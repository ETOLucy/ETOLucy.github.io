<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>PPT-考研操作系统 | Lucyの部落</title><meta name="author" content="Lucy"><meta name="copyright" content="Lucy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 操作系统引论操作系统的目标和作用OS的作用 OS是用户与计算机硬件系统之间的接口 OS是计算机系统资源的管理者 在一个计算机系统中，通常都含有各种各样的硬件和软件资源。归纳起来可将资源分为四类：**处理器、存储器、 I&#x2F;O设备以及信息(数据和程序)**。相应地，OS的主要功能也正是针对这四类资源进行有效的管理，即：处理机管理， 用于分配和控制处理机；存储器管理，主要负责内存的分配">
<meta property="og:type" content="article">
<meta property="og:title" content="PPT-考研操作系统">
<meta property="og:url" content="http://lucy23.blog/articles/c94444f9.html">
<meta property="og:site_name" content="Lucyの部落">
<meta property="og:description" content="第一章 操作系统引论操作系统的目标和作用OS的作用 OS是用户与计算机硬件系统之间的接口 OS是计算机系统资源的管理者 在一个计算机系统中，通常都含有各种各样的硬件和软件资源。归纳起来可将资源分为四类：**处理器、存储器、 I&#x2F;O设备以及信息(数据和程序)**。相应地，OS的主要功能也正是针对这四类资源进行有效的管理，即：处理机管理， 用于分配和控制处理机；存储器管理，主要负责内存的分配">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-03-08T06:52:46.000Z">
<meta property="article:modified_time" content="2025-03-11T11:32:04.402Z">
<meta property="article:author" content="Lucy">
<meta property="article:tag" content="Lucy的博客">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lucy23.blog/articles/c94444f9"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PPT-考研操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-11 19:32:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/myStyle.css"><div id="myscoll"></div><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cat-tou2.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lucyの部落</a></span><div id="he-plugin-simple"></div><div id="none_space"></div><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">PPT-考研操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-08T06:52:46.000Z" title="Created 2025-03-08 14:52:46">2025-03-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-11T11:32:04.402Z" title="Updated 2025-03-11 19:32:04">2025-03-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="PPT-考研操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h1><h2 id="操作系统的目标和作用"><a href="#操作系统的目标和作用" class="headerlink" title="操作系统的目标和作用"></a>操作系统的目标和作用</h2><h3 id="OS的作用"><a href="#OS的作用" class="headerlink" title="OS的作用"></a>OS的作用</h3><ol>
<li><strong>OS是用户与计算机硬件系统之间的接口</strong></li>
<li><strong>OS是计算机系统资源的管理者</strong><blockquote>
<p>在一个计算机系统中，通常都含有各种各样的硬件和软件资源。归纳起来可将资源分为四类：**处理器、存储器、 I&#x2F;O设备以及信息(数据和程序)**。相应地，OS的主要功能也正是针对这四类资源进行有效的管理，即：处理机管理， 用于分配和控制处理机；存储器管理，主要负责内存的分配与回收；I&#x2F;O设备管理，负责I&#x2F;O设备的分配与操纵；文件管理，负责文件的存取、共享和保护。可见，OS确是计算机系统资源的管理者。事实上，当今世界上广为流行的一个关于OS作用的观点，正是把OS作为计算机系统的资源管理者。</p>
</blockquote>
</li>
<li><strong>OS用作扩充机器</strong></li>
</ol>
<h3 id="系统调用："><a href="#系统调用：" class="headerlink" title="系统调用："></a><strong>系统调用：</strong></h3><ul>
<li>操作系统将计算机的资源（如CPU、内存、硬盘等）划分为两个空间：用户空间和内核空间。用户程序运行在用户空间，而操作系统的核心部分（内核）运行在内核空间。为了安全和稳定，用户程序不能直接访问内核空间，必须通过系统调用来请求内核服务。</li>
</ul>
<h2 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h2><h3 id="无操作系统的计算机系统"><a href="#无操作系统的计算机系统" class="headerlink" title="无操作系统的计算机系统"></a><strong>无操作系统</strong>的计算机系统</h3><ol>
<li>人工操作方式（穿孔纸带）</li>
</ol>
<ul>
<li>(1) 用户独占全机。(2) CPU等待人工操作。</li>
</ul>
<ol start="2">
<li>脱机输入&#x2F;输出方式</li>
</ol>
<ul>
<li>(1) 减少了CPU的空闲时间。(2) 提高I&#x2F;O速度。</li>
</ul>
<h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><ul>
<li>(1) 自动性。(2) 顺序性。(3) 单道性。</li>
</ul>
<h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><ul>
<li>(1) 提高CPU的利用率。(2) 可提高 [内存和I&#x2F;O设备] 利用率。(3) 增加系统吞吐量。<blockquote>
<p><strong>CPU利用率</strong>和<strong>系统吞吐量</strong>的关系<br>高CPU利用率并不一定带来高吞吐量。例如，如果CPU一直在处理低效的任务，CPU利用率可能很高，但吞吐量却很低。<br>高吞吐量通常需要较高的CPU利用率，但也受到其他系统资源的限制。</p>
</blockquote>
</li>
<li>(1) 多道性。(2) 无序性。(3) 调度性。</li>
<li>(1)资源利用率高。(2) 系统吞吐量大。(3) 平均周转时间长。(4) 无交互能力。 </li>
<li>需要解决：(1) 处理机管理问题。(2) 内存管理问题。(3) I&#x2F;O设备管理问题。(4) 文件管理问题。(5) 作业管理问题。</li>
</ul>
<h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><ul>
<li>计算机将CPU时间分成许多时间片，然后轮流分配给各个用户，由于切换速度很快，用户感觉就像独占计算机一样。</li>
<li>(1) 多路性。(2) 独立性。(3) 及时性。(4) 交互性。</li>
</ul>
<h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><ul>
<li>所谓“实时”，是表示“及时”，而实时系统(Real-Time System)是指系统能及时(或即时)响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</li>
</ul>
<p><strong>周期性实时任务</strong></p>
<ul>
<li><strong>定义：</strong> 任务以固定的时间间隔重复执行。</li>
<li><strong>例子：</strong><ul>
<li><strong>汽车防抱死系统（ABS）：</strong> 定期检测车轮速度，调整制动压力。</li>
<li><strong>工业自动化控制：</strong> 定期采样传感器数据，控制执行器。</li>
<li><strong>多媒体播放：</strong> 定期刷新屏幕，播放音频&#x2F;视频帧。</li>
<li><strong>雷达系统：</strong> 定期扫描指定区域。</li>
</ul>
</li>
</ul>
<p><strong>非周期性实时任务</strong></p>
<ul>
<li><strong>定义：</strong> 任务的执行时间不固定，由外部事件触发。</li>
<li><strong>例子：</strong><ul>
<li><strong>飞机紧急制动系统：</strong> 在检测到紧急情况时立即启动。</li>
<li><strong>医疗监护仪：</strong> 在检测到病人异常生理指标时发出警报。</li>
<li><strong>网络数据包处理：</strong> 在接收到网络数据包时进行处理。</li>
<li><strong>用户点击鼠标：</strong> 在用户点击鼠标时进行响应。</li>
</ul>
</li>
</ul>
<p><strong>硬实时任务</strong></p>
<ul>
<li><strong>定义：</strong> 任务必须在严格的时间限制内完成，否则会导致灾难性后果。</li>
<li><strong>例子：</strong><ul>
<li><strong>飞行控制系统：</strong> 任何延迟都可能导致飞机失控。</li>
<li><strong>核电站控制系统：</strong> 任何延迟都可能导致核泄漏。</li>
<li><strong>导弹制导系统：</strong> 任何延迟都可能导致目标丢失。</li>
<li><strong>汽车安全气囊系统：</strong> 在碰撞发生后，必须在极短的时间内展开。</li>
</ul>
</li>
</ul>
<p><strong>软实时任务</strong></p>
<ul>
<li><strong>定义：</strong> 任务尽可能在时间限制内完成，但偶尔的延迟是可以接受的。</li>
<li><strong>例子：</strong><ul>
<li><strong>多媒体播放：</strong> 偶尔的丢帧或卡顿不会导致严重后果。</li>
<li><strong>网络游戏：</strong> 偶尔的网络延迟会影响游戏体验，但不会导致游戏崩溃。</li>
<li><strong>视频会议：</strong> 偶尔的音频&#x2F;视频延迟是可以接受的。</li>
<li><strong>实时股票行情显示：</strong> 偶尔的延迟是可以接受的。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>周期性和非周期性是根据任务的执行频率来划分的。</li>
<li>硬实时和软实时是根据任务对时间限制的严格程度来划分的。</li>
<li>实际应用中，一个任务可能同时具有多种属性，例如，汽车ABS系统既是周期性任务，又是硬实时任务。</li>
</ul>
<h2 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a>操作系统的基本特性</h2><h3 id="并发-Concurrency"><a href="#并发-Concurrency" class="headerlink" title="并发 (Concurrency)"></a>并发 (Concurrency)</h3><ul>
<li><strong>定义:</strong> 指两个或多个事件在同一时间间隔内发生。</li>
</ul>
<h3 id="共享-Sharing"><a href="#共享-Sharing" class="headerlink" title="共享 (Sharing)"></a>共享 (Sharing)</h3><ul>
<li><strong>定义:</strong> 指系统中的资源可以被多个程序或用户共同使用。</li>
<li><strong>在操作系统中:</strong> 资源可以是硬件（如CPU、内存、磁盘）或软件（如文件、数据）。</li>
<li>(1) 互斥共享方式 (2) 同时访问方式</li>
</ul>
<h3 id="虚拟-Virtualization"><a href="#虚拟-Virtualization" class="headerlink" title="虚拟 (Virtualization)"></a>虚拟 (Virtualization)</h3><ul>
<li><strong>定义:</strong> 指通过技术手段将一个物理实体转化为多个逻辑实体，或者将多个物理实体转化为一个逻辑实体。</li>
<li><strong>在操作系统中:</strong><ul>
<li>虚拟内存：将物理内存扩展为更大的逻辑地址空间。</li>
<li>虚拟CPU：通过时间片轮转，使每个程序都感觉拥有独立的CPU。</li>
</ul>
</li>
<li><strong>关键点:</strong> 强调的是资源的逻辑抽象，这提高了资源的灵活性和效率。</li>
</ul>
<h3 id="异步-Asynchrony"><a href="#异步-Asynchrony" class="headerlink" title="异步 (Asynchrony)"></a>异步 (Asynchrony)</h3><ul>
<li>由于资源等因素的限制，使进程的执行通常都不是“一气呵成”，而是以“停停走走”的方式运行。 </li>
<li>进程是以人们不可预知的速度向前推进，此即进程的异步性。</li>
<li>尽管如此，但只要运行环境相同，作业经多次运行，都会获得完全相同的结果。因此，异步运行方式是允许的，是操作系统的一个重要特征。</li>
</ul>
<p>这四个概念是操作系统中非常重要的基本特征，它们共同构成了现代操作系统的基础。</p>
<h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h2><h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h3><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><ul>
<li>主要功能是为作业<strong>创建进程</strong>、<strong>撤消已结束的进程</strong>，以及<strong>控制进程在运行过程中的状态转换</strong>。</li>
</ul>
<h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><ul>
<li>进程同步的主要任务是为多个进程(含线程)的运行进行协调。</li>
<li>有两种协调方式： <ol>
<li>进程互斥方式， 这是指诸进程(线程)在对临界资源进行访问时， 应采用互斥方式； </li>
<li>进程同步方式，指在相互合作去完成共同任务的诸进程(线程)间，由同步机制对它们的执行次序加以协调。</li>
</ol>
</li>
<li>为了实现进程同步，系统中必须设置进程同步机制。最简单的用于实现进程互斥的机制，是为每一个<strong>临界资源</strong>配置一把<strong>锁W</strong>，当锁打开时，进程(线程)可以对该临界资源进行访问；而当锁关上时，则禁止进程(线程)访问该临界资源。</li>
</ul>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><ul>
<li>在多道程序环境下，为了加速应用程序的运行，应在系统中建立多个进程，并且再为一个进程建立若干个线程，由这些进程(线程)相互合作去完成一个共同的任务。而在这些进程(线程)之间，又往往需要交换信息。</li>
<li>当相互合作的进程(线程)处于同一计算机系统时，通常在它们之前是采用直接通信方式，即由源进程利用发送命令直接将消息(message)挂到目标进程的消息队列上，以后由目标进程利用接收命令从其消息队列中取出消息。</li>
</ul>
<h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><ul>
<li>在后备队列上等待的每个作业，通常都要经过调度才能执行。在传统的操作系统中，包括<strong>作业调度</strong>和<strong>进程调度</strong>两步。</li>
<li><strong>作业调度</strong>的基本任务，是从后备队列中按照一定的算法，选择出若干个作业，为它们分配其必需的资源(首先是分配内存)。 在将它们调入内存后，便分别为它们建立进程，使它们都成为可能获得处理机的就绪进程，并按照一定的算法将它们插入就绪队列。</li>
<li>而<strong>进程调度</strong>的任务，则是从进程的就绪队列中选出一新进程，把处理机分配给它，并为它设置运行现场， 使进程投入执行。</li>
<li>值得提出的是，在<strong>多线程OS</strong>中，通常是把<strong>线程</strong>作为独立运行和分配处理机的<strong>基本单位</strong>，为此，须把就绪线程排成一个队列，每次调度时，是从就绪线程队列中选出一个线程，把处理机分配给它。</li>
</ul>
<h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><ul>
<li>分配方式：<ol>
<li>静态分配</li>
<li>动态分配</li>
</ol>
</li>
<li>为了实现内存分配，在内存分配的机制中应具有这样的结构和功能：<ol>
<li>内存分配数据结构，该结构用于记录内存空间的使用情况，作为内存分配的依据；</li>
<li>内存分配功能，系统按照一定的内存分配算法，为用户程序分配内存空间；</li>
<li>内存回收功能，系统对于用户不再需要的内存，通过用户的释放请求，去完成系统的回收功能。</li>
</ol>
</li>
</ul>
<h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><ul>
<li><strong>主要任务</strong>是确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰。</li>
<li>一种比较简单的<strong>内存保护机制</strong>，是设置<strong>两个界限寄存器</strong>，分别用于存放正在执行程序的上界和下界。</li>
<li>系统须对每条指令所要访问的地址进行检查，如果发生越界，便发出越界中断请求，以停止该程序的执行。</li>
<li>如果这种检查完全用软件实现，则每执行一条指令，便须增加若干条指令去进行越界检查，这将显著降低程序的运行速度。<strong>因此，越界检查都由硬件实现。</strong>当然，对发生越界后的处理，<strong>还须与软件配合来完成。</strong></li>
</ul>
<h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><ul>
<li>地址映射是逻辑地址到物理地址的映射。</li>
<li>为使程序能正确运行，存储器管理必须提供地址映射功能，以将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。该功能应在硬件的支持下完成。</li>
</ul>
<h4 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h4><ul>
<li>借助<strong>虚拟存储技术</strong>，<strong>从逻辑上</strong>去扩充内存容量，使用户所感觉到的内存容量比实际内存容量大得多；或者是让更多的用户程序能并发运行。</li>
<li>用于实现下述各功能：<br>(1) 请求调入功能。<br>(2) 置换功能。</li>
</ul>
<p><strong>1. 请求调入功能</strong></p>
<ul>
<li><strong>概念：</strong><ul>
<li>当程序运行时，并非所有代码和数据都需要立即加载到物理内存中。</li>
<li>请求调入功能允许操作系统只将当前需要的程序部分（例如，代码页或数据页）加载到内存中。</li>
<li>当程序尝试访问不在内存中的部分时，会产生一个“缺页中断”，操作系统会响应这个中断，并将所需的部分从磁盘（或其他存储介质）加载到内存中。</li>
</ul>
</li>
<li><strong>作用：</strong><ul>
<li>提高内存利用率：只加载必要的部分，减少了内存的浪费。</li>
<li>支持更大的程序：允许程序使用比物理内存更大的地址空间。</li>
</ul>
</li>
</ul>
<p><strong>2. 置换功能</strong></p>
<ul>
<li><strong>概念：</strong><ul>
<li>当物理内存已满，而程序又需要加载新的部分时，操作系统必须腾出一些空间。</li>
<li>置换功能负责选择哪些内存中的部分应该被移出到磁盘（或其他存储介质），以便为新的部分腾出空间。</li>
<li><strong>置换算法（例如，LRU、FIFO）</strong>用于决定哪些部分应该被置换。</li>
</ul>
</li>
<li><strong>作用：</strong><ul>
<li>管理有限的物理内存：确保在内存不足时，系统能够继续运行。</li>
<li>优化内存使用：通过合理的置换算法，尽量减少频繁的磁盘I&#x2F;O操作。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>请求调入和置换是虚拟内存技术的关键组成部分。</li>
<li>它们共同工作，使得程序可以使用比实际物理内存更大的地址空间，并提高了内存的利用率。</li>
<li>虚拟内存是现代操作系统中至关重要的技术。</li>
</ul>
<h3 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a>设备管理功能</h3><h4 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h4><ul>
<li>如果在I&#x2F;O设备和CPU之间引入缓冲，则<strong>可有效地缓和CPU（高速）和I&#x2F;O设备速度（低速）不匹配的矛盾</strong>，提高CPU的利用率，进而提高系统吞吐量。 </li>
<li>因此，<strong>在现代计算机系统中，</strong>都毫无例外地在内存中设置了缓冲区，而且还可通过增加缓冲区容量的方法，来改善系统的性能。</li>
<li>最常见的缓冲区机制有单缓冲机制、能实现双向同时传送数据的双缓冲机制，以及能供多个设备同时使用的公用缓冲池机制。</li>
</ul>
<h4 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h4><ul>
<li>根据用户进程的I&#x2F;O请求、系统的现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。</li>
<li>如果在I&#x2F;O设备和CPU之间，还存在着设备控制器和I&#x2F;O通道时，还须为分配出去的设备分配相应的控制器和通道。</li>
<li>系统中应设置设备控制表、控制器控制表等数据结构，用于记录设备及控制器的标识符和状态。据这些表格可以了解指定设备当前是否可用，是否忙碌，以供进行设备分配时参考。</li>
<li>在进行设备分配时，应针对不同的设备类型而采用不同的设备分配方式。对于独占设备(临界资源)的分配，还应考虑到该设备被分配出去后，系统是否安全。设备使用完后，还应立即由系统回收。</li>
</ul>
<h4 id="设备处理"><a href="#设备处理" class="headerlink" title="设备处理"></a>设备处理</h4><ul>
<li><strong>设备处理程序</strong>又称为<strong>设备驱动程序</strong>。</li>
<li>其<strong>基本任务</strong>是用于实现CPU和设备控制器之间的通信，即由CPU向设备控制器发出I&#x2F;O命令，要求它完成指定的I&#x2F;O操作；反之由CPU接收从控制器发来的中断请求，并给予迅速的响应和相应的处理。</li>
<li>处理过程是：<ol>
<li>设备处理程序首先检查I&#x2F;O请求的合法性，了解设备状态是否是空闲的，了解有关的传递参数及设置设备的工作方式。</li>
<li>然后，便向设备控制器发出I&#x2F;O命令，启动I&#x2F;O设备去完成指定的I&#x2F;O操作。</li>
</ol>
</li>
<li>设备驱动程序还应能及时响应由控制器发来的中断请求，并根据该中断请求的类型，调用相应的中断处理程序进行处理。对于设置了通道的计算机系统， 设备处理程序还应能根据用户的I&#x2F;O请求，自动地构成通道程序。</li>
</ul>
<h4 id="虚拟设备"><a href="#虚拟设备" class="headerlink" title="虚拟设备"></a>虚拟设备</h4><blockquote>
<p>（没介绍）</p>
</blockquote>
<h3 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h3><h4 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h4><ul>
<li>为每个文件分配必要的外存空间，提高外存的利用率，并能有助于提高文件系统的运行速度。</li>
<li>为此，系统<ol>
<li>应设置相应的数据结构，用于记录文件存储空间的使用情况，以供分配存储空间时参考；</li>
<li>还应具有对存储空间进行分配和回收的功能。</li>
</ol>
</li>
<li>为了提高存储空间的利用率，对存储空间的分配，通常是采用离散分配方式，以减少外存零头，并以盘块为基本分配单位。盘块的大小通常为512 B~8 KB。</li>
</ul>
<h4 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h4><ul>
<li>为了使用户能方便地在外存上找到自己所需的文件，通常由系统为每个文件建立一个目录项。</li>
<li>目录项包括文件名、文件属性、文件在磁盘上的物理位置等。由若干个目录项又可构成一个目录文件。</li>
<li>目录管理的<strong>主要任务</strong>， 是为每个文件建立其目录项，并对众多的目录项加以有效的组织，以实现方便的按名存取。即用户只须提供文件名，即可对该文件进行存取。其次，目录管理还应能实现文件共享，这样，只须在外存上保留一份该共享文件的副本。此外，还应能提供快速的目录查询手段，以提高对文件的检索速度。</li>
</ul>
<h4 id="文件的读-写管理和保护"><a href="#文件的读-写管理和保护" class="headerlink" title="文件的读&#x2F;写管理和保护"></a>文件的读&#x2F;写管理和保护</h4><ol>
<li><strong>文件的读&#x2F;写管理。</strong>该功能是根据用户的请求，从外存中读取数据；或将数据写入外存。在进行文件读(写)时，系统先根据用户给出的文件名，去检索文件目录，从中获得文件在外存中的位置。然后，利用文件读(写)指针，对文件进行读(写)。一旦读(写)完成，便修改读(写)指针，为下一次读(写)做好准备。由于读和写操作不会同时进行，故可合用一个读&#x2F;写指针。</li>
<li><strong>文件保护。</strong>① 防止未经核准的用户存取文件； ② 防止冒名顶替存取文件； ③ 防止以不正确的方式使用文件。</li>
</ol>
<h4 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h4><ol>
<li>命令接口<br>  (1) 联机用户接口（终端或控制台）<br>  (2) 脱机用户接口（也称批处理用户接口）</li>
<li>程序接口</li>
</ol>
<ul>
<li>由一组系统调用组成，每一个系统调用都是一个能完成特定功能的子程序，每当应用程序要求OS提供某种服务(功能)时，便调用具有相应功能的系统调用。</li>
</ul>
<ol start="3">
<li>图形接口</li>
</ol>
<ul>
<li>用户虽然可以通过联机用户接口来取得OS的服务，但这时要求用户能熟记各种命令的名字和格式，并严格按照规定的格式输入命令，这既不方便又花时间，于是，图形用户接口便应运而生。</li>
<li>图形用户接口采用了图形化的操作界面， 用非常容易识别的各种图标(icon)来将系统的各项功能、各种应用程序和文件，直观、逼真地表示出来。用户可用鼠标或通过菜单和对话框，来完成对应用程序和文件的操作。</li>
<li>此时用户已完全不必像使用命令接口那样去记住命令名及格式，从而把用户从繁琐且单调的操作中解脱出来。</li>
</ul>
<h2 id="操作系统的结构设计"><a href="#操作系统的结构设计" class="headerlink" title="操作系统的结构设计"></a>操作系统的结构设计</h2><h3 id="软件工程的基本概念"><a href="#软件工程的基本概念" class="headerlink" title="软件工程的基本概念"></a>软件工程的基本概念</h3><h4 id="软件的含义"><a href="#软件的含义" class="headerlink" title="软件的含义"></a>软件的含义</h4><ul>
<li>所谓软件，是指<strong>当计算机运行时，能提供所要求的【功能和性能】的【指令和程序】的集合，该程序能够正确地处理信息的数据结构</strong>；作为规范软件，还应具有描述程序功能需求以及程序如何操作使用的文档。</li>
<li>如果说，硬件是物理部件，那么，软件则是一种逻辑部件，它具有与硬件完全不同的特点。</li>
</ul>
<h4 id="软件工程的含义"><a href="#软件工程的含义" class="headerlink" title="软件工程的含义"></a>软件工程的含义</h4><ul>
<li>软件工程是指运用【系统的、规范的和可定量】的方法，来【开发、运行和维护软件】；或者说，是采用工程的概念、原理、技术和方法，来开发与维护软件，其目的是为了解决在软件开发中所出现的编程随意、软件质量不可保证以及维护困难等问题。</li>
</ul>
<h3 id="传统的操作系统结构"><a href="#传统的操作系统结构" class="headerlink" title="传统的操作系统结构"></a>传统的操作系统结构</h3><ul>
<li>操作系统是一个十分复杂的大型软件。为了控制该软件的复杂性，在开发OS时，先后引入了分解、模块化、 抽象和隐蔽等方法。开发方法的不断发展，促进了OS结构的更新换代。这里，我们把第一代至第三代的OS结构， 称为传统的OS结构，而把微内核的OS结构称为现代OS结构。</li>
</ul>
<h4 id="无结构操作系统"><a href="#无结构操作系统" class="headerlink" title="无结构操作系统"></a>无结构操作系统</h4><h4 id="模块化OS结构"><a href="#模块化OS结构" class="headerlink" title="模块化OS结构"></a>模块化OS结构</h4><ul>
<li><p>每个模块具有某方面的管理功能，如进程管理模块、存储器管理模块、I&#x2F;O设备管理模块和文件管理模块等，并规定好各模块间的接口， 使各模块之间能通过该接口实现交互，然后再进一步将各模块细分为若干个具有一定管理功能的子模块，如把进程管理模块又分为进程控制、 进程同步、 进程通信和进程调度等子模块， 同样也要规定各子模块之间的接口。若子模块较大时，再进一步将它细分。</p>
<img src="/articles/c94444f9/模块化OS结构.png" width=70% height=70% />
</li>
<li><p>优点：</p>
<ol>
<li>提高了OS设计的正确性、可理解性和可维护性。 </li>
<li>增强了OS的可适应性。 </li>
<li>加速了OS的开发过程。</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>在开始设计OS时，对模块的划分及对接口的规定并不精确，而且还可能存在错误，因而很难保证按此规定所设计出的模块会完全正确，这将使在把这些模块装配成OS时发生困难；</li>
<li>其次，从功能观点来划分模块时，未能将共享资源和独占资源加以区别；</li>
<li>由于管理上的差异，又会使模块间存在着复杂的依赖关系使OS结构变得不清晰。</li>
</ol>
</li>
</ul>
<h4 id="分层式OS结构"><a href="#分层式OS结构" class="headerlink" title="分层式OS结构"></a>分层式OS结构</h4><ul>
<li>分层式结构设计的基本原则是：每一层都仅使用其底层所提供的功能和服务，这样可使系统的调试和验证都变得容易。</li>
<li>层次的设置：<ol>
<li><p><strong>程序嵌套。</strong>通常OS的每个功能的实现，并非是只用一个程序便能完成的，而是要经由若干个软件层才有可能完成。因此在划分OS层次时，首先要考虑在实现OS 的每个功能时所形成的程序嵌套。例如，作业调度模块须调用进程控制模块；在为某作业创建一进程时，进程控制模块又须调用内存管理模块为新进程分配内存空间，可见，进程控制模块应在内存管理模块之上； 而作业调度模块又应在更高层。</p>
</li>
<li><p><strong>运行频率。</strong>在分层结构中，各层次软件的运行速度是不同的，因为A1层软件能直接在物理机器上运行，故它有最高的运行速度。随着层次的增高，其相应软件的运行速度就随之下降，因而An层软件的运行速度最低。为了提高OS的运行效率，应该将那些经常活跃的模块放在最接近硬件的A1层，如时钟管理、进程调度，通常都放在A1层。</p>
</li>
<li><p>公用模块。应把供多种资源管理程序调用的公用模块，设置在最低层，不然，会使比它低的层次模块由于无法调用它而须另外配置相应功能的模块。例如，用于对<strong>信号量</strong>进行操作<strong>的</strong>原语Signal和Wait。</p>
<blockquote>
<p>这里提到<strong>信号量（Semaphore）</strong>是因为它是操作系统中用于进程同步与互斥的重要机制。信号量操作（如 Signal 和 Wait）通常是多个资源管理模块都会用到的基本功能，因此应放置在系统的底层，作为公用模块提供服务。这样可以避免不同模块重复实现相同的功能，提高系统的结构合理性和资源利用效率。</p>
</blockquote>
</li>
<li><p>用户接口。为方便用户(程序)，OS向用户提供了“用户与OS的接口”，如命令接口、程序接口以及图形用户接口。这些接口应设置在OS的最高层，直接提供给用户使用。</p>
</li>
</ol>
</li>
</ul>
<h3 id="微内核OS结构"><a href="#微内核OS结构" class="headerlink" title="微内核OS结构"></a>微内核OS结构</h3><h4 id="客户-服务器模式-Client-Server-Model"><a href="#客户-服务器模式-Client-Server-Model" class="headerlink" title="客户&#x2F;服务器模式(Client-Server Model)"></a>客户&#x2F;服务器模式(Client-Server Model)</h4><ul>
<li>为了提高OS的灵活性和可扩充性而将OS划分为两部分，一部分是<strong>用于提供各种服务的一组服务器(进程)<strong>，如用于提供进程管理的进程服务器、提供存储器管理的存储器服务器和提供文件管理的文件服务器等，所有这些服务器(进程)都运行在用户态。当有一</strong>用户进程(现在称为客户进程)<strong>要求读文件的一个盘块时，该进程便向文件服务器(进程)发出一个请求；当服务器完成了该客户的请求后，便给该客户回送一个响应。操作系统的另一部分是</strong>内核</strong>，<strong>用来处理客户和服务器之间的通信</strong>， 即由内核来接收客户的请求，再将该请求送至相应的服务器；同时它也接收服务器的应答，并将此应答回送给请求客户。此外，在内核中还应具有其它一些机构，用于实现与硬件紧密相关的和一些较基本的功能。<blockquote>
<p>平时我们提到 <strong>“服务器”</strong> 往往指的是云端或远程计算机提供的服务。但<strong>在操作系统（OS）内部，“服务器”指的是运行在用户态的系统进程，专门提供某些操作系统功能的服务。</strong></p>
</blockquote>
</li>
</ul>
<img src="/articles/c94444f9/C-S模式.png" width="70%" height="70%" />
<p style="text-align: center;">单机环境下的客户/服务器模式</p>

<ul>
<li>优点：<ol>
<li>提高了系统的灵活性和可扩充性。 </li>
<li>提高了OS的可靠性。 </li>
<li>可运行于分布式系统中。</li>
</ol>
</li>
</ul>
<h4 id="面向对象的程序设计技术-Object-Orientated-Programming"><a href="#面向对象的程序设计技术-Object-Orientated-Programming" class="headerlink" title="面向对象的程序设计技术(Object-Orientated Programming)"></a>面向对象的程序设计技术(Object-Orientated Programming)</h4><ul>
<li><strong>面向对象技术的基本概念</strong><br>面向对象技术是20世纪80年代初提出并很快流行起来的。该技术是基于“抽象”和“隐蔽”原则来控制大型软件的复杂度的。所谓对象，是指在现实世界中具有相同属性、服从相同规则的一系列事物的抽象，而把其中的具体事物称为对象的实例。OS中的各类实体如进程、线程、消息、存储器等，都使用了对象这一概念，相应地，便有进程对象线程对象、 存储器对象等。 </li>
<li><strong>优点</strong><ol>
<li><strong>可修改性和可扩充性。</strong>由于隐蔽了表示实体的数据和操作，因而可以改变对象的表示而不会影响其它部分， 从而可以方便地改变老的对象和增加新的对象。</li>
<li><strong>继承性。</strong>继承性是面向对象技术所具有的重要特性。继承性是指子对象可以继承父对象的属性，这样，在创建一个新的对象时， 便可减少大量的时空开销。</li>
<li><strong>正确性和可靠性。</strong>由于对象是构成操作系统的基本单元，可以独立地对它进行测试，这样，比较易于保证其正确性和可靠性，从而比较容易保证整个系统的正确性和可靠性。</li>
</ol>
</li>
</ul>
<h4 id="微内核技术"><a href="#微内核技术" class="headerlink" title="微内核技术"></a>微内核技术</h4><ul>
<li>所谓微内核技术，是指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS(程序)不同， 它更小更精炼，它不仅运行在核心态，而且开机后常驻内存， 它不会因内存紧张而被换出内存。微内核并非是一个完整的OS， 而只是为构建通用OS提供一个重要基础。由于在微内核OS结构中，通常都采用了客户&#x2F;服务器模式，因此OS的大部分功能和服务，都是由若干服务器来提供的， 如文件服务器、作业服务器和网络服务器等。</li>
<li>微内核所提供的功能，通常都是一些最基本的功能，如进程管理、存储器管理、进程间通信、低级I&#x2F;O功能。</li>
</ul>
<h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><h2 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h2><h3 id="程序顺序执行时的特征"><a href="#程序顺序执行时的特征" class="headerlink" title="程序顺序执行时的特征"></a>程序顺序执行时的特征</h3><ol>
<li>顺序性</li>
<li>封闭性</li>
<li>可再现性</li>
</ol>
<h3 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h3><ul>
<li>前趋图(Precedence Graph)是一个<strong>有向无循环图</strong>，记为<strong>DAG</strong>(Directed Acyclic Graph)，用于描述进程之间执行的前后关系。</li>
<li>在前趋图中，把<strong>没有前趋</strong>的结点称为<strong>初始结点</strong>(Initial Node)，把<strong>没有后继</strong>的结点称为<strong>终止结点</strong>(Final Node)。<img src="/articles/c94444f9/并发执行的前趋图.png" width=70% height=70% /></li>
</ul>
<h3 id="程序并发执行时的特征"><a href="#程序并发执行时的特征" class="headerlink" title="程序并发执行时的特征"></a>程序并发执行时的特征</h3><ol>
<li>间断性</li>
<li>失去封闭性 </li>
<li>不可再现性</li>
</ol>
<h3 id="进程的特征与状态"><a href="#进程的特征与状态" class="headerlink" title="进程的特征与状态"></a>进程的特征与状态</h3><h4 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h4><ol>
<li>结构特征</li>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
</ol>
<h4 id="较典型的进程的定义有："><a href="#较典型的进程的定义有：" class="headerlink" title="较典型的进程的定义有："></a>较典型的进程的定义有：</h4><ol>
<li>进程是程序的一次执行。</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li>
<li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li>
<li>在引入了进程实体的概念后，我们可以把传统OS中的进程定义为：<strong>“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位”</strong>。</li>
</ol>
<h4 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种<strong>基本</strong>状态</h4><ol>
<li>就绪(Ready)状态 </li>
<li>执行状态</li>
<li>阻塞状态</li>
</ol>
<img src="/articles/c94444f9/进程的三种基本状态及其转换.png" width=40% height=70% />

<h4 id="挂起状态"><a href="#挂起状态" class="headerlink" title="挂起状态"></a>挂起状态</h4><ul>
<li>引入挂起状态的原因 <ol>
<li>终端用户的请求。 </li>
<li>父进程请求。 </li>
<li>负荷调节的需要。 </li>
<li>操作系统的需要。</li>
</ol>
</li>
</ul>
<h4 id="进程状态的转换"><a href="#进程状态的转换" class="headerlink" title="进程状态的转换"></a><strong>进程状态的转换</strong></h4><p>在操作系统中，进程可能会经历多个状态，包括：</p>
<ul>
<li><strong>运行（Running）</strong>：进程正在 CPU 上执行。</li>
<li><strong>就绪（Ready）</strong>：进程已获得所有必要资源，等待 CPU 调度执行。<ul>
<li><strong>活动就绪（Active Ready）</strong>：进程保留在内存中，随时可以被 CPU 调度。</li>
<li><strong>静止就绪（Suspended Ready）</strong>：进程被挂起，暂时存放在外存中，需调回内存后才能被调度执行。</li>
</ul>
</li>
<li><strong>阻塞（Blocked）</strong>：进程正在等待某个事件（如 I&#x2F;O 结束）。<ul>
<li><strong>活动阻塞（Active Blocked）</strong>：进程在内存中等待事件。</li>
<li><strong>静止阻塞（Suspended Blocked）</strong>：进程被挂起，存放在外存，且仍在等待事件发生。</li>
</ul>
</li>
</ul>
<h4 id="进程状态的转换-1"><a href="#进程状态的转换-1" class="headerlink" title="进程状态的转换"></a>进程状态的转换</h4><ol>
<li>活动就绪→静止就绪。<blockquote>
<p>由于系统资源管理（如内存不足），某个就绪进程可能会被挂起并移至外存。</p>
</blockquote>
</li>
<li>活动阻塞→静止阻塞。 <blockquote>
<p>系统需要腾出内存，某个正在等待 I&#x2F;O 或其他事件的阻塞进程被挂起并移至外存。</p>
</blockquote>
</li>
<li>静止就绪→活动就绪。<blockquote>
<p>当系统资源充足（如内存可用）时，进程从外存调入内存，回到“活动就绪”状态，等待 CPU 调度。 </p>
</blockquote>
</li>
<li>静止阻塞→活动阻塞。 <blockquote>
<p>进程从外存恢复到内存，但仍然在等待事件完成。</p>
</blockquote>
</li>
</ol>
<img src="/articles/c94444f9/具有挂起状态的进程状态图.png" width=40% height=70% />

<h4 id="进程控制块（PCB，Process-Control-Block）"><a href="#进程控制块（PCB，Process-Control-Block）" class="headerlink" title="进程控制块（PCB，Process Control Block）"></a>进程控制块（PCB，Process Control Block）</h4><ul>
<li><p>进程控制块的<strong>作用</strong>：</p>
<ul>
<li>是使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。</li>
</ul>
</li>
<li><p>进程控制块中的<strong>信息</strong>：</p>
<ol>
<li><strong>进程标识符（两种）</strong></li>
</ol>
<ol>
<li><p>内部标识符。</p>
<blockquote>
<p>在所有的操作系统中，都为每一个进程赋予一个惟一的数字标识符，<strong>它通常是一个进程的序号</strong>。<br><strong>设置内部标识符主要是为了方便系统使用。</strong></p>
</blockquote>
</li>
<li><p>外部标识符。</p>
<blockquote>
<p>它由创建者提供，通常是由字母、数字组成，往往是由用户(进程)<strong>在访问该进程时</strong>使用。<br>为了描述进程的家族关系，还应设置父进程标识及子进程标识。<br>此外，还可设置用户标识，以指示拥有该进程的用户。</p>
</blockquote>
</li>
</ol>
<ol start="2">
<li><strong>处理机状态</strong><blockquote>
<p>处理机状态信息主要是由处理机的<strong>各种寄存器</strong>中的内容组成的。</p>
</blockquote>
</li>
</ol>
<ol>
<li>通用寄存器，又称为用户可视寄存器，它们是用户程序可以访问的，用于暂存信息，在大多数处理机中，有 8~32 个通用寄存器，在RISC结构的计算机中可超过 100 个；</li>
<li>指令计数器，其中存放了要访问的下一条指令的地址；</li>
<li>程序状态字PSW，其中含有状态信息，如条件码、执行方式、中断屏蔽标志等；</li>
<li>用户栈指针，指每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶。</li>
</ol>
<ol start="3">
<li><strong>进程调度信息</strong><blockquote>
<p>在PCB中还存放一些与进程调度和进程对换有关的信息，包括：</p>
</blockquote>
</li>
</ol>
<ol>
<li>进程状态，指明进程的当前状态，作为进程调度和对换时的依据；</li>
<li>进程优先级，用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机；</li>
<li>进程调度所需的其它信息，它们与所采用的进程调度算法有关，比如，进程已等待CPU的时间总和、进程已执行的时间总和等；</li>
<li>事件，是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。</li>
</ol>
<ol start="4">
<li><strong>进程控制信息</strong><blockquote>
<p>进程控制信息包括：</p>
</blockquote>
</li>
</ol>
<ol>
<li>程序和数据的地址，是指进程的程序和数据所在的内存或外存地(首)址，以便再调度到该进程执行时，能从PCB中找到其程序和数据；</li>
<li>进程同步和通信机制，指实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等，它们可能全部或部分地放在PCB中；</li>
<li>资源清单，是一张列出了除CPU以外的、进程所需的全部资源及已经分配到该进程的资源的清单；</li>
<li>链接指针，它给出了本进程(PCB)所在队列中的下一个进程的PCB的首地址。</li>
</ol>
</li>
<li><p>进程控制块的<strong>组织方式</strong>：</p>
<ol>
<li><strong>链接方式</strong><img src="/articles/c94444f9/链接方式.png" width=70% height=70% />
<p style="text-align: center;">PCB链接队列示意图</p></li>
<li><strong>索引方式</strong><img src="/articles/c94444f9/索引方式.png" width=70% height=70% />
<p style="text-align: center;">按索引方式组织PCB</p></li>
</ol>
</li>
</ul>
<h2 id="进程控制-1"><a href="#进程控制-1" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><h4 id="进程图"><a href="#进程图" class="headerlink" title="进程图"></a>进程图</h4><img src="/articles/c94444f9/进程树.png" width=70% height=70% />
<p style="text-align: center;">进程树</p>

<h4 id="引起进程创建的事件"><a href="#引起进程创建的事件" class="headerlink" title="引起进程创建的事件"></a>引起进程创建的事件</h4><ol>
<li>用户登录。 </li>
<li>作业调度。 </li>
<li>提供服务。 </li>
<li>应用请求。</li>
</ol>
<h4 id="进程的创建-1"><a href="#进程的创建-1" class="headerlink" title="进程的创建"></a>进程的创建</h4><ol>
<li>申请空白PCB。 </li>
<li>为新进程分配资源。 </li>
<li>初始化进程控制块。 </li>
<li>将新进程插入就绪队列，如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。</li>
</ol>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><h4 id="引起进程终止-Termination-of-Process-的事件"><a href="#引起进程终止-Termination-of-Process-的事件" class="headerlink" title="引起进程终止(Termination of Process)的事件"></a>引起进程终止(Termination of Process)的事件</h4><ul>
<li><p><strong>正常结束</strong><br>在任何计算机系统中，都应有一个用于表示进程已经运行完成的指示。例如，在批处理系统中，通常在程序的最后安排一条Holt指令或终止的系统调用。当程序运行到Holt指令时，将产生一个中断，去通知OS本进程已经完成。 在分时系统中，用户可利用Logs off去表示进程运行完毕， 此时同样可产生一个中断，去通知OS进程已运行完毕。 </p>
</li>
<li><p><strong>异常结束</strong><br>在进程运行期间，由于出现某些错误和故障而迫使进程终止。这类异常事件很多，常见的有：</p>
<ol>
<li>越界错误。这是指程序所访问的存储区，已越出该进程的区域； </li>
<li>保护错误。进程试图去访问一个不允许访问的资源或文件，或者以不适当的方式进行访问，例如，进程试图去写一个只读文件； </li>
<li>非法指令。程序试图去执行一条不存在的指令。出现该错误的原因，可能是程序错误地转移到数据区，把数据当成了指令；</li>
<li>特权指令错误。用户进程试图去执行一条只允许OS执行的指令； </li>
<li>运行超时。进程的执行时间超过了指定的最大值； </li>
<li>等待超时。进程等待某事件的时间， 超过了规定的最大值；</li>
<li>算术运算错。进程试图去执行一个被禁止的运算，例如，被0除；</li>
<li>I&#x2F;O故障。这是指在I&#x2F;O过程中发生了错误等。</li>
</ol>
</li>
<li><p><strong>外界干预</strong><br>外界干预并非指在本进程运行中出现了异常事件，而是指进程应外界的请求而终止运行。这些干预有： </p>
<ol>
<li>操作员或操作系统干预。 由于某种原因，例如，发生了死锁， 由操作员或操作系统终止该进程； </li>
<li>父进程请求。 由于父进程具有终止自己的任何子孙进程的权利， 因而当父进程提出请求时，系统将终止该进程； </li>
<li>父进程终止。 当父进程终止时，OS也将他的所有子孙进程终止。</li>
</ol>
</li>
</ul>
<h4 id="进程的终止过程"><a href="#进程的终止过程" class="headerlink" title="进程的终止过程"></a>进程的终止过程</h4><ol>
<li>根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态。</li>
<li>若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。</li>
<li>若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控的进程。</li>
<li>将被终止进程所拥有的全部资源，或者归还给其父进程， 或者归还给系统。</li>
<li>将被终止进程(它的PCB)从所在队列(或链表)中移出， 等待其他程序来搜集信息。</li>
</ol>
<h3 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h3><h4 id="引起进程阻塞和唤醒的事件"><a href="#引起进程阻塞和唤醒的事件" class="headerlink" title="引起进程阻塞和唤醒的事件"></a>引起进程阻塞和唤醒的事件</h4><ol>
<li>请求系统服务</li>
<li>启动某种操作</li>
<li>新数据尚未到达</li>
<li>无新工作可做</li>
</ol>
<h4 id="进程阻塞过程"><a href="#进程阻塞过程" class="headerlink" title="进程阻塞过程"></a>进程阻塞过程</h4><ul>
<li>正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用阻塞原语block把自己阻塞。可见，进程的阻塞是进程自身的一种主动行为。进入block过程后，由于此时该进程还处于执行状态，所以应先立即停止执行，把进程控制块中的现行状态由“执行”改为阻塞，并将PCB插入阻塞队列。如果系统中设置了因不同事件而阻塞的多个阻塞队列，则应将本进程插入到具有相同事件的阻塞(等待)队列。 最后，转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换，亦即，保留被阻塞进程的处理机状态(在PCB中)，再按新进程的PCB中的处理机状态设置CPU的环境。</li>
</ul>
<h4 id="进程唤醒过程"><a href="#进程唤醒过程" class="headerlink" title="进程唤醒过程"></a>进程唤醒过程</h4><ul>
<li>正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用阻塞原语block把自己阻塞。可见，进程的阻塞是进程自身的一种主动行为。进入block过程后，由于此时该进程还处于执行状态，所以应先立即停止执行，把进程控制块中的现行状态由“执行”改为阻塞，并将PCB插入阻塞队列。如果系统中设置了因不同事件而阻塞的多个阻塞队列，则应将本进程插入到具有相同事件的阻塞(等待)队列。 最后，转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换，亦即，保留被阻塞进程的处理机状态(在PCB中)，再按新进程的PCB中的处理机状态设置CPU的环境。</li>
</ul>
<h3 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a>进程的挂起与激活</h3><h4 id="进程的挂起过程"><a href="#进程的挂起过程" class="headerlink" title="进程的挂起过程"></a>进程的挂起过程</h4><ul>
<li>当出现了引起进程挂起的事件时，比如，用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起， 系统将利用挂起原语suspend( )将指定进程或处于阻塞状态的进程挂起。挂起原语的执行过程是：首先检查被挂起进程的状态，<strong>若处于活动就绪状态，便将其改为静止就绪；对于活动阻塞状态的进程，则将之改为静止阻塞。</strong>为了方便用户或父进程考查该进程的运行情况而把该进程的PCB复制到某指定的内存区域。最后，若被挂起的进程正在执行，则转向调度程序重新调度。</li>
</ul>
<h4 id="进程的激活过程"><a href="#进程的激活过程" class="headerlink" title="进程的激活过程"></a>进程的激活过程</h4><ul>
<li>当发生激活进程的事件时，例如，父进程或用户进程请求激活指定进程，若该进程驻留在外存而内存中已有足够的空间时，则可将在外存上处于静止就绪状态的进程换入内存。这时，系统将利用激活原语active( )将指定进程激活。<u> 激活原语先将进程从外存调入内存，检查该进程的现行状态，若是静止就绪，便将之改为活动就绪；若为静止阻塞便将之改为活动阻塞。假如采用的是抢占调度策略，则每当有新进程进入就绪队列时，应检查是否要进行重新调度，即由调度程序将被激活进程与当前进程进行优先级的比较，如果被激活进程的优先级更低，就不必重新调度；否则，立即剥夺当前进程的运行，把处理机分配给刚被激活的进程。 </u></li>
</ul>
<h2 id="进程同步-1"><a href="#进程同步-1" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h3><h4 id="两种形式的制约关系"><a href="#两种形式的制约关系" class="headerlink" title="两种形式的制约关系"></a>两种形式的制约关系</h4><ol>
<li>间接相互制约关系</li>
<li>直接相互制约关系</li>
</ol>
<h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a><strong>临界资源</strong></h4><ul>
<li><strong>生产者-消费者(producer-consumer)问题</strong><blockquote>
<p>生产者-消费者(producer-consumer)问题是一个著名的<strong>进程同步</strong>问题。<br>它描述的是：有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个<strong>具有n个缓冲区</strong>的<strong>缓冲池</strong>，生产者进程将它所生产的产品放入一个缓冲区中； 消费者进程可从一个缓冲区中取走产品去消费。尽管所有的生产者进程和消费者进程都是以异步方式运行的，<strong>但它们之间必须保持同步，</strong><u>即不允许消费者进程到一个空缓冲区去取产品；也不允许生产者进程向一个已装满产品且尚未被取走的缓冲区中投放产品。</u> </p>
</blockquote>
<ul>
<li>我们可利用一个数组来表示上述的具有n个(0，1，…，n-1)缓冲区的缓冲池。用输入指针in来指示下一个可投放产品的缓冲区，每当生产者进程生产并投放一个产品后，输入指针加1；用一个输出指针out来指示下一个可从中获取产品的缓冲区，每当消费者进程取走一个产品后，输出指针加1。 由于这里的缓冲池是组织成<strong>循环缓冲</strong>的，故应把输入指针加1表示成 in:&#x3D;(in+1)mod n；输出指针加1表示成out:&#x3D;(out+1) mod n。当(in+1) mod n&#x3D;out时表示缓冲池满；而in&#x3D;out则表示缓冲池空。此外，还引入了一个整型变量counter, 其初始值为0。每当生产者进程向缓冲池中投放一个产品后，使counter加1；反之，每当消费者进程从中取走一个产品时， 使counter减1。生产者和消费者两进程共享下面的变量： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Var n, integer;</span><br><span class="line"><span class="keyword">type</span> item=…;</span><br><span class="line"><span class="keyword">var</span> buffer:array［<span class="number">0</span>, <span class="number">1</span>, …, n<span class="number">-1</span>］ of item;</span><br><span class="line">in, out: <span class="number">0</span>, <span class="number">1</span>, …, n<span class="number">-1</span>;</span><br><span class="line">counter: <span class="number">0</span>, <span class="number">1</span>, …, n;</span><br></pre></td></tr></table></figure></li>
<li>指针in和out初始化为1。在生产者和消费者进程的描述中，no-op是一条空操作指令，while condition do no-op语句表示重复的测试条件(condication)，重复测试应进行到该条件变为false(假)，即到该条件不成立时为止。在生产者进程中使用一局部变量nextp，用于暂时存放每次刚生产出来的产品；而在消费者进程中，则使用一个局部变量nextc,用于存放每次要消费的产品。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">producer: repeat</span><br><span class="line">     …</span><br><span class="line">     produce an item in nextp;</span><br><span class="line">     …</span><br><span class="line">     while counter=n do no-op;</span><br><span class="line">     buffer［in］:= nextp;</span><br><span class="line">     in := in+<span class="number">1</span> mod n;</span><br><span class="line">     counter := counter+<span class="number">1</span>;</span><br><span class="line">    until <span class="literal">false</span>;</span><br><span class="line">consumer: repeat</span><br><span class="line">     while counter=<span class="number">0</span> do no-op;</span><br><span class="line">     nextc := buffer［out］;</span><br><span class="line">     out := (out+<span class="number">1</span>) mod n;</span><br><span class="line">     counter := counter<span class="number">-1</span>;</span><br><span class="line">     consumer the item in nextc;</span><br><span class="line">    until <span class="literal">false</span>; </span><br></pre></td></tr></table></figure></li>
<li>虽然上面的生产者程序和消费者程序，在分别看时都是正确的，而且两者在顺序执行时其结果也会是正确的，但若并发执行时，就会出现差错，问题就在于这两个进程共享变量counter。生产者对它做加1操作，消费者对它做减1操作，这两个操作在用机器语言实现时， 常可用下面的形式描述：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">register1 := counter;       register2 := counter;</span><br><span class="line">register1 := register1 + <span class="number">1</span>; register2 := register2 - <span class="number">1</span>;  </span><br><span class="line">counter := register1;       counter := register2; </span><br></pre></td></tr></table></figure></li>
<li>假设：counter的当前值是5。如果生产者进程先执行左列的三条机器语言语句，然后消费者进程再执行右列的三条语句， 则最后共享变量counter的值仍为5；反之，如果让消费者进程先执行右列的三条语句，然后再让生产者进程执行左列的三条语句，counter值也还是5，但是，如果按下述顺序执行：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">register1 := counter; (register1 = <span class="number">5</span>)</span><br><span class="line">register1 := register1 + <span class="number">1</span>; (register1 = <span class="number">6</span>)</span><br><span class="line">register2 := counter; (register2 = <span class="number">5</span>)</span><br><span class="line">register2 := register2 - <span class="number">1</span>; (register2 = <span class="number">4</span>)</span><br><span class="line">counter := register1; (counter = <span class="number">6</span>)</span><br><span class="line">counter := register2; (counter = <span class="number">4</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><img src="/articles/c94444f9/临界区.png" width=70% height=70% />

<ul>
<li>可以把临界资源想象成一间只有一个人的厕所。<ul>
<li>“进入区段”就是你走到厕所门口，看看里面有没有人。</li>
<li>“临界区”就是你在厕所里面。</li>
<li>“退出区段”就是你从厕所出来，并且告诉别人厕所现在没人了。</li>
<li>“剩余区段”就是你上完厕所之后的其他活动。</li>
</ul>
</li>
</ul>
<h4 id="同步机制应遵循的规则"><a href="#同步机制应遵循的规则" class="headerlink" title="同步机制应遵循的规则"></a>同步机制应遵循的规则</h4><ol>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ol>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p><strong>1. 信号量 (Semaphore) 是什么？</strong></p>
<p>信号量是一种用于控制多个进程或线程访问共享资源的同步机制。你可以把它想象成一个计数器，它记录了可用资源的数量。</p>
<ul>
<li><strong>计数器 (value):</strong><ul>
<li>如果计数器大于 0，表示有可用资源，进程可以继续访问。</li>
<li>如果计数器等于 0，表示没有可用资源，进程需要等待。</li>
</ul>
</li>
<li><strong>作用:</strong><ul>
<li><strong>互斥 (Mutual Exclusion):</strong> 确保同一时刻只有一个进程可以访问临界资源，防止数据竞争。</li>
<li><strong>同步 (Synchronization):</strong> 控制进程的执行顺序，确保它们按照特定的顺序访问资源。</li>
</ul>
</li>
</ul>
<h4 id="整型信号量-vs-记录型信号量"><a href="#整型信号量-vs-记录型信号量" class="headerlink" title="整型信号量 vs. 记录型信号量"></a>整型信号量 vs. 记录型信号量</h4><p><strong>2. 整型信号量 vs. 记录型信号量</strong></p>
<ul>
<li><strong>整型信号量:</strong><ul>
<li>只包含一个整数变量 <code>S</code>，表示可用资源的数量。</li>
<li>当 <code>S &lt;= 0</code> 时，进程会不断地测试 <code>S</code> 的值，直到 <code>S &gt; 0</code>，这种方式称为<strong>“忙等”</strong>。</li>
<li><strong>“忙等”会浪费 CPU 资源，因为它让进程不断地循环检查，而不是让出 CPU。</strong></li>
</ul>
</li>
<li><strong>记录型信号量:</strong><ul>
<li>为了解决“忙等”的问题，记录型信号量引入了一个进程链表 <code>L</code>。</li>
<li>当进程需要等待资源时，它会被加入到链表 <code>L</code> 中，并进入睡眠状态，让出 CPU。</li>
<li>当资源可用时，操作系统会唤醒链表 <code>L</code> 中的一个等待进程。</li>
<li>记录型信号量的数据结构：  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> semaphore = record</span><br><span class="line">  value : integer</span><br><span class="line">  L : list of process; </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li><code>value</code>: 整数，表示可用资源的数量。</li>
<li><code>L</code>: 进程链表，存储等待资源的进程。</li>
</ul>
</li>
<li>wait(S)和signal(S)操作可描述为：  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">procedure wait(S)</span><br><span class="line"><span class="keyword">var</span> S : semaphore;</span><br><span class="line">begin</span><br><span class="line">  S.value := S.value<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> S.value &lt; <span class="number">0</span> then block(S,L)</span><br><span class="line">end</span><br><span class="line">procedure signal(S)</span><br><span class="line"><span class="keyword">var</span> S : semaphore;</span><br><span class="line">begin</span><br><span class="line">  S.value := S.value+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> S.value &lt;= <span class="number">0</span> then wakeup(S,L);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>wait(S)</code> 操作 (也称为 P 操作)</strong><ul>
<li><strong>作用：</strong><ul>
<li><code>wait(S)</code> 用于请求一个资源。当进程需要访问临界资源时，它会调用 <code>wait(S)</code>。</li>
<li>它的主要目的是减少信号量 <code>S</code> 的值，并检查是否需要等待。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>signal(S)</code> 操作 (也称为 V 操作)</strong><ul>
<li><strong>作用：</strong><ul>
<li><code>signal(S)</code> 用于释放一个资源。当进程完成对临界资源的访问后，它会调用 <code>signal(S)</code>。</li>
<li>它的主要目的是增加信号量 <code>S</code> 的值，并唤醒等待的进程（如果有）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3. 代码解释</strong></p>
<ul>
<li><p><code>type semaphore = record ... end</code>: 这段代码定义了一个名为 <code>semaphore</code> 的记录类型，它包含两个字段：</p>
<ul>
<li><code>value : integer</code>: 一个整数类型的字段，用于存储信号量的计数值。</li>
<li><code>L : list of process</code>: 一个进程链表类型的字段，用于存储等待该信号量的进程。</li>
</ul>
</li>
<li><p><code>wait(S)</code></p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">procedure wait(S)</span><br><span class="line">  <span class="keyword">var</span> S : semaphore;</span><br><span class="line">  begin</span><br><span class="line">    S.value := S.value - <span class="number">1</span>; <span class="comment">// 减少信号量的值</span></span><br><span class="line">    <span class="keyword">if</span> S.value &lt; <span class="number">0</span> then block(S, L) <span class="comment">// 如果资源不足，则阻塞进程</span></span><br><span class="line">  end</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong><code>S.value := S.value - 1;</code></strong>:</p>
<ul>
<li>这行代码将信号量 <code>S</code> 的值减 1。</li>
<li>如果 <code>S.value</code> 原本是正数，减 1 后仍然是正数或 0，表示还有可用资源。</li>
<li>如果 <code>S.value</code> 原本是 0，减 1 后变为负数，表示资源已被用完，进程需要等待。</li>
</ul>
</li>
<li><p><strong><code>if S.value &lt; 0 then block(S, L)</code></strong>:</p>
<ul>
<li>这行代码检查 <code>S.value</code> 是否小于 0。</li>
<li>如果 <code>S.value &lt; 0</code>，表示没有可用资源，进程需要等待。</li>
<li><code>block(S, L)</code> 函数会将当前进程加入到信号量 <code>S</code> 的等待队列 <code>L</code> 中，并使进程进入阻塞（睡眠）状态，让出 CPU。</li>
</ul>
</li>
</ol>
</li>
<li><p><code>signal(S)</code></p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">procedure signal(S)</span><br><span class="line">  <span class="keyword">var</span> S : semaphore;</span><br><span class="line">  begin</span><br><span class="line">    S.value := S.value + <span class="number">1</span>; <span class="comment">// 增加信号量的值</span></span><br><span class="line">    <span class="keyword">if</span> S.value &lt;= <span class="number">0</span> then wakeup(S, L); <span class="comment">// 如果有等待的进程，则唤醒一个</span></span><br><span class="line">  end</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong><code>S.value := S.value + 1;</code></strong>:</p>
<ul>
<li>这行代码将信号量 <code>S</code> 的值加 1。</li>
<li>这表示资源被释放，可用资源数量增加。</li>
</ul>
</li>
<li><p><strong><code>if S.value &lt;= 0 then wakeup(S, L);</code></strong>:</p>
<ul>
<li>这行代码检查 <code>S.value</code> 是否小于等于 0。</li>
<li>如果 <code>S.value &lt;= 0</code>，表示有进程在等待该资源（因为 <code>S.value</code> 可能是负数，表示等待的进程数）。</li>
<li><code>wakeup(S, L)</code> 函数会从信号量 <code>S</code> 的等待队列 <code>L</code> 中唤醒一个进程，使其进入就绪状态，等待 CPU 调度。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>4. 记录型信号量的工作原理</strong></p>
<ul>
<li><strong>P 操作 (Wait):</strong><ul>
<li>当一个进程想要访问临界资源时，它会执行 P 操作。</li>
<li>P 操作会减少信号量的 <code>value</code> 值。</li>
<li>如果 <code>value</code> 变为负数，表示没有可用资源，进程会被加入到链表 <code>L</code> 中并进入睡眠状态。</li>
</ul>
</li>
<li><strong>V 操作 (Signal):</strong><ul>
<li>当一个进程释放临界资源时，它会执行 V 操作。</li>
<li>V 操作会增加信号量的 <code>value</code> 值。</li>
<li>如果 <code>value</code> 变为非负数，表示有 <code>value</code> 个可用资源，操作系统会从链表 <code>L</code> 中唤醒一个进程。</li>
</ul>
</li>
</ul>
<p><strong>5. 总结</strong></p>
<p>记录型信号量通过引入进程链表和睡眠&#x2F;唤醒机制，实现了 <strong>“让权等待”</strong> ，解决了整型信号量的 <strong>“忙等”</strong> 问题，显著提高了 CPU 的利用率。</p>
<h4 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h4><p><strong>1. AND 型信号量的概念</strong></p>
<ul>
<li>AND 型信号量是一种扩展的信号量机制，用于解决进程需要同时申请多个资源的情况。</li>
<li>在传统的信号量机制中，进程每次只能申请一个资源。但在实际应用中，很多进程需要同时申请多个资源才能继续执行。</li>
<li>AND 型信号量允许进程一次性申请多个资源，只有当所有资源都可用时，进程才能继续执行。</li>
</ul>
<p><strong>2. AND 型信号量的作用</strong></p>
<ul>
<li><strong>避免死锁：</strong><ul>
<li>死锁是指多个进程因竞争资源而互相等待，导致所有进程都无法继续执行的情况。</li>
<li>AND 型信号量通过一次性申请所有资源，避免了进程逐步申请资源时可能发生的死锁。</li>
</ul>
</li>
<li><strong>提高资源利用率：</strong><ul>
<li>通过一次性申请所有资源，进程可以更快地获得所需的全部资源，从而提高资源利用率。</li>
<li>减少了进程多次申请资源带来的系统开销。</li>
</ul>
</li>
</ul>
<p><strong>3. AND 型信号量的工作原理</strong></p>
<ul>
<li>当一个进程需要同时申请多个资源时，它会执行 AND 型 P 操作（也称为 <code>Swait</code> 操作）。</li>
<li><code>Swait</code> 操作会检查所有需要的资源是否都可用。</li>
<li>如果所有资源都可用，<code>Swait</code> 操作会一次性减少所有相关信号量的值，进程继续执行。</li>
<li>如果任何一个资源不可用，<code>Swait</code> 操作会阻塞进程，并将进程放入所有相关信号量的等待队列中。</li>
<li>当其他进程释放资源时，它们会执行 AND 型 V 操作（也称为 <code>Ssignal</code> 操作）。</li>
<li><code>Ssignal</code> 操作会增加相关信号量的值，并检查是否有等待进程可以被唤醒。</li>
<li>只有当所有相关资源都可用时，等待进程才会被唤醒。</li>
</ul>
<p><strong>4. 代码</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1, S2, …, Sn)</span><br><span class="line">    <span class="keyword">if</span> Si≥<span class="number">1</span> and … and Sn≥<span class="number">1</span> then</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span> to n do</span><br><span class="line">        Si := Si<span class="number">-1</span>;</span><br><span class="line">        endfor</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    place the process in the waiting queue associated with the first Si found   with Si＜<span class="number">1</span>, and set the program count of this process to the beginning of Swait operation</span><br><span class="line">    endif</span><br><span class="line">Ssignal(S1, S2, …, Sn)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span> to n do</span><br><span class="line">    Si=Si+<span class="number">1</span>;</span><br><span class="line">    Remove all the process waiting in the queue associated with Si into the ready queue.</span><br><span class="line">  endfor; </span><br></pre></td></tr></table></figure>

<p><strong>5. 总结</strong></p>
<ul>
<li>AND 型信号量是一种用于解决进程需要同时申请多个资源的同步机制。</li>
<li>它通过一次性申请所有资源，避免了死锁，提高了资源利用率。</li>
<li>AND 型 P 操作（<code>Swait</code>）用于申请多个资源，AND 型 V 操作（<code>Ssignal</code>）用于释放资源。</li>
</ul>
<h4 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h4><ul>
<li>是对 AND 型信号量的扩展。</li>
<li>它不仅能一次性申请&#x2F;释放多个资源，还能指定每个资源所需的具体数量。</li>
<li>这种机制更加灵活，可以更好地满足实际应用的需求。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1, t1, d1, …, Sn, tn, dn)</span><br><span class="line">    <span class="keyword">if</span> Si ≥ t1 and … and Sn ≥ tn then</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">1</span> to n do</span><br><span class="line">        Si := Si - di;</span><br><span class="line">      endfor</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    Place the executing process in the waiting queue of the first Si with Si＜ti and set its program counter to the beginning of the Swait Operation. </span><br><span class="line">    endif</span><br><span class="line"></span><br><span class="line">Ssignal(S1, d1, …, Sn, dn)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span> to n do</span><br><span class="line">      Si ∶= Si + di;</span><br><span class="line">      Remove all the process waiting in the queue associated with Si into the ready queue</span><br><span class="line">    endfor; </span><br></pre></td></tr></table></figure>

<p><strong>信号量集的三种特殊情况</strong></p>
<p>信号量集是一种强大的资源管理工具，通过 <code>Swait</code> 操作，我们可以一次性申请多个资源，并指定每个资源的需求量和阈值。以下是信号量集的三种特殊情况，它们展示了信号量集的灵活性和实用性：</p>
<p><strong>(1) 资源批量申请：Swait(S, d, d)</strong></p>
<ul>
<li><strong>说明：</strong> 这种形式的 <code>Swait</code> 操作仅涉及单个信号量 <code>S</code>，但允许进程一次性申请 <code>d</code> 个资源。</li>
<li><strong>特性：</strong> 只有当信号量 <code>S</code> 的当前值大于等于 <code>d</code> 时，即现有可用资源数不少于 <code>d</code> 时，才会分配资源。否则，进程将进入等待状态。</li>
<li><strong>应用：</strong> 适用于需要批量申请同一类型资源的场景，例如，一次性申请多个打印机或内存块。</li>
</ul>
<p><strong>(2) 简化为传统信号量：Swait(S, 1, 1)</strong></p>
<ul>
<li><strong>说明：</strong> 这种形式的 <code>Swait</code> 操作实际上退化为传统的记录型信号量或互斥信号量。</li>
<li><strong>特性：</strong><ul>
<li>当 <code>S &gt; 1</code> 时，它等同于记录型信号量，允许多个进程并发访问资源。</li>
<li>当 <code>S = 1</code> 时，它等同于互斥信号量（mutex），确保同一时刻只有一个进程可以访问资源。</li>
</ul>
</li>
<li><strong>应用：</strong> 适用于需要互斥或同步的简单资源访问场景。</li>
</ul>
<p><strong>(3) 可控开关：Swait(S, 1, 0)</strong></p>
<ul>
<li><strong>说明：</strong> 这是一种特殊且实用的信号量操作，用于实现可控的资源访问开关。</li>
<li><strong>特性：</strong><ul>
<li>当 <code>S ≥ 1</code> 时，允许多个进程进入特定区域。</li>
<li>当 <code>S</code> 变为 0 时，阻止任何新进程进入该区域。</li>
<li>本质上，它充当了一个开关，可以动态地控制对特定区域的访问。</li>
</ul>
</li>
<li><strong>应用：</strong> 适用于需要动态控制资源访问权限的场景，例如，控制对某个共享缓冲区的访问或实现某种形式的门禁机制。</li>
</ul>
<h4 id="利用信号量实现前趋关系"><a href="#利用信号量实现前趋关系" class="headerlink" title="利用信号量实现前趋关系"></a>利用信号量实现前趋关系</h4><ul>
<li><strong>举例</strong></li>
</ul>
<img src="/articles/c94444f9/前趋图举例.png" width=40% height=70% />

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Var a,b,c,d,e,f,g; semaphore := <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;</span><br><span class="line">  begin</span><br><span class="line">    parbegin</span><br><span class="line">      begin S1; signal(a); signal(b); end;</span><br><span class="line">      begin wait(a); S2; signal(c); signal(d); end;</span><br><span class="line">      begin wait(b); S3; signal(e); end;</span><br><span class="line">      begin wait(c); S4; signal(f); end;</span><br><span class="line">      begin wait(d); S5; signal(g); end;</span><br><span class="line">      begin wait(e); wait(f); wait(g); S6; end;</span><br><span class="line">    parend</span><br><span class="line">   end </span><br></pre></td></tr></table></figure>

<h2 id="经典进程的同步问题"><a href="#经典进程的同步问题" class="headerlink" title="经典进程的同步问题"></a>经典进程的同步问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><p>生产者-消费者问题是并发编程中一个经典的同步问题，它描述了两个或多个进程共享一个固定大小的缓冲区。生产者进程负责生成数据并放入缓冲区，而消费者进程则负责从缓冲区取出数据并进行处理。这个问题抽象了许多实际应用场景，例如：</p>
<ul>
<li><strong>输入&#x2F;输出：</strong> 输入进程作为生产者，计算进程作为消费者；计算进程作为生产者，打印进程作为消费者。</li>
<li><strong>线程池：</strong> 生产者线程生成任务，消费者线程从队列中取出任务执行。</li>
</ul>
<p><strong>核心挑战：</strong></p>
<ul>
<li><strong>互斥访问：</strong> 多个生产者和消费者需要互斥地访问共享缓冲区，避免数据竞争。</li>
<li><strong>同步：</strong> 生产者不能在缓冲区满时继续生产，消费者不能在缓冲区空时继续消费。</li>
</ul>
<h3 id="1-利用记录型信号量解决生产者-消费者问题"><a href="#1-利用记录型信号量解决生产者-消费者问题" class="headerlink" title="1. 利用记录型信号量解决生产者-消费者问题"></a>1. 利用记录型信号量解决生产者-消费者问题</h3><p><strong>场景描述：</strong></p>
<ul>
<li>共享缓冲区：包含 n 个缓冲区。</li>
<li>信号量：<ul>
<li><code>mutex</code>：互斥信号量，初始值为 1，用于控制对缓冲区的互斥访问。</li>
<li><code>empty</code>：资源信号量，初始值为 n，表示空缓冲区的数量。</li>
<li><code>full</code>：资源信号量，初始值为 0，表示满缓冲区的数量。</li>
</ul>
</li>
<li>指针：<ul>
<li><code>in</code>：指向下一个要放入数据的空缓冲区。</li>
<li><code>out</code>：指向下一个要取出数据的满缓冲区。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Var mutex, empty, full: semaphore := <span class="number">1</span>, n, <span class="number">0</span>;</span><br><span class="line">buffer: array[<span class="number">0</span>, ..., n<span class="number">-1</span>] of item;</span><br><span class="line">in, out: integer := <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">    parbegin</span><br><span class="line">        producer: begin</span><br><span class="line">            repeat</span><br><span class="line">                <span class="comment">// 生产数据</span></span><br><span class="line">                producer an item nextp;</span><br><span class="line"></span><br><span class="line">                wait(empty);  <span class="comment">// 检查是否有空缓冲区</span></span><br><span class="line">                wait(mutex);  <span class="comment">// 获取互斥锁</span></span><br><span class="line"></span><br><span class="line">                buffer[in] := nextp;</span><br><span class="line">                in := (in + <span class="number">1</span>) mod n;</span><br><span class="line"></span><br><span class="line">                signal(mutex); <span class="comment">// 释放互斥锁</span></span><br><span class="line">                signal(full);  <span class="comment">// 增加满缓冲区计数</span></span><br><span class="line"></span><br><span class="line">            until <span class="literal">false</span>;</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        consumer: begin</span><br><span class="line">            repeat</span><br><span class="line">                wait(full);   <span class="comment">// 检查是否有满缓冲区</span></span><br><span class="line">                wait(mutex);  <span class="comment">// 获取互斥锁</span></span><br><span class="line"></span><br><span class="line">                nextc := buffer[out];</span><br><span class="line">                out := (out + <span class="number">1</span>) mod n;</span><br><span class="line"></span><br><span class="line">                signal(mutex); <span class="comment">// 释放互斥锁</span></span><br><span class="line">                signal(empty); <span class="comment">// 增加空缓冲区计数</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 消费数据</span></span><br><span class="line">                consumer the item in nextc;</span><br><span class="line"></span><br><span class="line">            until <span class="literal">false</span>;</span><br><span class="line">        end</span><br><span class="line">    parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>关键点：</strong></p>
<ul>
<li><strong>互斥：</strong> <code>mutex</code> 信号量确保了对缓冲区的互斥访问。</li>
<li><strong>同步：</strong><ul>
<li><code>empty</code> 信号量控制生产者，防止缓冲区溢出。</li>
<li><code>full</code> 信号量控制消费者，防止缓冲区为空时消费。</li>
</ul>
</li>
<li><strong>顺序：</strong> <code>wait(empty)</code> 和 <code>wait(mutex)</code> 的顺序不能颠倒，否则可能导致死锁。</li>
</ul>
<h3 id="2-利用-AND-信号量解决生产者-消费者问题"><a href="#2-利用-AND-信号量解决生产者-消费者问题" class="headerlink" title="2. 利用 AND 信号量解决生产者-消费者问题"></a>2. 利用 AND 信号量解决生产者-消费者问题</h3><p><strong>代码实现：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex, empty, full: semaphore := <span class="number">1</span>, n, <span class="number">0</span>;</span><br><span class="line">buffer: array[<span class="number">0</span>, ..., n<span class="number">-1</span>] of item;</span><br><span class="line">in, out: integer := <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">    parbegin</span><br><span class="line">        producer: begin</span><br><span class="line">            repeat</span><br><span class="line">                <span class="comment">// 生产数据</span></span><br><span class="line">                produce an item in nextp;</span><br><span class="line"></span><br><span class="line">                Swait(empty, mutex); <span class="comment">// 同时申请空缓冲区和互斥锁</span></span><br><span class="line"></span><br><span class="line">                buffer[in] := nextp;</span><br><span class="line">                in := (in + <span class="number">1</span>) mod n;</span><br><span class="line"></span><br><span class="line">                Ssignal(mutex, full); <span class="comment">// 同时释放互斥锁和增加满缓冲区计数</span></span><br><span class="line"></span><br><span class="line">            until <span class="literal">false</span>;</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        consumer: begin</span><br><span class="line">            repeat</span><br><span class="line">                Swait(full, mutex); <span class="comment">// 同时申请满缓冲区和互斥锁</span></span><br><span class="line"></span><br><span class="line">                nextc := buffer[out];</span><br><span class="line">                out := (out + <span class="number">1</span>) mod n;</span><br><span class="line"></span><br><span class="line">                Ssignal(mutex, empty); <span class="comment">// 同时释放互斥锁和增加空缓冲区计数</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 消费数据</span></span><br><span class="line">                consumer the item in nextc;</span><br><span class="line"></span><br><span class="line">            until <span class="literal">false</span>;</span><br><span class="line">        end</span><br><span class="line">    parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>关键点：</strong></p>
<ul>
<li><strong>原子性：</strong> <code>Swait</code> 和 <code>Ssignal</code> 操作保证了资源申请和释放的原子性，避免了死锁的可能。</li>
<li><strong>简化：</strong> 使用 AND 信号量可以简化代码，提高效率。</li>
</ul>
<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>哲学家进餐问题是并发编程中一个经典的同步问题，它描述了五个哲学家围坐在一张圆桌旁，每两个哲学家之间都有一根筷子。哲学家有两种状态：思考和进餐。当哲学家想进餐时，他必须拿起他左右两边的筷子才能进餐。进餐完毕后，他会放下筷子继续思考。</p>
<p><strong>核心挑战：</strong></p>
<ul>
<li><strong>死锁：</strong> 如果每个哲学家都拿起自己左边的筷子，然后等待右边的筷子，就会发生死锁。</li>
<li><strong>饥饿：</strong> 如果某个哲学家一直无法获得筷子，就会发生饥饿。</li>
</ul>
<p><strong>1. 利用信号量解决哲学家进餐问题</strong></p>
<p><strong>场景描述：</strong></p>
<ul>
<li>五个哲学家，五根筷子。</li>
<li>信号量：<ul>
<li><code>chopstick[5]</code>：包含五个互斥信号量的数组，每个信号量代表一根筷子，初始值为 1。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chopstick[<span class="number">5</span>] semaphore := [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">    parbegin</span><br><span class="line">        philosopher[i]: begin <span class="comment">// i = 0, 1, 2, 3, 4</span></span><br><span class="line">            repeat</span><br><span class="line">                <span class="comment">// 思考</span></span><br><span class="line">                think();</span><br><span class="line"></span><br><span class="line">                wait(chopstick[i]);          <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">                wait(chopstick[(i+<span class="number">1</span>) mod <span class="number">5</span>]); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进餐</span></span><br><span class="line">                eat();</span><br><span class="line"></span><br><span class="line">                signal(chopstick[i]);          <span class="comment">// 放下左边的筷子</span></span><br><span class="line">                signal(chopstick[(i+<span class="number">1</span>) mod <span class="number">5</span>]); <span class="comment">// 放下右边的筷子</span></span><br><span class="line"></span><br><span class="line">            until <span class="literal">false</span>;</span><br><span class="line">        end</span><br><span class="line">    parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>问题分析：</strong></p>
<ul>
<li><strong>死锁：</strong> 如果所有哲学家同时拿起左边的筷子，就会发生死锁。</li>
<li><strong>饥饿：</strong> 如果某个哲学家一直无法获得筷子，就会发生饥饿。</li>
</ul>
<p><strong>2. 避免死锁的解决方案</strong></p>
<p><strong>方案一：最多允许四个哲学家同时进餐</strong></p>
<ul>
<li><strong>原理：</strong> 这样可以保证至少有一个哲学家可以拿到两根筷子，从而避免死锁。</li>
<li><strong>实现：</strong> 增加一个计数信号量 <code>count</code>，初始值为 4。哲学家在拿起筷子之前，需要先 <code>wait(count)</code>，进餐完毕后 <code>signal(count)</code>。</li>
</ul>
<p><strong>方案二：奇数号哲学家先拿左边的筷子，偶数号哲学家先拿右边的筷子</strong></p>
<ul>
<li><strong>原理：</strong> 这样可以打破死锁的条件。</li>
<li><strong>实现：</strong> 修改哲学家拿起筷子的顺序。</li>
</ul>
<p><strong>方案三：使用条件变量</strong>（PPT无）</p>
<ul>
<li><strong>原理：</strong> 使用条件变量可以更灵活地控制哲学家的状态。</li>
<li><strong>实现：</strong> 每个哲学家都有一个状态变量，表示其思考、饥饿或进餐状态。哲学家在拿起筷子之前，需要检查其左右邻居的状态。</li>
</ul>
<p><strong>方案四：使用AND信号量</strong>（最简洁）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chopstick[<span class="number">5</span>] semaphore := [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">    parbegin</span><br><span class="line">        philosopher[i]: begin <span class="comment">// i = 0, 1, 2, 3, 4</span></span><br><span class="line">            repeat</span><br><span class="line">                <span class="comment">// 思考</span></span><br><span class="line">                think();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 尝试同时拿起左右两边的筷子</span></span><br><span class="line">                Swait(chopstick[i], chopstick[(i+<span class="number">1</span>) mod <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进餐</span></span><br><span class="line">                eat();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 同时放下左右两边的筷子</span></span><br><span class="line">                Ssignal(chopstick[i], chopstick[(i+<span class="number">1</span>) mod <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">            until <span class="literal">false</span>;</span><br><span class="line">        end</span><br><span class="line">    parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p><strong>1. 记录型信号量</strong></p>
<ul>
<li>为实现Reader与Writer进程间在读或写时的互斥而设置了一个互斥信号量Wmutex。另外，再设置一个整型变量Readcount表示正在读的进程数目。由于只要有一个Reader进程在读，便不允许Writer进程去写。因此，仅当Readcount&#x3D;0, 表示尚无Reader进程在读时，Reader进程才需要执行Wait(Wmutex)操作。若wait(Wmutex)操作成功，Reader进程便可去读，相应地，做Readcount+1操作。同理，仅当Reader进程在执行了Readcount减1操作后其值为0时，才须执行signal(Wmutex)操作，以便让Writer进程写。又因为Readcount是一个可被多个Reader进程访问的临界资源，因此，应该为它设置一个互斥信号量rmutex。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Var rmutex, wmutex:semaphore := <span class="number">1</span>,<span class="number">1</span>;</span><br><span class="line">    Readcount:integer := <span class="number">0</span>;</span><br><span class="line">    begin</span><br><span class="line">    parbegin</span><br><span class="line">      Reader:begin</span><br><span class="line">        repeat</span><br><span class="line">          wait(rmutex);</span><br><span class="line">          <span class="keyword">if</span> readcount=<span class="number">0</span> then</span><br><span class="line">          wait(wmutex);</span><br><span class="line">          Readcount := Readcount+<span class="number">1</span>;</span><br><span class="line">          signal(rmutex);</span><br><span class="line">          …</span><br><span class="line">          perform read operation;</span><br><span class="line">          …</span><br><span class="line">          wait(rmutex);</span><br><span class="line">          readcount := readcount<span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">if</span> readcount=<span class="number">0</span> then </span><br><span class="line">          signal(wmutex);</span><br><span class="line">          signal(rmutex);</span><br><span class="line">        until <span class="literal">false</span>;</span><br><span class="line">      end</span><br><span class="line">      writer:begin</span><br><span class="line">        repeat</span><br><span class="line">          wait(wmutex);</span><br><span class="line">          perform write operation;</span><br><span class="line">          signal(wmutex);</span><br><span class="line">        until <span class="literal">false</span>;</span><br><span class="line">      end</span><br><span class="line">    parend</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<p><strong>2. 信号量集</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Var RN integer;</span><br><span class="line">    L, mx:semaphore := RN,<span class="number">1</span>;</span><br><span class="line">    begin</span><br><span class="line">    parbegin</span><br><span class="line">      reader:begin</span><br><span class="line">        repeat</span><br><span class="line">          Swait(L,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">          Swait(mx,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">          …</span><br><span class="line">          perform read operation;</span><br><span class="line">          …</span><br><span class="line">          Ssignal(L,<span class="number">1</span>);</span><br><span class="line">        until <span class="literal">false</span>;</span><br><span class="line">      end</span><br><span class="line">      writer:begin</span><br><span class="line">        repeat</span><br><span class="line">          Swait(mx,<span class="number">1</span>,<span class="number">1</span>; L,RN,<span class="number">0</span>);</span><br><span class="line">          perform write operation;</span><br><span class="line">          Ssignal(mx,<span class="number">1</span>);</span><br><span class="line">        until <span class="literal">false</span>;</span><br><span class="line">      end</span><br><span class="line">    parend</span><br><span class="line">  end </span><br></pre></td></tr></table></figure>

<h2 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h2><h3 id="管程的基本概念"><a href="#管程的基本概念" class="headerlink" title="管程的基本概念"></a>管程的基本概念</h3><ul>
<li>管程（Monitor）是一种用于多线程同步的机制，它提供了一种更高级、更安全的共享资源访问方式。</li>
</ul>
<p><strong>核心概念</strong></p>
<ul>
<li><strong>共享资源封装：</strong><ul>
<li>管程将共享变量以及对这些变量的所有操作都封装在一个模块中。这样，所有对共享资源的访问都必须通过管程提供的接口进行，从而避免了直接访问可能导致的数据竞争。</li>
</ul>
</li>
<li><strong>互斥访问：</strong><ul>
<li>管程保证在任何时刻，最多只有一个线程可以进入管程执行。这种互斥性确保了共享数据的一致性。</li>
</ul>
</li>
<li><strong>条件变量：</strong><ul>
<li>管程内部通常包含条件变量，允许线程在不满足特定条件时等待，并在条件满足时被唤醒。这使得线程可以更灵活地进行同步。</li>
</ul>
</li>
</ul>
<p><strong>主要特点</strong></p>
<ul>
<li><strong>简化同步：</strong><ul>
<li>管程通过集中管理共享资源和同步操作，简化了并发编程的复杂性。</li>
</ul>
</li>
<li><strong>提高安全性：</strong><ul>
<li>管程的互斥访问特性和条件变量机制，减少了因不正确的同步操作而导致的数据竞争和死锁等问题。</li>
</ul>
</li>
<li><strong>模块化：</strong><ul>
<li>管程将共享资源和相关操作封装在一起，提高了代码的模块化和可维护性。</li>
</ul>
</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li>管程被广泛应用于各种并发编程场景，例如：<ul>
<li>操作系统中的进程同步</li>
<li>多线程应用程序中的共享资源管理</li>
<li>数据库系统中的并发控制</li>
</ul>
</li>
</ul>
<p><strong>与信号量的区别</strong></p>
<ul>
<li>与信号量相比，管程提供了一种更高级别的同步机制，它将共享资源的访问控制和同步操作封装在一起，使得并发编程更加安全和可靠。</li>
</ul>
<p><strong>在java语言中的体现</strong></p>
<ul>
<li>java中的synchronized关键字和wait(),notify(),notifyAll()这三个方法是java中实现管程技术的组成部分。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>管程是一种强大的同步工具，它通过封装共享资源和提供高级同步机制，简化了并发编程，提高了程序的安全性和可靠性。</li>
</ul>
<p><strong>利用管程解决生产者-消费者问题</strong></p>
<ul>
<li>使用管程，我们可以将缓冲区和相关操作封装在一个模块中，并利用条件变量实现同步。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> producer-consumer=monitor</span><br><span class="line">  Var in,out,count:integer;</span><br><span class="line">    buffer:array［<span class="number">0</span>,…,n<span class="number">-1</span>］ of item;</span><br><span class="line">    notfull, notempty:condition;</span><br><span class="line">    procedure entry put(item)</span><br><span class="line">      begin</span><br><span class="line">        <span class="keyword">if</span> count≥n then notfull.wait;</span><br><span class="line">          buffer(in) := nextp;</span><br><span class="line">          in := (in+<span class="number">1</span>) mod n;</span><br><span class="line">          count := count+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> notempty.queue then </span><br><span class="line">          notempty.signal;</span><br><span class="line">      end</span><br><span class="line">    procedure entry get(item)</span><br><span class="line">      begin</span><br><span class="line">        <span class="keyword">if</span> count≤<span class="number">0</span> then notempty.wait;</span><br><span class="line">          nextc := buffer(out);</span><br><span class="line">          out := (out+<span class="number">1</span>) mod n;</span><br><span class="line">          count := count<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> notfull.quene then </span><br><span class="line">          notfull.signal;</span><br><span class="line">      end</span><br><span class="line">      begin </span><br><span class="line">        in := out := <span class="number">0</span>; </span><br><span class="line">        count := <span class="number">0</span> </span><br><span class="line">      end </span><br></pre></td></tr></table></figure>

<ul>
<li>在利用管程解决生产者-消费者问题时，其中的生产者和消费者可描述为：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">producer:begin</span><br><span class="line">  repeat</span><br><span class="line">  produce an item in nextp;</span><br><span class="line">  PC.put(item);</span><br><span class="line">  until <span class="literal">false</span>;</span><br><span class="line">end</span><br><span class="line">consumer:begin</span><br><span class="line">  repeat</span><br><span class="line">  PC.get(item);</span><br><span class="line">  consume the item in nextc;</span><br><span class="line">  until <span class="literal">false</span>;</span><br><span class="line">end </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="进程通信-1"><a href="#进程通信-1" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a>进程通信的类型</h3><ol>
<li><p><strong>共享存储器系统</strong><br>(1) 基于共享数据结构的通信方式<br>(2) 基于共享存储区的通信方式</p>
</li>
<li><p><strong>消息传递系统</strong></p>
</li>
</ol>
<ul>
<li>消息传递系统是一种强大的通信机制，它在分布式系统和并发编程中发挥着重要的作用。它通过解耦、异步和可靠的通信方式，提高了系统的灵活性和可扩展性。</li>
</ul>
<ol start="3">
<li><strong>管道</strong></li>
</ol>
<ul>
<li>管道是一种简单而有效的进程间通信机制，它通过单向的数据流和缓冲区，实现了进程之间的数据交换。</li>
</ul>
<h3 id="消息传递通信的实现方法"><a href="#消息传递通信的实现方法" class="headerlink" title="消息传递通信的实现方法"></a>消息传递通信的实现方法</h3><h4 id="直接通信方法"><a href="#直接通信方法" class="headerlink" title="直接通信方法"></a>直接通信方法</h4><h4 id="间接通信方法"><a href="#间接通信方法" class="headerlink" title="间接通信方法"></a>间接通信方法</h4><ol>
<li>信箱的创建和撤销</li>
<li>消息的发送和接收</li>
</ol>
<p><strong>信箱分为三类：</strong></p>
<ol>
<li>私用信箱（用户为自己创建，只能自己读；作为进程的一部分，进程结束信箱消失；单向通信链路）</li>
<li>公用信箱（操作系统创建，给所有核准进程用；系统运行期间始终存在；双向通信链路）</li>
<li>共享信箱（某进程船舰，拥有者和共享者可取信息）</li>
</ol>
<p><strong>信箱通信时，发送&#x2F;接受进程之间的四种关系：</strong></p>
<ol>
<li>一对一关系（这时可为发送进程和接收进程建立一条两者专用的通信链路，使两者之间的交互不受其他进程的干扰）</li>
<li>多对一关系（允许提供服务的进程与多个用户进程之间进行交互，也称为客户&#x2F;服务器交互(client&#x2F;server interaction)）</li>
<li>一对多关系（允许一个发送进程与多个接收进程进行交互，使发送进程可用<strong>广播方式</strong>，向接收者(多个)发送消息）</li>
<li>多对多关系（允许建立一个公用信箱，让多个进程都能向信箱中投递消息；也可从信箱中取走属于自己的消息）</li>
</ol>
<h3 id="消息传递系统实现中的若干问题"><a href="#消息传递系统实现中的若干问题" class="headerlink" title="消息传递系统实现中的若干问题"></a>消息传递系统实现中的若干问题</h3><h4 id="通信链路"><a href="#通信链路" class="headerlink" title="通信链路"></a>通信链路</h4><ul>
<li><p>为使在发送进程和接收进程之间能进行通信，必须在两者之间建立一条<strong>通信链路</strong>。</p>
</li>
<li><p>有两种方式建立通信链路：</p>
<ol>
<li><p>为使在发送进程和接收进程之间能进行通信，必须在两者之间建立一条通信链路。有两种方式建立通信链路。</p>
<blockquote>
<p>这种方式主要用于计算机网络中。</p>
</blockquote>
</li>
<li><p>发送进程无须明确提出建立链路的请求，只须利用系统提供的发送命令(原语)，系统会自动地为之建立一条链路。</p>
<blockquote>
<p>这种方式主要用于单机系统中。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>根据<strong>连接方法</strong>分类通信链路：</p>
<ol>
<li>点—点连接通信链路，这时的一条链路只连接两个结点(进程)；</li>
<li>多点连接链路，指用一条链路连接多个(n＞2)结点(进程)。</li>
</ol>
</li>
<li><p>根据<strong>通信方式</strong>分类通信链路：</p>
<ol>
<li>单向通信链路，只允许发送进程向接收进程发送消息；</li>
<li>双向链路，既允许由进程A向进程B发送消息，也允许进程B同时向进程A发送消息。</li>
</ol>
</li>
</ul>
<h4 id="消息的格式"><a href="#消息的格式" class="headerlink" title="消息的格式"></a>消息的格式</h4><ul>
<li><p>在某些OS中，消息是采用<strong>比较短</strong>的<strong>定长消息格式</strong>，<u>这减少了对消息的处理和存储开销</u>。这种方式可用于办公自动化系统中，为用户提供快速的便笺式通信；但这对要发送较长消息的用户是不方便的。</p>
</li>
<li><p>在有的OS中，采用另一种<strong>变长</strong>的消息格式，即进程所发送消息的长度是可变的。系统在处理和存储变长消息时，须付出更多的开销，但方便了用户。</p>
</li>
<li><p>这两种消息格式各有其优缺点，故在很多系统(包括计算机网络)中，是<strong>同时都用</strong>的。</p>
</li>
</ul>
<h4 id="进程同步的方式"><a href="#进程同步的方式" class="headerlink" title="进程同步的方式"></a>进程同步的方式</h4><ol>
<li>发送进程阻塞、接收进程阻塞。</li>
<li>发送进程不阻塞、接收进程阻塞。 </li>
<li>发送进程和接收进程均不阻塞。</li>
</ol>
<h3 id="消息缓冲队列通信机制"><a href="#消息缓冲队列通信机制" class="headerlink" title="消息缓冲队列通信机制"></a>消息缓冲队列通信机制</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li><p>在消息缓冲队列通信方式中，主要利用的数据结构是消息缓冲区。它可描述如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> message buffer=record</span><br><span class="line">  sender; 发送者进程标识符</span><br><span class="line">  size; 消息长度</span><br><span class="line">  text; 消息正文</span><br><span class="line">  next; 指向下一个消息缓冲区的指针</span><br><span class="line">end </span><br></pre></td></tr></table></figure>
</li>
<li><p>PCB中有关通信的数据项。在利用消息缓冲队列通信机制时，在设置消息缓冲队列的同时，还应增加用于对消息队列进行操作和实现同步的信号量，并将它们置入进程的PCB中。在PCB中应增加的数据项可描述如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> processcontrol block=record</span><br><span class="line">  …</span><br><span class="line">  mq; 消息队列队首指针</span><br><span class="line">  mutex; 消息队列互斥信号量</span><br><span class="line">  sm; 消息队列资源信号量</span><br><span class="line">  …</span><br><span class="line">end </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="发送原语"><a href="#发送原语" class="headerlink" title="发送原语"></a>发送原语</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">procedure send(receiver, a)</span><br><span class="line">  begin</span><br><span class="line">    getbuf(a.size,i); 根据a.size申请缓冲区；</span><br><span class="line">    i.sender:=a.sender; 将发送区a中的信息复制到消息缓冲区之中；</span><br><span class="line">    i.size:=a.size;</span><br><span class="line">    i.text:=a.text;</span><br><span class="line">    i.next:=<span class="number">0</span>;</span><br><span class="line">    getid(PCB set, receiver.j); 获得接收进程内部标识符；</span><br><span class="line">    wait(j.mutex);</span><br><span class="line">    insert(j.mq, i); 将消息缓冲区插入消息队列；</span><br><span class="line">    signal(j.mutex);</span><br><span class="line">    signal(j.sm);</span><br><span class="line">  end </span><br></pre></td></tr></table></figure>

<h4 id="接受原语"><a href="#接受原语" class="headerlink" title="接受原语"></a>接受原语</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">procedure receive(b)</span><br><span class="line">  begin</span><br><span class="line">    j:=internal name; j为接收进程内部的标识符；</span><br><span class="line">    wait(j.sm);</span><br><span class="line">    wait(j.mutex);</span><br><span class="line">    remove(j.mq, i); 将消息队列中第一个消息移出；</span><br><span class="line">    signal(j.mutex);</span><br><span class="line">    b.sender:=i.sender; 将消息缓冲区i中的信息复制到接收区b;</span><br><span class="line">    b.size:=i.size;</span><br><span class="line">    b.text:=i.text;</span><br><span class="line">  end</span><br></pre></td></tr></table></figure>

<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h3><ul>
<li>为使程序能并发执行，系统还必须进行以下的一系列操作：<ol>
<li>创建进程</li>
<li>撤销进程</li>
<li>进程切换</li>
</ol>
</li>
</ul>
<h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h4><ol>
<li>轻型实体</li>
<li>独立调度和分派的基本单位</li>
<li>可并发执行</li>
<li>共享进程资源</li>
</ol>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><ol>
<li>状态参数</li>
</ol>
<ul>
<li>在OS中的每一个线程都可以利用<strong>线程标识符</strong>和<strong>一组状态参数</strong>进行描述。</li>
<li>状态参数通常有这样几项：<ol>
<li>寄存器状态，它包括程序计数器PC和堆栈指针中的内容；</li>
<li>堆栈，在堆栈中通常保存有局部变量和返回地址；</li>
<li>线程运行状态，用于描述线程正处于何种运行状态；</li>
<li>优先级，描述线程执行的优先程度；</li>
<li>线程专有存储器，用于保存线程自己的局部变量拷贝；</li>
<li>信号屏蔽，即对某些信号加以屏蔽。</li>
</ol>
</li>
</ul>
<ol start="2">
<li>线程运行状态</li>
</ol>
<ul>
<li>三种基本状态：<ol>
<li>执行状态</li>
<li>就绪状态</li>
<li>阻塞状态</li>
</ol>
</li>
</ul>
<h4 id="线程的创建和终止"><a href="#线程的创建和终止" class="headerlink" title="线程的创建和终止"></a>线程的创建和终止</h4><ul>
<li>在创建新线程时，需要利用一个线程创建函数（或系统调用），并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。</li>
<li>在线程创建函数执行完后，将返回一个线程标识符供以后使用。</li>
<li>终止线程的方式有两种：<ol>
<li>在线程完成了自己的工作后自愿退出；</li>
<li>线程在运行中出现错误或由于某种原因而被其它线程强行终止。</li>
</ol>
</li>
</ul>
<h4 id="多线程OS中的进程"><a href="#多线程OS中的进程" class="headerlink" title="多线程OS中的进程"></a>多线程OS中的进程</h4><ul>
<li>在多线程OS中，进程是作为拥有系统资源的基本单位，通常的进程都包含多个线程并为它们提供资源，<strong>但此时的进程就不再作为一个执行的实体</strong>。</li>
<li>多线程OS中的进程有以下属性：<ol>
<li>作为系统资源分配的单位；</li>
<li>可包括多个线程；</li>
<li>进程不是一个可执行的实体。</li>
</ol>
</li>
</ul>
<h3 id="线程间的同步和通信"><a href="#线程间的同步和通信" class="headerlink" title="线程间的同步和通信"></a>线程间的同步和通信</h3><h4 id="互斥锁-mutex"><a href="#互斥锁-mutex" class="headerlink" title="互斥锁(mutex)"></a>互斥锁(mutex)</h4><ul>
<li>互斥锁是一种比较简单的、用于实现进程间对资源互斥访问的机制。</li>
<li>由于<strong>操作互斥锁的时间和空间开销都比较低</strong>，因而比较适合用于高频度使用的关键共享数据和程序段。</li>
<li>互斥锁有**开锁(unlock)<strong>和</strong>关锁(lock)**状态。</li>
<li>相应地，可用两条命令（函数）对互斥锁进行操作。其中的关锁lock操作用于将mutex关上，开锁操作unlock则用于打开mutex。</li>
</ul>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><ul>
<li>每一个条件变量通常都与一个互斥锁一起使用。即，在创建一个互斥锁时便联系着一个条件变量。</li>
<li>单纯的互斥锁用于短期锁定，主要是用来保证对临界区的互斥进入。</li>
<li><strong>而条件变量则用于线程的长期等待</strong>，直至所等待的资源成为可用的。</li>
<li>线程首先对mutex执行关锁操作，若成功便进入临界区，然后查找用于描述资源状态的数据结构，以了解资源的情况。</li>
<li>只要发现所需资源R正处于忙碌状态，线程便转为等待状态，并对mutex执行开锁操作后，等待该资源被释放；</li>
<li>若资源处于空闲状态，表明线程可以使用该资源，于是将该资源设置为忙碌状态，再对mutex执行开锁操作。</li>
</ul>
<h4 id="信号量机制-1"><a href="#信号量机制-1" class="headerlink" title="信号量机制"></a>信号量机制</h4><ol>
<li>私用信号量</li>
<li>公用信号量</li>
</ol>
<h3 id="内核支持线程和用户级线程"><a href="#内核支持线程和用户级线程" class="headerlink" title="内核支持线程和用户级线程"></a>内核支持线程和用户级线程</h3><h4 id="内核支持线程"><a href="#内核支持线程" class="headerlink" title="内核支持线程"></a>内核支持线程</h4><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><h4 id="内核支持线程的实现"><a href="#内核支持线程的实现" class="headerlink" title="内核支持线程的实现"></a>内核支持线程的实现</h4><h4 id="用户级线程的实现"><a href="#用户级线程的实现" class="headerlink" title="用户级线程的实现"></a>用户级线程的实现</h4><ol>
<li>运行时系统</li>
</ol>
<ul>
<li>所谓“运行时系统”，实质上是用于管理和控制线程的函数（过程）的集合，其中包括用于创建和撤销线程的函数、线程同步和通信的函数以及实现线程调度的函数等。</li>
<li>正因为有这些函数，才能使用户级线程与内核无关。运行时系统中的所有函数都驻留在用户空间，并作为用户级线程与内核之间的接口。</li>
</ul>
<ol start="2">
<li>内核控制线程</li>
</ol>
<ul>
<li>这种线程又称为轻型线程LWP(Light Weight Process)。每一个进程都可拥有多个LWP，同用户级线程一样，每个LWP都有自己的数据结构（如TCB），其中包括线程标识符、优先级、状态，另外还有栈和局部存储区等。</li>
<li>它们也可以共享进程所拥有的资源。</li>
<li>LWP可通过系统调用来获得内核提供的服务。这样，当一个用户级线程运行时，只要将它连接到一个LWP上，此时它便具有了内核支持线程的所有属性。</li>
</ul>
<img src="/articles/c94444f9/利用轻型进程作为中间系统.png" width="70%" height="70%" />
<p style="text-align: center;">利用轻型进程作为中间系统</p>

<h1 id="第三章-处理及调度与死锁"><a href="#第三章-处理及调度与死锁" class="headerlink" title="第三章 处理及调度与死锁"></a>第三章 处理及调度与死锁</h1><h2 id="处理机调度的基本概念"><a href="#处理机调度的基本概念" class="headerlink" title="处理机调度的基本概念"></a>处理机调度的基本概念</h2><h3 id="高级、中级和低级调度"><a href="#高级、中级和低级调度" class="headerlink" title="高级、中级和低级调度"></a>高级、中级和低级调度</h3><h4 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h4><ul>
<li>在每次执行作业调度时，都须做出以下两个决定：<ol>
<li>接纳多少个作业</li>
<li>接纳哪些作业</li>
</ol>
</li>
</ul>
<h4 id="低级调度-Low-Level-Scheduling"><a href="#低级调度-Low-Level-Scheduling" class="headerlink" title="低级调度(Low Level Scheduling)"></a>低级调度(Low Level Scheduling)</h4><ol>
<li><strong>非抢占方式(Non-preemptive Mode)</strong></li>
</ol>
<ul>
<li>在采用非抢占调度时，可能引起进程调度的因素可以归结为这样几个：<ol>
<li>正在执行的进程执行完毕，或因发生某事件而不能再继续执行；</li>
<li>执行中的进程因提出I&#x2F;O请求而暂停执行；</li>
<li>在进程通信或同步过程中执行了某种原语操作，如P操作（wait操作）、Block原语、Wakeup原语等。</li>
</ol>
</li>
<li>这种调度方式的优点是<strong>实现简单、系统开销小</strong>，<strong>适用于大多数的批处理系统环境</strong>。</li>
<li>但它<strong>难以满足紧急任务的要求</strong>——立即执行，因而可能造成难以预料的后果。</li>
<li>显然，<strong>在要求比较严格的<u>实时系统</u>中，不宜采用这种调度方式</strong>。</li>
</ul>
<ol start="2">
<li><strong>抢占方式(Preemptive Mode)</strong></li>
</ol>
<ul>
<li>抢占的原则有：<ol>
<li>优先权原则</li>
<li>短作业（进程）优先原则</li>
<li>时间片原则</li>
</ol>
</li>
</ul>
<h4 id="中级调度-Intermediate-Level-Scheduling"><a href="#中级调度-Intermediate-Level-Scheduling" class="headerlink" title="中级调度(Intermediate-Level Scheduling)"></a>中级调度(Intermediate-Level Scheduling)</h4><ul>
<li>中级调度又称中程调度(Medium-Term Scheduling)。</li>
<li>引入中级调度的主要目的，是为了<strong>提高内存利用率</strong>和<strong>系统吞吐量</strong>。</li>
<li>为此，应使那些暂时不能运行的进程不再占用宝贵的内存资源，而将它们调至外存上去等待，把此时的进程状态称为就绪驻外存状态或挂起状态。当这些进程重又具备运行条件、且内存又稍有空闲时，由中级调度来决定把外存上的哪些又具备运行条件的就绪进程，重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待进程调度。</li>
</ul>
<h4 id="高、中、低级调度的区别"><a href="#高、中、低级调度的区别" class="headerlink" title="高、中、低级调度的区别"></a>高、中、低级调度的区别</h4><p>在操作系统中，高级调度、中级调度和低级调度是三种不同层次的进程调度方式，它们在功能、调度对象和频率上有所区别。</p>
<p><strong>1. 高级调度（作业调度或长程调度）</strong></p>
<ul>
<li><strong>功能：</strong><ul>
<li>主要负责将外存（如硬盘）上的作业调入内存，为它们创建进程。</li>
<li>决定哪些作业可以进入内存，从而控制进入系统的作业数量。</li>
</ul>
</li>
<li><strong>调度对象：</strong><ul>
<li>作业（Job）。</li>
</ul>
</li>
<li><strong>调度频率：</strong><ul>
<li>较低，通常在作业进入系统或结束时进行。</li>
</ul>
</li>
<li><strong>特点：</strong><ul>
<li>主要用于批处理系统，目的是提高系统的吞吐量和资源利用率。</li>
<li>选择作业的依据通常是作业的优先级、资源需求等。</li>
</ul>
</li>
</ul>
<p><strong>2. 中级调度（内存调度或交换调度）</strong></p>
<ul>
<li><strong>功能：</strong><ul>
<li>负责内存和外存之间的进程交换，将暂时不能运行的进程调到外存（挂起状态），以释放内存空间。</li>
<li>提高内存利用率和系统吞吐量。</li>
</ul>
</li>
<li><strong>调度对象：</strong><ul>
<li>进程（Process）。</li>
</ul>
</li>
<li><strong>调度频率：</strong><ul>
<li>中等，通常在内存资源紧张时进行。</li>
</ul>
</li>
<li><strong>特点：</strong><ul>
<li>引入中级调度是为了提高内存的利用率，使得在内存资源紧张的时候，可以把暂时不能运行的进程挂起，从而腾出一些内存空间。</li>
<li>处于挂起状态的进程，在具备运行条件且内存又稍有空闲时，再由中级调度来决定把外存上的具备运行条件的就绪进程重新调入内存，修改其状态为就绪态，挂在就绪队列上。</li>
</ul>
</li>
</ul>
<p><strong>3. 低级调度（进程调度或短程调度）</strong></p>
<ul>
<li><strong>功能：</strong><ul>
<li>负责从就绪队列中选择一个进程，将处理器（CPU）分配给它。</li>
<li>是操作系统中最基本的调度，决定哪个进程占用 CPU 运行。</li>
</ul>
</li>
<li><strong>调度对象：</strong><ul>
<li>进程（Process）或线程（Thread）。</li>
</ul>
</li>
<li><strong>调度频率：</strong><ul>
<li>最高，通常几十毫秒一次。</li>
</ul>
</li>
<li><strong>特点：</strong><ul>
<li>是操作系统核心，对系统性能影响最大。</li>
<li>选择进程的依据通常是进程的优先级、时间片轮转等。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>高级调度：关注作业的整体调度，决定哪些作业进入内存。</li>
<li>中级调度：关注内存的利用率，负责进程的内存交换。</li>
<li>低级调度：关注 CPU 的分配，决定哪个进程占用 CPU 运行。</li>
</ul>
<p>这三种调度方式共同协作，实现了对系统资源的有效管理和调度。</p>
<h3 id="选择调度方式和调度算法的若干准则"><a href="#选择调度方式和调度算法的若干准则" class="headerlink" title="选择调度方式和调度算法的若干准则"></a>选择调度方式和调度算法的若干准则</h3><h4 id="面向用户的准则"><a href="#面向用户的准则" class="headerlink" title="面向用户的准则"></a>面向用户的准则</h4><ol>
<li><strong>周转时间短</strong></li>
</ol>
<ul>
<li><strong>周转时间公式：</strong>  <img src="/articles/c94444f9/周转时间公式.png" width=15% height=70% /></li>
<li><strong>带权周转时间公式：</strong>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mi>T</mi><mi mathvariant="normal">/</mi><msub><mi>T</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">W=T/T_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li><strong>平均带权周转时间公式：</strong>  <img src="/articles/c94444f9/平均带权周转时间公式.png" width=15% height=70% /></li>
</ul>
<ol start="2">
<li>响应时间快</li>
<li>截至时间的保证</li>
<li>优先权准则</li>
</ol>
<h4 id="面向系统的准则"><a href="#面向系统的准则" class="headerlink" title="面向系统的准则"></a>面向系统的准则</h4><ol>
<li>系统吞吐量高</li>
<li>处理机利用率好</li>
<li>各类资源的平衡利用</li>
</ol>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务-FCFS-和短作业（进程）优先调度算法-SJF"><a href="#先来先服务-FCFS-和短作业（进程）优先调度算法-SJF" class="headerlink" title="先来先服务(FCFS)和短作业（进程）优先调度算法(SJF)"></a>先来先服务(FCFS)和短作业（进程）优先调度算法(SJF)</h3><h4 id="先来先服务调度算法"><a href="#先来先服务调度算法" class="headerlink" title="先来先服务调度算法"></a>先来先服务调度算法</h4><img src="/articles/c94444f9/FCFS.png" width=70% height=70% />

<h4 id="FCFS和SJF性能比较"><a href="#FCFS和SJF性能比较" class="headerlink" title="FCFS和SJF性能比较"></a>FCFS和SJF性能比较</h4><img src="/articles/c94444f9/FCFS和SJF.png" width=70% height=70% />

<h4 id="短作业（进程）优先调度算法"><a href="#短作业（进程）优先调度算法" class="headerlink" title="短作业（进程）优先调度算法"></a>短作业（进程）优先调度算法</h4><ul>
<li>缺点：<ol>
<li>对长作业不利。</li>
<li>完全未考虑作业的紧迫程度，不能保证紧迫性作业（进程）会被及时处理</li>
<li>执行时间是用户估计的，不一定能真正做到短作业优先调度</li>
</ol>
</li>
</ul>
<h3 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h3><h4 id="优先权调度算法的类型"><a href="#优先权调度算法的类型" class="headerlink" title="优先权调度算法的类型"></a>优先权调度算法的类型</h4><ol>
<li>非抢占式优先权算法</li>
</ol>
<ul>
<li>这种调度算法主要用于<strong>批处理系统</strong>中；也可用于某些<strong>对实时性要求不严</strong>的实时系统中。</li>
</ul>
<ol start="2">
<li>抢占式优先权调度算法</li>
</ol>
<ul>
<li>常用于<strong>要求比较严格的实时系统</strong>中， 以及<strong>对性能要求较高的批处理和分时系统</strong>中。</li>
</ul>
<h4 id="优先权的类型"><a href="#优先权的类型" class="headerlink" title="优先权的类型"></a>优先权的类型</h4><ol>
<li>静态优先权</li>
</ol>
<ul>
<li>确定优先权的依据：<ol>
<li>进程类型</li>
<li>进程对资源的需求</li>
<li>用户要求</li>
</ol>
</li>
</ul>
<ol start="2">
<li>动态优先权</li>
</ol>
<ul>
<li>例如，我们可以规定，在就绪队列中的进程，<strong>随其等待时间的增长，其优先权以速率a提高</strong>。<ul>
<li><strong>若所有的进程都具有相同的优先权初值</strong>，则显然是最先进入就绪队列的进程，将因其动态优先权变得最高而优先获得处理机，<strong>此即FCFS算法</strong>。</li>
<li>若所有的就绪进程具有各不相同的优先权初值，那么，对于优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机。</li>
</ul>
</li>
<li>当采用<strong>抢占式优先权调度算法</strong>时，如果再规定当前进程的优先权<strong>以速率b下降</strong>，则可防止一个长作业长期地垄断处理机。</li>
</ul>
<h4 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h4><ul>
<li><p>优先权等于响应比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">R_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<img src="/articles/c94444f9/优先权公式.png" width=70% height=70% />
</li>
<li><p>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。</p>
</li>
<li><p>当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。</p>
</li>
<li><p><strong>对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高， 从而也可获得处理机。</strong></p>
</li>
</ul>
<h3 id="基于时间片的轮转调度算法"><a href="#基于时间片的轮转调度算法" class="headerlink" title="基于时间片的轮转调度算法"></a>基于时间片的轮转调度算法</h3><h4 id="时间偏轮转法"><a href="#时间偏轮转法" class="headerlink" title="时间偏轮转法"></a>时间偏轮转法</h4><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><ul>
<li><p>应设置多个就绪队列，并为各个队列赋予不同的优先级。 第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。</p>
</li>
<li><p>例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。如图：</p>
<img src="/articles/c94444f9/多级反馈队列调度算法.png" width=50% height=70% />
</li>
<li><p>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n队列中便采取按时间片轮转的方式运行。</p>
</li>
<li><p>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第<code>1~(i-1)</code> 队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第<code>1~(i-1)</code>中的任何一个队列)，则此时新进程将<strong>抢占</strong>正在运行进程的处理机，即由调度程序<strong>把正在运行的进程放回到第i队列的末尾</strong>，把处理机分配给新到的高优先权进程。</p>
</li>
<li><p><strong>多级反馈队列调度算法的性能</strong></p>
<ol>
<li>终端型作业用户</li>
<li>短批处理作业用户</li>
<li>长批处理作业用户</li>
</ol>
</li>
</ul>
<h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3><h4 id="提供必要的信息"><a href="#提供必要的信息" class="headerlink" title="提供必要的信息"></a>提供必要的信息</h4><ol>
<li>就绪时间</li>
<li>开始截止时间和完成截止时间</li>
<li>处理时间</li>
<li>资源要求</li>
<li>优先级</li>
</ol>
<h4 id="系统处理能力强"><a href="#系统处理能力强" class="headerlink" title="系统处理能力强"></a>系统处理能力强</h4><ul>
<li><p>假定系统中有m个周期性的硬实时任务，它们的处理时间可表示为Ci，周期时间表示为Pi，则在单处理机情况下，必须满足下面的限制条件，系统才是可调度的。</p>
<img src="/articles/c94444f9/系统处理能力.png" width=15% height=70% />
</li>
<li><p>解决办法：</p>
<ol>
<li>仍采用单处理机系统，但增强其处理能力，以显著地减少对每一个任务的处理时间；</li>
<li>采用多处理机系统。假定系统中的处理机数为N，则应将上述的限制条件改为：<img src="/articles/c94444f9/多处理机系统.png" width=15% height=70% /></li>
</ol>
</li>
</ul>
<h4 id="采用抢占式调度机制"><a href="#采用抢占式调度机制" class="headerlink" title="采用抢占式调度机制"></a>采用抢占式调度机制</h4><ul>
<li>当一个优先权更高的任务到达时，允许将当前任务暂时挂起，而令高优先权任务立即投入运行，这样便可满足该硬实时任务对截止时间的要求。但这种调度机制比较复杂。</li>
<li>对于一些小的实时系统，如果能预知任务的开始截止时间，则对实时任务的调度可采用非抢占调度机制，以简化调度程序和对任务调度时所花费的系统开销。但在设计这种调度机制时，应使所有的实时任务都比较小，并在执行完关键性程序和临界区后，能及时地将自己阻塞起来，以便释放出处理机，供调度程序去调度那种开始截止时间即将到达的任务。</li>
</ul>
<h4 id="具有快速切换机制"><a href="#具有快速切换机制" class="headerlink" title="具有快速切换机制"></a>具有快速切换机制</h4><ol>
<li>对外部中断的快速响应能力。</li>
<li>快速的任务分派能力。</li>
</ol>
<h3 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h3><h4 id="非抢占式调度算法"><a href="#非抢占式调度算法" class="headerlink" title="非抢占式调度算法"></a>非抢占式调度算法</h4><ol>
<li>非抢占式轮转调度算法</li>
<li>非抢占式优先调度算法</li>
</ol>
<h4 id="抢占式调度算法"><a href="#抢占式调度算法" class="headerlink" title="抢占式调度算法"></a>抢占式调度算法</h4><ol>
<li>基于<strong>时钟中断</strong>的抢占式优先权调度算法</li>
<li>立即抢占(Immediate Preemption)的优先权调度算法</li>
</ol>
<h3 id="常用的实时调度算法"><a href="#常用的实时调度算法" class="headerlink" title="常用的实时调度算法"></a>常用的实时调度算法</h3><h4 id="最早截至时间优先算法-EDF-Eariest-Deadline-First"><a href="#最早截至时间优先算法-EDF-Eariest-Deadline-First" class="headerlink" title="最早截至时间优先算法(EDF, Eariest Deadline First)"></a>最早截至时间优先算法(EDF, Eariest Deadline First)</h4><h4 id="最低松弛度优先算法-LLf-Least-Laxity-First"><a href="#最低松弛度优先算法-LLf-Least-Laxity-First" class="headerlink" title="最低松弛度优先算法(LLf, Least Laxity First)"></a>最低松弛度优先算法(LLf, Least Laxity First)</h4><ul>
<li>例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的 <strong>紧急程度(松弛程度)</strong> 为100 ms。</li>
<li>一个按松弛度排序的实时任务就绪队列，松弛度最低（即紧急程度最高）的任务排在队列最前面，调度程序总是选择就绪队列中的队首任务执行。</li>
<li>该算法主要用于<strong>可抢占</strong>调度方式中。</li>
<li>周期性实时任务题目（见第三章ppt-38，<strong>很复杂</strong>）</li>
</ul>
<h2 id="多处理机系统中的调度"><a href="#多处理机系统中的调度" class="headerlink" title="多处理机系统中的调度"></a>多处理机系统中的调度</h2><h3 id="多处理器系统的类型"><a href="#多处理器系统的类型" class="headerlink" title="多处理器系统的类型"></a>多处理器系统的类型</h3><h4 id="紧密耦合多处理器系统-TCMPS-Tightly-Coupted-Multiprocessor-System"><a href="#紧密耦合多处理器系统-TCMPS-Tightly-Coupted-Multiprocessor-System" class="headerlink" title="紧密耦合多处理器系统(TCMPS, Tightly Coupted Multiprocessor System)"></a>紧密耦合多处理器系统(TCMPS, Tightly Coupted Multiprocessor System)</h4><ul>
<li>这通常是通过高速总线或高速交叉开关，来实现多个处理器之间的互连的。</li>
<li>它们共享主存储器系统和I&#x2F;O设备，并要求将主存储器划分为若干个能独立访问的存储器模块，以便多个处理机能同时对主存进行访问。系统中的所有资源和进程，都由操作系统实施统一的控制和管理。</li>
</ul>
<h4 id="对称多处理器系统-SMPS-Symmetric-MultiProcessor-System"><a href="#对称多处理器系统-SMPS-Symmetric-MultiProcessor-System" class="headerlink" title="对称多处理器系统(SMPS, Symmetric MultiProcessor System)"></a>对称多处理器系统(SMPS, Symmetric MultiProcessor System)</h4><ul>
<li>在系统中所包含的<strong>各处理器单元</strong>，<strong>在功能和结构上都是相同的</strong>，当前的绝大多数MPS都属于SMP系统。例如，IBM公司的SR&#x2F;6000 Model F50, 便是利用4片Power PC处理器构成的。</li>
</ul>
<h4 id="非对称多处理器系统-ASMP-Asymmetric-Multiprocessing-System"><a href="#非对称多处理器系统-ASMP-Asymmetric-Multiprocessing-System" class="headerlink" title="非对称多处理器系统(ASMP, Asymmetric Multiprocessing System)"></a>非对称多处理器系统(ASMP, Asymmetric Multiprocessing System)</h4><ul>
<li>在系统中有<strong>多种类型的处理单元</strong>，<strong>它们的功能和结构各不相同</strong>，其中只有一个主处理器，有多个从处理器。</li>
</ul>
<h3 id="进程分配方式"><a href="#进程分配方式" class="headerlink" title="进程分配方式"></a>进程分配方式</h3><h4 id="对称多处理器系统中的进程分配方式"><a href="#对称多处理器系统中的进程分配方式" class="headerlink" title="对称多处理器系统中的进程分配方式"></a>对称多处理器系统中的进程分配方式</h4><ul>
<li>在SMP系统中，所有的处理器都是相同的，因而可把所有的处理器作为一个处理器池(Processor pool)，由调度程序或基于处理器的请求，<strong>将任何一个进程分配给池中的任何一个处理器去处理</strong>。在进行进程分配时，可采用以下两种方式之一。 <ol>
<li>静态分配方式(Static Assignment)</li>
<li>动态分配方式(Dynamic Assignment)</li>
</ol>
</li>
</ul>
<h4 id="非对称多处理器系统中的进程分配方式"><a href="#非对称多处理器系统中的进程分配方式" class="headerlink" title="非对称多处理器系统中的进程分配方式"></a>非对称多处理器系统中的进程分配方式</h4><ul>
<li>对于非对称MPS，其OS大多采用<strong>主—从(Master-Slave)式OS</strong>，即OS的核心部分驻留在一台主机上(Master)，而从机(Slave)上只是用户程序，进程调度只由主机执行。</li>
<li>每当从机空闲时，便向主机发送一个索求进程的信号，然后，便等待主机为它分配进程。在主机中保持有一个就绪队列，只要就绪队列不空，主机便从其队首摘下一进程分配给请求的从机。</li>
<li>从机接收到分配的进程后便运行该进程，该进程结束后从机又向主机发出请求。</li>
</ul>
<h3 id="进程（线程）调度方式"><a href="#进程（线程）调度方式" class="headerlink" title="进程（线程）调度方式"></a>进程（线程）调度方式</h3><h4 id="自调度方式-Self-Scheduling"><a href="#自调度方式-Self-Scheduling" class="headerlink" title="自调度方式(Self-Scheduling)"></a>自调度方式(Self-Scheduling)</h4><ol>
<li>自调度机制</li>
</ol>
<ul>
<li>在多处理器系统中，自调度方式是<strong>最简单</strong>的一种调度方式。</li>
<li>在系统中设置有一个公共的进程或线程就绪队列，所有的处理器在空闲时，都可自己到该队列中取得一进程(或线程)来运行。</li>
<li>优点：<br>自调度方式的主要优点表现为：首先，系统中的公共就绪队列可按照单处理机系统中所采用的各种方式加以组织； 其调度算法也可沿用单处理机系统所用的算法，亦即，很容易将单处理机环境下的调度机制移植到多处理机系统中， 故它仍然是当前多处理机系统中较常用的调度方式。其次， 只要系统中有任务，或者说只要公共就绪队列不空，就不会出现处理机空闲的情况，也不会发生处理器忙闲不均的现象，因而有利于提高处理器的利用率。 </li>
<li>缺点：<ol>
<li>瓶颈问题</li>
<li>低效性</li>
<li>线程切换频率</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>成组调度方式(Gang Scheduling)<br>  (1) 面向所有应用程序平均分配处理器时间<br>  (2) 面向所有线程平均分配处理器时间 </p>
</li>
<li><p>专用处理器分配方式(Dedicated Processor Assignment)</p>
</li>
</ol>
<h2 id="产生死锁的原因和必要条件"><a href="#产生死锁的原因和必要条件" class="headerlink" title="产生死锁的原因和必要条件"></a>产生死锁的原因和必要条件</h2><h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><ol>
<li>竞争资源</li>
<li>进程间推进顺序非法</li>
</ol>
<h4 id="竞争资源引起死锁"><a href="#竞争资源引起死锁" class="headerlink" title="竞争资源引起死锁"></a>竞争资源引起死锁</h4><ol>
<li>可剥夺和非剥夺性资源</li>
<li>竞争非剥夺性资源</li>
<li>竞争临时资源</li>
</ol>
<img src="/articles/c94444f9/IO死锁.png" width=20% height=70% />
<p style="text-align: center;">I/O设备共享时的死锁情况</p>

<img src="/articles/c94444f9/IO死锁.png" width=20% height=70% />
<p style="text-align: center;">进程之间通信时的死锁情况</p>

<h4 id="进程推进顺序不当引起死锁"><a href="#进程推进顺序不当引起死锁" class="headerlink" title="进程推进顺序不当引起死锁"></a>进程推进顺序不当引起死锁</h4><ol>
<li>进程推进顺序合法（不会发生死锁）</li>
<li>进程推进顺序非法（循环等待）</li>
</ol>
<h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><ol>
<li><strong>互斥条件</strong></li>
<li><strong>请求和保持条件</strong></li>
<li><strong>不剥夺条件</strong></li>
<li><strong>环路等待条件</strong></li>
</ol>
<h3 id="处理死锁的基本方法"><a href="#处理死锁的基本方法" class="headerlink" title="处理死锁的基本方法"></a>处理死锁的基本方法</h3><ol>
<li>预防死锁</li>
<li>避免死锁</li>
<li>检测死锁</li>
<li>解除死锁</li>
</ol>
<h2 id="预防死锁的方法"><a href="#预防死锁的方法" class="headerlink" title="预防死锁的方法"></a>预防死锁的方法</h2><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><ol>
<li>摒弃“请求和保持”条件 </li>
<li>摒弃“不剥夺”条件 </li>
<li>摒弃“环路等待”条件</li>
</ol>
<h3 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h3><ul>
<li>核心思想：<ul>
<li>动态资源分配与安全性检查：<ul>
<li>允许进程动态申请资源。</li>
<li>在分配资源前，系统进行安全性计算。</li>
<li>只有当分配不会导致系统进入不安全状态时，才分配资源。</li>
<li>否则，进程等待。</li>
</ul>
</li>
</ul>
</li>
<li>安全状态与不安全状态：<ul>
<li>安全状态：<ul>
<li>系统能找到一个进程执行顺序（安全序列）。</li>
<li>按照此顺序，每个进程都能获得所需资源并完成。</li>
</ul>
</li>
<li>不安全状态：<ul>
<li>系统无法找到任何安全序列。</li>
<li>可能导致死锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul>
<li>看王道</li>
<li>有点像某个数字游戏</li>
<li>如果系统处于<strong>安全状态</strong>，就<strong>一定不会</strong>发生<strong>死锁</strong>；如果系统进入<strong>不安全状态</strong>，就<strong>可能</strong>发生<strong>死锁</strong>。</li>
<li>处于不安全状态未必会发生死锁，但发生死锁时一定是在不安全状态。</li>
<li>银行家算法的<strong>核心思想</strong>：因此可以<strong>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态</strong>，以此决定是否答应资源分配请求。</li>
<li>用在操作系统上，资源用矢量代替。</li>
<li>代码表示<ul>
<li>n*m矩阵-<code>Max</code>-各进程最大需求</li>
<li>n*m矩阵-<code>Allocation</code>-分配矩阵（已为每个进程分配了多少资源）</li>
<li>n*m矩阵-<code>Need</code>&#x3D;<code>Max-Allocation</code>-各进程最多还需多少各类资源</li>
<li>len&#x3D;m的一维数组-<code>Available</code>-表示当前系统中还有多少可用资源</li>
<li>len&#x3D;m的一维数组-<code>Request_i</code>-表示某进程向系统申请的各种资源</li>
<li><strong>分配资源</strong>：<ul>
<li>需改变<code>Available</code>、<code>Allocation</code>、<code>Need</code>数组，然后执行安全性检查（用以下<strong>安全性算法</strong>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>安全性算法</strong>：<ul>
<li><code>Work</code>（初始化为<code>Available</code>）、<code>Need</code>、<code>Allocation</code>、<code>Work+Allocation</code>、<code>finish</code>。</li>
<li>循环查找：<ol>
<li>从所有<code>Finish[i]==false</code>的进程中，查找一个进程i，满足<code>Need[i]&lt;=Work</code>。</li>
<li>如果找到这样的进程<code>i</code>，执行以下操作：</li>
</ol>
<ul>
<li><code>Work = Work + Allocation[i]</code> （模拟进程<code>i</code>完成，释放其占有的资源）。</li>
<li><code>Finish[i]=true</code>（标记进程<code>i</code>已完成）</li>
</ul>
<ol start="3">
<li>重复上述步骤，直到所有进程都完成（即所有<code>Finish[i]</code>都为<code>true</code>），或者找不到满足条件的进程。</li>
</ol>
</li>
<li>安全性判断：<ul>
<li>如果所有<code>Finish[i]</code>都为<code>true</code>，则系统处于安全状态。</li>
<li>否则，系统处于不安全状态，可能发生死锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h2><ul>
<li>看王道</li>
</ul>
<h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><ul>
<li>最终<strong>能消除所有边</strong>，就称这个图是<strong>可完全简化的</strong>。此时一定<strong>没有发生死锁</strong>（相当于能找到一个安全序列）。</li>
<li>如果最终<strong>不能消除所有边</strong>，那么此时就是<strong>发生了死锁</strong>。</li>
<li><strong>最终还连着边的那些进程就是处于死锁状态的进程。</strong></li>
</ul>
<h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li><strong>资源剥夺法</strong>。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li><strong>撤销进程法</strong>（或称<strong>终止进程法</strong>）。强制撤销部分、甚至全部死锁进程，并剥夺这些资源。这种方法的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>
</ol>
<h4 id="如何决定“对谁动手”"><a href="#如何决定“对谁动手”" class="headerlink" title="如何决定“对谁动手”"></a>如何决定“对谁动手”</h4><ol>
<li><strong>进程优先级</strong></li>
<li><strong>已执行多长时间</strong></li>
<li><strong>还要多久能完成</strong></li>
<li><strong>进程已经使用了多少资源</strong></li>
<li><strong>进程是交互式的还是批处理式的</strong></li>
</ol>
<h1 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h1><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><h2 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title="连续分配方式"></a>连续分配方式</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><ul>
<li>最简单的一种存储管理方式</li>
<li>只能用于单用户、单任务的操作系统中</li>
<li>把内存区分为两部分：<ul>
<li>系统区仅提供给OS使用，通常是放在内存的低址部分；</li>
<li>用户区是指系统区以外的全部内存空间，提供给用户使用。</li>
</ul>
</li>
</ul>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><h4 id="划分分区的方法"><a href="#划分分区的方法" class="headerlink" title="划分分区的方法"></a>划分分区的方法</h4><ul>
<li>分区大小相等，即使所有的内存分区大小相等</li>
<li>分区大小不等</li>
</ul>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><ol>
<li>空闲分区表</li>
<li>空闲分区链</li>
</ol>
<h4 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法"></a>分区分配算法</h4><ol>
<li>首次适应算法FF</li>
<li>循环首次适应算法，该算法是由首次适应算法演变而成的</li>
<li>最佳适应算法</li>
</ol>
<h3 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h3><ul>
<li>进行紧凑形成连续空闲区</li>
</ul>
<h2 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h2><h2 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h2><h2 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h2><ul>
<li>所谓虚拟存储器， 是指具有请求调入功能和置换功能， 能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、 中、 小型机器和微型机中。</li>
</ul>
<p>  </p>
<h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h3><ul>
<li>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</li>
<li>缺页中断之后未必发生页面置换。若还有可用的空闲内存块，就不用进行页面置换。</li>
<li>缺页率&#x3D;缺页中断的次数&#x2F;总共访问的页面次数*100%</li>
<li>因此操作系统实际无法提前预判页面访问序列，因此，最佳置换算法是理想的置换算法。在实际应用中是无法实现的。</li>
</ul>
<h3 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h3><ul>
<li><code>Belady异常</code>——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</li>
<li>**只有FIFO算法会产生<code>Belady异常</code>**。</li>
<li>另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。</li>
<li>因此，算法性能差。</li>
</ul>
<h3 id="最近最久未使用置换算法（LRU，Least-Recently-Used）"><a href="#最近最久未使用置换算法（LRU，Least-Recently-Used）" class="headerlink" title="最近最久未使用置换算法（LRU，Least Recently Used）"></a>最近最久未使用置换算法（LRU，Least Recently Used）</h3><ul>
<li>每次淘汰的页面是最近最久未使用的页面。</li>
<li>该算法的实现需要专门的硬件支持，虽然算法性能好，但是<strong>实现困难，开销大</strong>。</li>
</ul>
<h3 id="时钟置换算法（CLOCK-NRU）"><a href="#时钟置换算法（CLOCK-NRU）" class="headerlink" title="时钟置换算法（CLOCK &#x2F; NRU）"></a>时钟置换算法（CLOCK &#x2F; NRU）</h3><ul>
<li>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</li>
<li><strong>时钟置换算法</strong>是一种性能和开销较均衡的算法，又称<strong>CLOCK算法</strong>，或<strong>最近未用算法</strong>（<strong>NRU</strong>，Not Recently Used）</li>
</ul>
<h3 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h3><ul>
<li>用<code>（访问位，修改位）</code>的形式表示各页面状态。</li>
<li>改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描，而简单的时钟算法在淘汰一个页面的时候最多会进行两轮扫描。</li>
</ul>
<img src="/articles/c94444f9/页面置换算法.png" width=70% height=70% />

<h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><h1 id="第五章-设备管理"><a href="#第五章-设备管理" class="headerlink" title="第五章 设备管理"></a>第五章 设备管理</h1><h2 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I&#x2F;O系统"></a>I&#x2F;O系统</h2><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><h4 id="I-O设备的类型"><a href="#I-O设备的类型" class="headerlink" title="I&#x2F;O设备的类型"></a>I&#x2F;O设备的类型</h4><h5 id="按传输速率分类"><a href="#按传输速率分类" class="headerlink" title="按传输速率分类"></a>按传输速率分类</h5><ol>
<li><strong>低速设备。</strong><code>几字节~几百字节/s</code>，键盘、鼠标器、语音的I&#x2F;O设备。</li>
<li><strong>中速设备。</strong><code>数千字节~数万字节/s</code>，行式打印机、激光打印机。</li>
<li><strong>高速设备。</strong><code>数百千字节~数十兆字节</code>，磁带机、磁盘机、光盘机。</li>
</ol>
<h5 id="按信息交换的单位分类"><a href="#按信息交换的单位分类" class="headerlink" title="按信息交换的单位分类"></a>按信息交换的单位分类</h5><ol>
<li><strong>块设备（Block Device）</strong>。<blockquote>
<p>用于存储信息。<br>由于信息的存取总是以数据块为单位， 故而得名。<br>属于有结构设备。<br>典型的块设备是磁盘，每个盘块的大小为512B~4KB。<br>磁盘设备的基本特征是其传输速率较高，通常每秒钟为几兆位；另一特征是可寻址，即对它可随机地读&#x2F;写任一块；此外磁盘设备的I&#x2F;O常采用DMA方式。<br>ppt-5-p3</p>
</blockquote>
</li>
<li><strong>字符设备（character Device）</strong><blockquote>
<p>用于数据的输入和输出。<br>其基本单位是字符，故称为字符设备。</p>
</blockquote>
</li>
</ol>
<h5 id="按设备的共享属性分类"><a href="#按设备的共享属性分类" class="headerlink" title="按设备的共享属性分类"></a><strong>按设备的共享属性分类</strong></h5><ol>
<li>独占设备</li>
<li>共享设备</li>
<li>虚拟设备</li>
</ol>
<h4 id="设备与控制器之间的接口"><a href="#设备与控制器之间的接口" class="headerlink" title="设备与控制器之间的接口"></a>设备与控制器之间的接口</h4><h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><h3 id="I-O通道"><a href="#I-O通道" class="headerlink" title="I&#x2F;O通道"></a>I&#x2F;O通道</h3><h4 id="通道类型"><a href="#通道类型" class="headerlink" title="通道类型"></a>通道类型</h4><ol>
<li><strong>字节多路通道（Byte Multiplexor Channel）</strong></li>
</ol>
<ul>
<li>适用于低速设备（键盘、打印机），逐字节传输（Byte），可以同时管理多个低速设备，适用于低速外设的数据输入&#x2F;输出。</li>
</ul>
<ol start="2">
<li><strong>数组选择通道（Block selector Channel）</strong></li>
</ol>
<ul>
<li>适用于高速设备（磁盘、磁带），按块传输（Block），一次只能管理一个设备，适用于大数据量的存储读写。</li>
</ul>
<ol start="3">
<li><strong>数组多路通道（Block Multiplexor Channel）</strong></li>
</ol>
<ul>
<li>数组多路通道是将数组选择通道传输速率高和字节多路通道能使各子通道(设备)分时并行操作的优点相结合而形成的一种新通道。</li>
<li>数组多路通道是将数组选择通道传输速率高和字节多路通道能使各子通道(设备)分时并行操作的优点相结合而形成的一种新通道。</li>
<li>被广泛地用于连接多台高、中速的外围设备，其数据传送是按数组方式进行的。</li>
</ul>
<h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h2><h2 id="缓冲管理-1"><a href="#缓冲管理-1" class="headerlink" title="缓冲管理"></a>缓冲管理</h2><h2 id="设备分配-1"><a href="#设备分配-1" class="headerlink" title="设备分配"></a>设备分配</h2><h2 id="设备处理-1"><a href="#设备处理-1" class="headerlink" title="设备处理"></a>设备处理</h2><h2 id="磁盘存储器管理"><a href="#磁盘存储器管理" class="headerlink" title="磁盘存储器管理"></a>磁盘存储器管理</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://lucy23.blog">Lucy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://lucy23.blog/articles/c94444f9.html">http://lucy23.blog/articles/c94444f9.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/articles/cc2fa8c5.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">复试OS</div></div></a></div><div class="next-post pull-right"><a href="/articles/7de3dde6.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">考研数据库</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第一章 操作系统引论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">操作系统的目标和作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OS%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">OS的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9A"><span class="toc-number">1.1.2.</span> <span class="toc-text">系统调用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">操作系统的发展过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">无操作系统的计算机系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">单道批处理系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">多道批处理系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">分时系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.5.</span> <span class="toc-text">实时系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">操作系统的基本特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91-Concurrency"><span class="toc-number">1.3.1.</span> <span class="toc-text">并发 (Concurrency)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB-Sharing"><span class="toc-number">1.3.2.</span> <span class="toc-text">共享 (Sharing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F-Virtualization"><span class="toc-number">1.3.3.</span> <span class="toc-text">虚拟 (Virtualization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-Asynchrony"><span class="toc-number">1.3.4.</span> <span class="toc-text">异步 (Asynchrony)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">1.4.</span> <span class="toc-text">操作系统的主要功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-number">1.4.1.</span> <span class="toc-text">处理机管理功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">进程控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">进程同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">进程通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-number">1.4.2.</span> <span class="toc-text">存储器管理功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">内存保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">地址映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">内存扩充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-number">1.4.3.</span> <span class="toc-text">设备管理功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">缓冲管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">设备分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%A4%84%E7%90%86"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">设备处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E8%AE%BE%E5%A4%87"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">虚拟设备</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-number">1.4.4.</span> <span class="toc-text">文件管理功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">文件存储空间的管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">目录管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB-%E5%86%99%E7%AE%A1%E7%90%86%E5%92%8C%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">文件的读&#x2F;写管理和保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">用户接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.5.</span> <span class="toc-text">操作系统的结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">软件工程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">软件的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">软件工程的含义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">传统的操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">无结构操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96OS%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">模块化OS结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%BC%8FOS%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">分层式OS结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8OS%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.3.</span> <span class="toc-text">微内核OS结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%BC%8F-Client-Server-Model"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">客户&#x2F;服务器模式(Client-Server Model)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF-Object-Orientated-Programming"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">面向对象的程序设计技术(Object-Orientated Programming)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8%E6%8A%80%E6%9C%AF"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">微内核技术</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">第二章 进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">进程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">程序顺序执行时的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%B6%8B%E5%9B%BE"><span class="toc-number">2.1.2.</span> <span class="toc-text">前趋图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.3.</span> <span class="toc-text">程序并发执行时的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%8E%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.4.</span> <span class="toc-text">进程的特征与状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">进程的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%83%E5%85%B8%E5%9E%8B%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E6%9C%89%EF%BC%9A"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">较典型的进程的定义有：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">进程的三种基本状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.4.4.</span> <span class="toc-text">挂起状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.4.5.</span> <span class="toc-text">进程状态的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">2.1.4.6.</span> <span class="toc-text">进程状态的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%88PCB%EF%BC%8CProcess-Control-Block%EF%BC%89"><span class="toc-number">2.1.4.7.</span> <span class="toc-text">进程控制块（PCB，Process Control Block）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6-1"><span class="toc-number">2.2.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.2.1.</span> <span class="toc-text">进程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%BE"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">进程图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E8%B5%B7%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">引起进程创建的事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA-1"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">进程的创建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-number">2.2.2.</span> <span class="toc-text">进程的终止</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E8%B5%B7%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2-Termination-of-Process-%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">引起进程终止(Termination of Process)的事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">进程的终止过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92"><span class="toc-number">2.2.3.</span> <span class="toc-text">进程的阻塞与唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E8%B5%B7%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E5%92%8C%E5%94%A4%E9%86%92%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">引起进程阻塞和唤醒的事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">进程阻塞过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%94%A4%E9%86%92%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">进程唤醒过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%E4%B8%8E%E6%BF%80%E6%B4%BB"><span class="toc-number">2.2.4.</span> <span class="toc-text">进程的挂起与激活</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">进程的挂起过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%BF%80%E6%B4%BB%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">进程的激活过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-1"><span class="toc-number">2.3.</span> <span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.3.1.</span> <span class="toc-text">进程同步的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">两种形式的制约关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">临界资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%BA%94%E9%81%B5%E5%BE%AA%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">同步机制应遵循的规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.2.</span> <span class="toc-text">信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F-vs-%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">整型信号量 vs. 记录型信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AND%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">AND型信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">信号量集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E8%B6%8B%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">利用信号量实现前趋关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.</span> <span class="toc-text">经典进程的同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.1.</span> <span class="toc-text">生产者-消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.2.</span> <span class="toc-text">1. 利用记录型信号量解决生产者-消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%A9%E7%94%A8-AND-%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.3.</span> <span class="toc-text">2. 利用 AND 信号量解决生产者-消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.4.</span> <span class="toc-text">哲学家进餐问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.5.</span> <span class="toc-text">读者-写者问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.</span> <span class="toc-text">管程机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.5.1.</span> <span class="toc-text">管程的基本概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-1"><span class="toc-number">2.6.</span> <span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.1.</span> <span class="toc-text">进程通信的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.2.</span> <span class="toc-text">消息传递通信的实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">直接通信方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.2.2.</span> <span class="toc-text">间接通信方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.3.</span> <span class="toc-text">消息传递系统实现中的若干问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF"><span class="toc-number">2.6.3.1.</span> <span class="toc-text">通信链路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.6.3.2.</span> <span class="toc-text">消息的格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.3.3.</span> <span class="toc-text">进程同步的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%BC%93%E5%86%B2%E9%98%9F%E5%88%97%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">2.6.4.</span> <span class="toc-text">消息缓冲队列通信机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%8E%9F%E8%AF%AD"><span class="toc-number">2.6.4.2.</span> <span class="toc-text">发送原语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E5%8E%9F%E8%AF%AD"><span class="toc-number">2.6.4.3.</span> <span class="toc-text">接受原语</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.7.1.</span> <span class="toc-text">线程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">线程的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">线程的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%88%E6%AD%A2"><span class="toc-number">2.7.1.3.</span> <span class="toc-text">线程的创建和终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8BOS%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.7.1.4.</span> <span class="toc-text">多线程OS中的进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E9%80%9A%E4%BF%A1"><span class="toc-number">2.7.2.</span> <span class="toc-text">线程间的同步和通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81-mutex"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">互斥锁(mutex)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-1"><span class="toc-number">2.7.2.3.</span> <span class="toc-text">信号量机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%94%AF%E6%8C%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.7.3.</span> <span class="toc-text">内核支持线程和用户级线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%94%AF%E6%8C%81%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">内核支持线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">用户级线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.7.4.</span> <span class="toc-text">线程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%94%AF%E6%8C%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">内核支持线程的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.7.4.2.</span> <span class="toc-text">用户级线程的实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%84%E7%90%86%E5%8F%8A%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">第三章 处理及调度与死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">处理机调度的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E3%80%81%E4%B8%AD%E7%BA%A7%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">3.1.1.</span> <span class="toc-text">高级、中级和低级调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">高级调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6-Low-Level-Scheduling"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">低级调度(Low Level Scheduling)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6-Intermediate-Level-Scheduling"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">中级调度(Intermediate-Level Scheduling)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E3%80%81%E4%B8%AD%E3%80%81%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">高、中、低级调度的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F%E5%92%8C%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%87%86%E5%88%99"><span class="toc-number">3.1.2.</span> <span class="toc-text">选择调度方式和调度算法的若干准则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E7%94%A8%E6%88%B7%E7%9A%84%E5%87%86%E5%88%99"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">面向用户的准则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%87%86%E5%88%99"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">面向系统的准则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-FCFS-%E5%92%8C%E7%9F%AD%E4%BD%9C%E4%B8%9A%EF%BC%88%E8%BF%9B%E7%A8%8B%EF%BC%89%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-SJF"><span class="toc-number">3.2.1.</span> <span class="toc-text">先来先服务(FCFS)和短作业（进程）优先调度算法(SJF)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">先来先服务调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FCFS%E5%92%8CSJF%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">FCFS和SJF性能比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%EF%BC%88%E8%BF%9B%E7%A8%8B%EF%BC%89%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">短作业（进程）优先调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E4%BC%98%E5%85%88%E6%9D%83%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">高优先权优先调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E6%9D%83%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">优先权调度算法的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E6%9D%83%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">优先权的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">高响应比优先调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%89%87%E7%9A%84%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">基于时间片的轮转调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%81%8F%E8%BD%AE%E8%BD%AC%E6%B3%95"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">时间偏轮转法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">多级反馈队列调度算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">3.3.</span> <span class="toc-text">实时调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.3.1.</span> <span class="toc-text">实现实时调度的基本条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E5%BF%85%E8%A6%81%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">提供必要的信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B%E5%BC%BA"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">系统处理能力强</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">采用抢占式调度机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.1.4.</span> <span class="toc-text">具有快速切换机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.3.2.</span> <span class="toc-text">实时调度算法的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">非抢占式调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">抢占式调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.3.</span> <span class="toc-text">常用的实时调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E6%97%A9%E6%88%AA%E8%87%B3%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95-EDF-Eariest-Deadline-First"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">最早截至时间优先算法(EDF, Eariest Deadline First)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%8E%E6%9D%BE%E5%BC%9B%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95-LLf-Least-Laxity-First"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">最低松弛度优先算法(LLf, Least Laxity First)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">3.4.</span> <span class="toc-text">多处理机系统中的调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">多处理器系统的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A7%E5%AF%86%E8%80%A6%E5%90%88%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F-TCMPS-Tightly-Coupted-Multiprocessor-System"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">紧密耦合多处理器系统(TCMPS, Tightly Coupted Multiprocessor System)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F-SMPS-Symmetric-MultiProcessor-System"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">对称多处理器系统(SMPS, Symmetric MultiProcessor System)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F-ASMP-Asymmetric-Multiprocessing-System"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">非对称多处理器系统(ASMP, Asymmetric Multiprocessing System)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">进程分配方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">对称多处理器系统中的进程分配方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">非对称多处理器系统中的进程分配方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%EF%BC%88%E7%BA%BF%E7%A8%8B%EF%BC%89%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.3.</span> <span class="toc-text">进程（线程）调度方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F-Self-Scheduling"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">自调度方式(Self-Scheduling)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.</span> <span class="toc-text">产生死锁的原因和必要条件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.5.1.</span> <span class="toc-text">产生死锁的原因</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%9E%E4%BA%89%E8%B5%84%E6%BA%90%E5%BC%95%E8%B5%B7%E6%AD%BB%E9%94%81"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">竞争资源引起死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A8%E8%BF%9B%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%BD%93%E5%BC%95%E8%B5%B7%E6%AD%BB%E9%94%81"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">进程推进顺序不当引起死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.2.</span> <span class="toc-text">产生死锁的必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.3.</span> <span class="toc-text">处理死锁的基本方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.</span> <span class="toc-text">预防死锁的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">3.6.1.</span> <span class="toc-text">预防死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="toc-number">3.6.2.</span> <span class="toc-text">系统安全状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">银行家算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4"><span class="toc-number">3.7.</span> <span class="toc-text">死锁的检测与解除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">3.7.1.</span> <span class="toc-text">死锁的检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="toc-number">3.7.2.</span> <span class="toc-text">死锁的解除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E2%80%9C%E5%AF%B9%E8%B0%81%E5%8A%A8%E6%89%8B%E2%80%9D"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">如何决定“对谁动手”</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">第四章 存储器管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">4.1.</span> <span class="toc-text">程序的装入和链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">连续分配方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">4.2.1.</span> <span class="toc-text">单一连续分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">4.2.2.</span> <span class="toc-text">固定分区分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%92%E5%88%86%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">划分分区的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">4.2.3.</span> <span class="toc-text">动态分区分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">分区分配算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">4.2.4.</span> <span class="toc-text">可重定位分区分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">基本分页存储管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">基本分段存储管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.5.</span> <span class="toc-text">虚拟存储器的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">请求分页存储管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">4.7.</span> <span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88OPT%EF%BC%89"><span class="toc-number">4.7.1.</span> <span class="toc-text">最佳置换算法（OPT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88FIFO%EF%BC%89"><span class="toc-number">4.7.2.</span> <span class="toc-text">先进先出置换算法（FIFO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88LRU%EF%BC%8CLeast-Recently-Used%EF%BC%89"><span class="toc-number">4.7.3.</span> <span class="toc-text">最近最久未使用置换算法（LRU，Least Recently Used）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88CLOCK-NRU%EF%BC%89"><span class="toc-number">4.7.4.</span> <span class="toc-text">时钟置换算法（CLOCK &#x2F; NRU）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E5%9E%8B%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">4.7.5.</span> <span class="toc-text">改进型的时钟置换算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.8.</span> <span class="toc-text">请求分段存储管理方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">第五章 设备管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.1.</span> <span class="toc-text">I&#x2F;O系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E8%AE%BE%E5%A4%87"><span class="toc-number">5.1.1.</span> <span class="toc-text">I&#x2F;O设备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O%E8%AE%BE%E5%A4%87%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">I&#x2F;O设备的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.1.1.1.</span> <span class="toc-text">按传输速率分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2%E7%9A%84%E5%8D%95%E4%BD%8D%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.1.1.2.</span> <span class="toc-text">按信息交换的单位分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E8%AE%BE%E5%A4%87%E7%9A%84%E5%85%B1%E4%BA%AB%E5%B1%9E%E6%80%A7%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.1.1.3.</span> <span class="toc-text">按设备的共享属性分类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">设备与控制器之间的接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">设备控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E9%80%9A%E9%81%93"><span class="toc-number">5.1.3.</span> <span class="toc-text">I&#x2F;O通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">通道类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">I&#x2F;O控制方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86-1"><span class="toc-number">5.3.</span> <span class="toc-text">缓冲管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D-1"><span class="toc-number">5.4.</span> <span class="toc-text">设备分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%A4%84%E7%90%86-1"><span class="toc-number">5.5.</span> <span class="toc-text">设备处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">5.6.</span> <span class="toc-text">磁盘存储器管理</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Lucy</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="Chat"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer src="/js/cursor.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js" type="application/javascript"></script><script src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script async data-pjax src="/js/newYear.js"></script><canvas id="universe"></canvas><script src="/js/universe.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>