{"title":"考研875数据结构","slug":"考研875数据结构","date":"2024-10-12T13:34:19.000Z","updated":"2024-11-13T14:36:11.816Z","comments":true,"path":"api/articles/考研875数据结构.json","excerpt":null,"covers":["/articles/9eb01842/GL_1.png","/articles/9eb01842/GL_11.png","/articles/9eb01842/GL_2.png","/articles/9eb01842/GL_3.png","/articles/9eb01842/满二叉树.jpg","/articles/9eb01842/完全二叉树.jpg","/articles/9eb01842/先序遍历非递归法一.jpeg","/articles/9eb01842/BST_del.jpg","/articles/9eb01842/前缀编码.jpg","/articles/9eb01842/哈夫曼编码.jpg","/articles/9eb01842/堆插入.jpg","/articles/9eb01842/双亲表示法.jpg","/articles/9eb01842/孩子表示法.jpg","/articles/9eb01842/孩子兄弟表示法.jpg","/articles/9eb01842/树变二叉树.jpg","/articles/9eb01842/二叉树变森林.jpg","/articles/9eb01842/并查集.jpg","/articles/9eb01842/十字链表.jpg","/articles/9eb01842/邻接多重表.jpg","/articles/9eb01842/四存区别.jpg","/articles/9eb01842/Floyd判负环.png","/articles/9eb01842/最短路径总结表格.jpg","/articles/9eb01842/不同存储结构时间复杂度总结.jpg","/articles/9eb01842/散列查找分析.jpg","/articles/9eb01842/拉链法.jpg","/articles/9eb01842/排序知识框架.jpg","/articles/9eb01842/希尔排序.jpg","/articles/9eb01842/堆排序.jpg","/articles/9eb01842/堆排序_2.jpg"],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"一、数据结构基本概念\"><a href=\"#一、数据结构基本概念\" class=\"headerlink\" title=\"一、数据结构基本概念\"></a>一、数据结构基本概念</h2><blockquote>\n<p>建议另外过一遍 <a href=\"./fc6ebebe.html\">严蔚敏课笔记</a><br>注意：代码缩进本该为4个空格，这里为了美观和方便，缩进是2个空格。</p>\n</blockquote>\n<h4 id=\"数据\"><a href=\"#数据\" class=\"headerlink\" title=\"数据\"></a>数据</h4><ul>\n<li>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。</li>\n</ul>\n<h4 id=\"数据元素\"><a href=\"#数据元素\" class=\"headerlink\" title=\"数据元素\"></a>数据元素</h4><ul>\n<li>数据元素是数据的<strong>基本单位</strong>，通常作为一个整体进行考虑和处理。</li>\n</ul>\n<h4 id=\"数据项\"><a href=\"#数据项\" class=\"headerlink\" title=\"数据项\"></a>数据项</h4><ul>\n<li>一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的<strong>最小单位</strong>。</li>\n<li>例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。</li>\n</ul>\n<h4 id=\"数据对象\"><a href=\"#数据对象\" class=\"headerlink\" title=\"数据对象\"></a>数据对象</h4><ul>\n<li>数据对象是具有相同性质的数据元素的集合，是数据的一个子集。</li>\n<li>例如，整数数据对象是集合 N={0,±1,±2,…}。</li>\n</ul>\n<h4 id=\"数据、数据元素、数据项之间的关系\"><a href=\"#数据、数据元素、数据项之间的关系\" class=\"headerlink\" title=\"数据、数据元素、数据项之间的关系\"></a>数据、数据元素、数据项之间的关系</h4><ul>\n<li>数据-&gt;数据对象-&gt;数据元素-&gt;数据项</li>\n<li>两张表-&gt;数据；其中一张表-&gt;数据对象；表中每一行（记录）-&gt;数据元素；每条记录的每个属性-&gt;数据项</li>\n</ul>\n<h4 id=\"数据结构的定义\"><a href=\"#数据结构的定义\" class=\"headerlink\" title=\"数据结构的定义\"></a>数据结构的定义</h4><ul>\n<li>数据结构是相互之间存在一种或多种特定<strong>关系</strong>的<strong>数据元素</strong>的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构（Structure）。</li>\n</ul>\n<h4 id=\"数据结构的三要素\"><a href=\"#数据结构的三要素\" class=\"headerlink\" title=\"数据结构的三要素\"></a>数据结构的三要素</h4><ul>\n<li>数据结构包括三方面的内容：<strong>逻辑结构</strong>、<strong>存储结构</strong>和<strong>数据的运算</strong>。</li>\n<li>数据的<strong>逻辑结构</strong>和<strong>存储结构</strong>是密不可分的两个方面，一个<strong>算法的设计</strong>取决于所选定的<strong>逻辑结构</strong>，而<strong>算法的实现</strong>依赖于所采用的<strong>存储结构</strong>。</li>\n</ul>\n<h4 id=\"数据的逻辑结构\"><a href=\"#数据的逻辑结构\" class=\"headerlink\" title=\"数据的逻辑结构\"></a>数据的逻辑结构</h4><ul>\n<li>逻辑结构是指数据元素之间的<strong>逻辑关系</strong>，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。</li>\n<li>数据的逻辑结构分为<strong>线性结构</strong>和<strong>非线性结构</strong>，<strong>线性表</strong>是典型的线性结构，<strong>集合、树和图</strong>是典型的非线性结构。<br>1) <strong>集合</strong>。结构中的元素之间除“同属一个集合”外，别无其它关系。<br>2) <strong>线性结构</strong>。结构中的数据元素之间只存在一对一的关系。<br>3) <strong>树形结构</strong>。结构中的数据元素之间存在一对多的关系。<br>4) <strong>图状结构</strong>或<strong>网状结构</strong>。结构中的数据元素之间存在多对多的关系。</li>\n</ul>\n<h4 id=\"数据的物理结构\"><a href=\"#数据的物理结构\" class=\"headerlink\" title=\"数据的物理结构\"></a>数据的物理结构</h4><ul>\n<li><code>存储结构</code>是指数据结构在计算机中的表示（又称<strong>映像</strong>），也称<code>物理结构</code>。它包括<strong>数据元素</strong>的表示和<strong>关系</strong>的表示。数据的存储结构是计算机语言实现的逻辑结构，它依赖于计算机语言。数据的存储结构主要有<strong>顺序存储、链式存储、索引存储和散列存储</strong>。<br>1) <strong>顺序存储</strong>。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。<br>其<strong>优点</strong>是可以实现<u>随机存取</u>，每个元素占用最少的存储空间；<strong>缺点</strong>是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。<br>2) <strong>链式存储</strong>。不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。<br>其<strong>优点</strong>是<u>不会出现碎片现象</u>，能充分利用所有存储单元；<strong>缺点</strong>是<u>每个元素因存储指针而占用额外的存储空间</u>，且只能实现顺序存取。<br>3) <strong>索引存储</strong>。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为<strong>索引项</strong>，索引项的一般形式是（关键字，地址）。<br>其<strong>优点</strong>是<u>检索速度快</u>；<strong>缺点</strong>是<u>附加的索引表额外占用存储空间</u>。另外，增加和删除数据时也要修改索引表，因而<u>会花费较多的时间</u>。<br>4) <strong>散列存储</strong>。根据元素的关键字直接计算出该元素的存储地址，又称<strong>哈希（Hash）存储</strong>。<br>其<strong>优点</strong>时<u>检索、增加和删除结点的操作都很快</u>；<strong>缺点</strong>是若散列函数不好，则可能出现<u>元素存储单元的冲突</u>，而解决冲突<u>会增加时间和空间开销</u>。</li>\n</ul>\n<h4 id=\"数据的运算的定义\"><a href=\"#数据的运算的定义\" class=\"headerlink\" title=\"数据的运算的定义\"></a>数据的运算的定义</h4><ul>\n<li>（王道）施加在数据上的运算包括运算的<strong>定义</strong>和<strong>实现</strong>。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</li>\n<li>（博客）数据的运算是指对数据实施的操作，数据的运算最终需要在对应的存储结构上用算法实现，所以数据运算分为运算的定义和运算的实现两个层面。<br>运算的定义是对运算功能的描述，是抽象的，是基于逻辑的。<br>运算的实现是程序员完成运算的实现算法，是具体的，是基于存储结构的。</li>\n</ul>\n<h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><ul>\n<li>数据类型是一个值的集合和定义在集合上的一组操作的总称。<br>1) <strong>原子类型</strong>。其值不可再分的数据类型。<br>2) <strong>结构类型</strong>。其值可以再分解为若干成分（分量）的数据类型。<br>3) <code>抽象数据类型</code>。一个数学模型及定义在该数学模型上的一组操作。它通常是对数据的某种抽象，定义了数据的取值范围及其结构形式，以及对数据操作的集合。</li>\n<li><code>抽象数据类型</code>的三个组成部分：数据对象、数据关系和基本操作。</li>\n<li>（蓝皮书，定义）<code>抽象数据类型</code>是一种构造数据类型，它具有三大特征，<strong>信息隐蔽、数据封装、使用与实现相分离</strong>。</li>\n</ul>\n<h4 id=\"数据类型、抽象数据类型和数据结构之间的关系\"><a href=\"#数据类型、抽象数据类型和数据结构之间的关系\" class=\"headerlink\" title=\"数据类型、抽象数据类型和数据结构之间的关系\"></a>数据类型、抽象数据类型和数据结构之间的关系</h4><ul>\n<li><strong>数据类型</strong>是一个值的集合和定义在此集合上的一组操作的总称。（值+操作）</li>\n<li><strong>抽象数据类型（ADT）</strong>是一个数学模型及定义在该数学模型上的一组操作。（数学模型+操作）它通常是对数据的某种抽象，定义了数据的取值范围及其结构形式，以及对数据操作的集合。（数据对象+数据关系+基本操作）</li>\n<li><strong>数据结构</strong>是相互之间存在一种或多种特定<strong>关系</strong>的<strong>数据元素</strong>的集合。（数据元素+数据关系）</li>\n</ul>\n<h2 id=\"二、算法和算法分析\"><a href=\"#二、算法和算法分析\" class=\"headerlink\" title=\"二、算法和算法分析\"></a>二、算法和算法分析</h2><h3 id=\"算法的定义\"><a href=\"#算法的定义\" class=\"headerlink\" title=\"算法的定义\"></a>算法的定义</h3><ul>\n<li>算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每一条指令表示一个或多个操作。</li>\n<li>算法和程序的区别：<ol>\n<li>算法是描述一个问题求解的步骤序列，而程序是算法在特定计算机上的实现。</li>\n<li>算法不依赖于计算机，而程序依赖于特定的计算机和特定的编程语言。</li>\n<li>算法必须满足五个特性，即有穷性、确定性、可行性、有输入、有输出，而程序可能不满足有穷性。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"算法的特性（五个）\"><a href=\"#算法的特性（五个）\" class=\"headerlink\" title=\"算法的特性（五个）\"></a>算法的特性（五个）</h3><ol>\n<li><strong>有穷性</strong>。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</li>\n<li><strong>确定性</strong>。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</li>\n<li><strong>可行性</strong>。算法中描述的操作都可以通过 已经实现的基本运算 执行有限次来实现。</li>\n<li><strong>输入</strong>。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li>\n<li><strong>输出</strong>。一个算法有一个或多个输出，这些输出是与输入有着某些特定关系的量。</li>\n</ol>\n<h3 id=\"算法设计的要求\"><a href=\"#算法设计的要求\" class=\"headerlink\" title=\"算法设计的要求\"></a>算法设计的要求</h3><ol>\n<li><strong>正确性</strong>。算法应能够正确地解决求解问题。<ul>\n<li>首先，算法应当满足以特定的“规格说明”方式给出的需求。</li>\n<li>其次，对算法是否“正确”的理解可以有以下四个层次：<br>a. 程序中不含语法错误；<br>b. 程序对于几组输入数据能够得出满足规格说明要求的结果；<br>c. 程序对于精心选择的典型、苛刻而带有刁难性的几组输入数据能够得出满足规格说明要求的结果；<br>d. 程序对于一切合法的输入数据都能产生满足规格说明要求的结果。<br>（通常以第c层意义的正确性作为衡量一个程序是否合格的标准。）</li>\n</ul>\n</li>\n<li><strong>可读性</strong>。算法应具有良好的可读性，以帮助人们理解。<ul>\n<li>算法主要是为了人的阅读与交流，其次才是机器执行。可读性好有助于人对算法的理解；</li>\n<li>另一方面，晦涩难懂的程序易于隐藏较多错误，难以调试和修改。</li>\n</ul>\n</li>\n<li><strong>健壮性</strong>。算法能对输入的非法数据做出反应或处理，而不会产生莫名其妙的输出。<ul>\n<li>当输入数据非法时，算法也能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</li>\n<li>并且，处理出错的方法应是返回一个表示错误或错误性质的值，而不是打印错误信息或异常，并中止程序的执行，以便在更高的抽象层次上进行处理。</li>\n</ul>\n</li>\n<li><strong>效率与低存储量需求</strong>。效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。<ul>\n<li>（因为：求100个人的平均分与求1000个人的平均分所花的执行时间或运行空间显然有一定的差别。）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"算法的时间、空间复杂度的定义及计算\"><a href=\"#算法的时间、空间复杂度的定义及计算\" class=\"headerlink\" title=\"算法的时间、空间复杂度的定义及计算\"></a>算法的时间、空间复杂度的定义及计算</h3><ul>\n<li>（归纳下应该这么说）算法的<strong>时间复杂度</strong>是一个关于问题规模n的函数，表示算法中基本运算的执行次数的数量级，定性地描述该算法的运行时间。</li>\n<li>（归纳下应该这么说）算法的<strong>空间复杂度</strong>是问题规模n的函数，定性地描述该算法或程序运行所需要的存储空间大小。</li>\n<li>（<a href=\"https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">wiki</a>）算法的<strong>时间复杂度</strong>（time complexity）是一个函数，它定性描述该算法的运行时间。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，也就是考察输入值大小趋近无穷时的情况。例如，如果一个算法对于任何大小为 n （必须比 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">n_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 大）的输入，它至多需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn><msup><mi>n</mi><mn>3</mn></msup><mo>+</mo><mn>3</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">5n^3 + 3n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\">5</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mord mathnormal\">n</span></span></span></span> 的时间运行完毕，那么它的渐近时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>（<a href=\"https://zh.wikipedia.org/wiki/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">wiki</a>）在计算机科学中，一个算法或程序的<strong>空间复杂度</strong>定性地描述该算法或程序运行所需要的存储空间大小。空间复杂度是相应计算问题的输入值的长度的函数，它表示一个算法完全执行所需要的存储空间大小。</li>\n<li>就像时间复杂度的计算不考虑算法所使用的空间大小一样，空间复杂度也不考虑算法运行需要的时间长短。</li>\n</ul>\n<h3 id=\"衡量算法在资源上的两个方面\"><a href=\"#衡量算法在资源上的两个方面\" class=\"headerlink\" title=\"衡量算法在资源上的两个方面\"></a>衡量算法在资源上的两个方面</h3><ul>\n<li>算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。因此衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，即<strong>时间复杂度和空间复杂度</strong>。时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的<strong>额外内存空间</strong>。根据算法编写出的程序，运行时间更短，运行期间占用的内存更少，该算法的运行效率就更高，算法也就更好。</li>\n<li>度量一个程序的执行时间通常有两种方法：</li>\n</ul>\n<ol>\n<li><p>事后统计的方法 （让算法变成一个程序，在机器上执行并计时）<br>缺点：<br>(1) 必须执行程序<br>(2) 其他因素掩盖算法本质</p>\n</li>\n<li><p>事前分析估算的方法（通常使用的）<br>和算法执行时间相关的因素：<br>(1) 算法选用的策略<br>(2) 问题的规模<br>(3) 编写程序的语言<br>(4) 编译程序产生的机器代码的质量<br>(5) 机器执行指令的速度<br>（后三条和计算机的软件和硬件有关，和设计算法无关，所以设计算法时只考虑前两条）</p>\n</li>\n</ol>\n<ul>\n<li>算法的存储量包括：<br>(1) 输入数据所占空间<br>(2) 程序本身所占空间<br>(3) 辅助变量所占空间<ul>\n<li>若<u><strong>输入数据</strong>所占空间只取决于问题本身，<strong>和算法无关</strong></u>，则只需要分析除输入和程序之外的<strong>辅助变量所占额外空间</strong>。</li>\n<li>若<u><strong>所需额外空间</strong>相对于<strong>输入数据量</strong>来说是<strong>常数</strong></u>，则称此算法为<strong>原地工作</strong>。</li>\n<li>若<u><strong>所需存储量</strong>依赖于<strong>特定的输入</strong></u>，则通常按<strong>最坏情况</strong>考虑。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"算法的渐进性分析方法，会用该方法对算法进行评估\"><a href=\"#算法的渐进性分析方法，会用该方法对算法进行评估\" class=\"headerlink\" title=\"算法的渐进性分析方法，会用该方法对算法进行评估\"></a>算法的渐进性分析方法，会用该方法对算法进行评估</h3><h4 id=\"渐进分析\"><a href=\"#渐进分析\" class=\"headerlink\" title=\"渐进分析\"></a>渐进分析</h4><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%B8%90%E8%BF%91%E5%88%86%E6%9E%90\">渐进分析（asymptotic analysis、asymptotics）</a>，在数学分析中是一种描述函数在极限附近的行为的方法。有多个科学领域应用此方法。例子如下：<ul>\n<li>在计算机科学中，<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90\">算法分析</a>考虑给定算法在输入非常大的数据集时候的性能。</li>\n<li>当实体系统的规模变得非常大的时候，分析它的行为。</li>\n</ul>\n</li>\n<li>最简单的例子如下：考虑一个函数f(n)，我们需要了解当n变得非常大的时候f(n)的性质。<br>令<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">f(n)=n^2+3n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mord mathnormal\">n</span></span></span></span>，在n特别大的时候，第二项3n比起第一项<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>要小很多。<br>于是对于这个函数，有如下断言：“f(n)在n→∞的情况下与<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>渐近等价”，记作<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>∼</mo><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">f(n)∼n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>。<h4 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4></li>\n<li>在计算机科学中，<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90\">算法分析（Analysis of algorithm）</a>是分析执行一个给定算法需要消耗的计算资源数量（例如计算时间，存储器使用等）的过程。算法的效率或复杂度在理论上表示为一个函数。其定义域是输入数据的长度（通常考虑任意大的输入，没有上界），值域通常是执行步骤数量（时间复杂度）或者存储器位置数量（空间复杂度）。算法分析是计算复杂度理论的重要组成部分。</li>\n<li>理论分析常常利用<a href=\"https://zh.wikipedia.org/wiki/%E6%B8%90%E8%BF%91%E5%88%86%E6%9E%90\">渐近分析</a>估计一个算法的复杂度，并使用<a href=\"https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7\">大O符号</a>、<a href=\"https://zh.wikipedia.org/wiki/%E5%A4%A7%CE%A9%E7%AC%A6%E5%8F%B7\">大Ω符号</a>和<a href=\"https://zh.wikipedia.org/wiki/%E5%A4%A7%CE%98%E7%AC%A6%E5%8F%B7\">大Θ符号</a>作为标记。举例，二分查找所需的执行步骤数量与查找列表的长度之对数成正比，记为O(log n)，简称为“对数时间”。通常使用渐近分析的原因是，同一算法的不同具体实现的效率可能有差别。但是，对于任何给定的算法，所有符合其设计者意图的实现，它们之间的性能差异应当仅仅是一个系数。</li>\n<li>精确分析算法的效率有时也是可行的，但这样的分析通常需要一些与具体实现相关的假设，称为计算模型。计算模型可以用抽象机器来定义，比如图灵机。或者可以假设某些基本操作在单位时间内可完成。</li>\n<li>假设二分查找的目标列表总共有 n 个元素。如果我们假设单次查找可以在一个时间单位内完成，那么至多只需要 logn + 1 单位的时间就可以得到结果。这样的分析在有些场合非常重要。</li>\n<li>算法分析在实际工作中是非常重要的，因为使用低效率的算法会显著降低系统性能。在对运行时间要求极高的场合，耗时太长的算法得到的结果可能是过期或者无用的。低效率算法也会大量消耗计算资源。<h4 id=\"渐进最优\"><a href=\"#渐进最优\" class=\"headerlink\" title=\"渐进最优\"></a>渐进最优</h4></li>\n<li>在计算机科学中，<a href=\"https://zh.wikipedia.org/wiki/%E6%B8%90%E8%BF%9B%E6%9C%80%E4%BC%98\">渐进最优</a>一词用以评价算法的效率。如果已经证实一个问题需要使用Ω(f(n))的资源来解决，而某个算法用O(f(n))的资源来解决这个问题，则该算法就是渐进最优的。</li>\n<li>渐进最优的例子包括数据结构动态数组，能够在常数时间内索引，但性能在多数机器上不如普通数组的索引。另外，在所有基于比较的排序算法中，归并排序和堆排序是渐进最优的。</li>\n</ul>\n<h3 id=\"三个标记法\"><a href=\"#三个标记法\" class=\"headerlink\" title=\"三个标记法\"></a>三个标记法</h3><ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi></mrow><annotation encoding=\"application/x-tex\">O</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span></span></span></span>标记法<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7\">大O符号</a>（上界）表示函数在增长到一定程度时总小于一个特定函数的常数倍。</li>\n</ul>\n</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Ω</mi></mrow><annotation encoding=\"application/x-tex\">\\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Ω</span></span></span></span>标记法<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%A4%A7%CE%A9%E7%AC%A6%E5%8F%B7\">大Ω符号</a>表示函数在增长到一定程度时总大于一个特定函数的常数倍。</li>\n</ul>\n</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Θ</mi></mrow><annotation encoding=\"application/x-tex\">\\Theta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Θ</span></span></span></span>标记法<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%A4%A7%CE%98%E7%AC%A6%E5%8F%B7\">大Θ符号</a>表示函数在某个区间上的渐近关系。如果两个函数在某个区间上的上界和下界都分别为另一个函数，那么这两个函数在该区间上是渐近相等的，可以用大Θ符号表示为：f(n) = Θ(g(n))</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"时空权衡原则\"><a href=\"#时空权衡原则\" class=\"headerlink\" title=\"时空权衡原则\"></a>时空权衡原则</h3><ul>\n<li>计算机科学中的 <a href=\"https://zh.wikipedia.org/wiki/%E6%97%B6%E7%A9%BA%E6%9D%83%E8%A1%A1\">时空权衡</a>（英语：space–time trade off，又叫<strong>空间换时间</strong>）是指一个算法或程序用增加空间使用量来换取时间减少的情况。这里，空间指的是执行一个给定任务所消耗的数据存储（内存、硬盘等），而时间指的是执行一个给定任务所消耗的时间（计算时间或反应时间）。</li>\n<li>一个给定的时空权衡的效用受到相关的固定和可变成本（如CPU速度、存储空间）的影响，并受到<u>收益递减的</u>影响。</li>\n</ul>\n<h2 id=\"三、线性表\"><a href=\"#三、线性表\" class=\"headerlink\" title=\"三、线性表\"></a>三、线性表</h2><h3 id=\"线性表的定义\"><a href=\"#线性表的定义\" class=\"headerlink\" title=\"线性表的定义\"></a>线性表的定义</h3><ul>\n<li>线性表是具有相同数据类型的n个数据元素的有限序列，n为表长，当n=0时，该线性表是空表。</li>\n</ul>\n<h3 id=\"线性表的逻辑结构\"><a href=\"#线性表的逻辑结构\" class=\"headerlink\" title=\"线性表的逻辑结构\"></a>线性表的逻辑结构</h3><ul>\n<li>线性表是一种逻辑结构，表示元素之间一对一的相邻关系；顺序表和链表是存储结构。</li>\n<li>线性表的<strong>逻辑特性</strong>：若用L命名线性表，则其一般表示为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L=(a_1,a_2,\\cdots,a_i,a_{i+1},\\cdots,a_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。式中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">a_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>是唯一的“第一个”数据元素，又称<strong>表头元素</strong>；<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>是唯一的“最后一个”数据元素，又称<strong>表尾元素</strong>。除第一个元素外，每个元素<strong>有且仅有</strong>一个直接前驱。除最后一个元素外，每个元素<strong>有且仅有</strong>一个直接后继（“直接前驱”和“前驱”、“直接后继”和“后继”通常被视为同义词）。这种线性有序的逻辑结构正是线性表名字的又来。</li>\n<li>线性表的<strong>特点</strong>：<ol>\n<li>表中元素的个数有限。</li>\n<li>表中元素具有逻辑上的顺序性，表中元素有其先后次序。</li>\n<li>表中元素都是数据元素，每个元素都是单个元素。</li>\n<li>表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。</li>\n<li>表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"线性表的基本操作\"><a href=\"#线性表的基本操作\" class=\"headerlink\" title=\"线性表的基本操作\"></a>线性表的基本操作</h3><ol>\n<li>InitList(&amp;L): 初始化表。构造一个空的线性表。</li>\n<li>Length(L): 求表长。返回线性表L的长度，即L中数据元素的个数。</li>\n<li>LocateElem(L,e): 按值查找操作。在表L中查找具有给定关键字值的元素。</li>\n<li>GetElem(L,i): 按位查找操作。获取表L中第i个位置的元素的值。</li>\n<li>ListInsert(&amp;L,i,e): 插入操作。在表L中的第i个位置上插入指定的元素e。</li>\n<li>ListDelete(&amp;L,i,&amp;e): 删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</li>\n<li>PrintList(L): 输出操作。按前后顺序输出线性表L的所有元素值。</li>\n<li>Empty(L): 判空操作。若L为空表，则返回true，否则返回false。</li>\n<li>DestroyList(&amp;L): 销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</li>\n</ol>\n<h3 id=\"顺序表的定义\"><a href=\"#顺序表的定义\" class=\"headerlink\" title=\"顺序表的定义\"></a>顺序表的定义</h3><ul>\n<li>线性表的顺序存储又称<strong>顺序表</strong>。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。</li>\n<li>（称i为元素<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>在顺序表中的<strong>位序</strong>。）</li>\n</ul>\n<h3 id=\"顺序表的特点\"><a href=\"#顺序表的特点\" class=\"headerlink\" title=\"顺序表的特点\"></a>顺序表的特点</h3><ul>\n<li>表中元素的<strong>逻辑顺序</strong>与其存储的<strong>物理顺序</strong><u>相同</u>，因此可以随机存取表中的任一元素，它的存储位置可用一个简单、直观的公式表示。</li>\n</ul>\n<h3 id=\"用顺序存储结构对线性表基本操作的实现\"><a href=\"#用顺序存储结构对线性表基本操作的实现\" class=\"headerlink\" title=\"用顺序存储结构对线性表基本操作的实现\"></a>用顺序存储结构对线性表基本操作的实现</h3><div class=\"tip warning faa-parent animated-hover\"><p class=\"faa-horizontal\"> 注意不可以用int替代数据元素的数据类型，因为数据类型未给定，得用ElemType代替。</p></div>\n<ul>\n<li><p>线性表的动态分配顺序存储结构</p>\n<blockquote>\n<p>数组指针elem指示线性表的基地址，listsize指示顺序表当前分配的存储空间大小，一旦因插入元素而导致空间不足时，可进行再分配，即为顺序表增加一个大小为存储LISTINCREMENT个数据元素的空间。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LIST_INIT_SIZE 100 <span class=\"comment\">//线性表存储空间的初始分配量</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LISTINCREMENT 10 <span class=\"comment\">//线性表存储空间的分配增量</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  ElemType *elem; <span class=\"comment\">//存储空间基址</span></span><br><span class=\"line\">  <span class=\"type\">int</span> length; <span class=\"comment\">//当前长度</span></span><br><span class=\"line\">  <span class=\"type\">int</span> listsize; <span class=\"comment\">//当前分配的存储容量（以sizeof(Elemtype)为单位）</span></span><br><span class=\"line\">&#125;Sqlist;</span><br></pre></td></tr></table></figure></li>\n<li>顺序表的初始化<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">InitList_Sq</span><span class=\"params\">(SqList &amp;L)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//构造一个空的线性表L</span></span><br><span class=\"line\">  L.elem = (ElemType *)<span class=\"built_in\">malloc</span>(LIST_INIT_SIZE * <span class=\"keyword\">sizeof</span>(ElemType));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (! L.elem) <span class=\"built_in\">exit</span>(OVERFLOW); <span class=\"comment\">//存储分配失败</span></span><br><span class=\"line\">  L.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">  L.listsize = LIST_INIT_SIZE; <span class=\"comment\">//初始存储容量</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>插入操作</p>\n<blockquote>\n<p>在第i（1≤i≤n）个元素之前插入一个元素，需将<strong>第n至第i（共n-i+1个）</strong>个元素向后移动一个位置。<br>C语言中数组的下标从“0”开始，因此表中第i个数据元素是L.elem[i-1]。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">ListInsert_Sq</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//在顺序线性表L中第i个位置之前插入新的元素e</span></span><br><span class=\"line\">  <span class=\"comment\">//i的合法值为 1≤i≤ListLength_Sq(L)+1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">1</span> || i &gt; L.length+<span class=\"number\">1</span>) <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//i值不合法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (L.length &gt;= L.listsize) &#123; <span class=\"comment\">//当前存储空间已满，增加分配</span></span><br><span class=\"line\">    newbase = (ElemType *)<span class=\"built_in\">realloc</span>(L.elem, (L.listsize+LISTINCREMENT) * <span class=\"keyword\">sizeof</span>(ElemType));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!newbase) <span class=\"built_in\">exit</span>(OVERFLOW); <span class=\"comment\">//存储分配失败</span></span><br><span class=\"line\">    L.elem = newbase;</span><br><span class=\"line\">    L.listsize += LISTINCREMENT; <span class=\"comment\">//增加存储容量</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  q = &amp;(L.elem[i<span class=\"number\">-1</span>]); <span class=\"comment\">//q为插入位置</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (p = &amp;(L.elem[L.length<span class=\"number\">-1</span>]); p &gt;= q; --p)</span><br><span class=\"line\">    *(p+<span class=\"number\">1</span>) = *p; <span class=\"comment\">//插入位置及之后的元素右移</span></span><br><span class=\"line\">  *q = e; <span class=\"comment\">//插入e</span></span><br><span class=\"line\">  ++ L.length; <span class=\"comment\">//表长增1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>删除操作</p>\n<blockquote>\n<p>删除第i（1≤i≤n）个元素时，需将<strong>从第i+1至n（共n-i）</strong>个元素依次向前移动一个位置。<br>C语言中数组的下标从“0”开始，因此表中第i个数据元素是L.elem[i-1]。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">ListDelete_Sq</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//在顺序线性表L中删除第i个元素，并用e返回其值</span></span><br><span class=\"line\">  <span class=\"comment\">//i的合法值为 1≤i≤ListLength_Sq(L)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">1</span> || i &gt; L.length) <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//i值不合法</span></span><br><span class=\"line\">  p = &amp;(L.elem[i<span class=\"number\">-1</span>]); <span class=\"comment\">//p为被删除元素的位置</span></span><br><span class=\"line\">  e = *p; <span class=\"comment\">//被删除元素的值赋给e</span></span><br><span class=\"line\">  q = L.elem + L.length - <span class=\"number\">1</span>; <span class=\"comment\">//表尾元素的位置（elem表示线性表的基址）</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (++p; p &lt;= q; ++p)</span><br><span class=\"line\">    *(p<span class=\"number\">-1</span>) = *p; <span class=\"comment\">//被删除元素之后的元素左移</span></span><br><span class=\"line\">  --L.length; <span class=\"comment\">//表长减1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>移动元素次数的期望值</p>\n<blockquote>\n<p>当在顺序存储结构的线性表中某个位置上插入或删除一个数据元素时，其时间主要耗费在移动元素上（换句话说，移动元素的操作为预估算法时间复杂度的基本操作），而移动元素的个数取决于插入或删除元素的位置。</p>\n</blockquote>\n<ul>\n<li>假设等概率，<ul>\n<li>插入（在i前插入）：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>E</mi><mrow><mi>i</mi><mi>s</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msubsup><msub><mi>p</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">E_{is} = \\sum\\limits_{i=1}^{n+1}p_i(n-i+1) = \\frac{1}{n+1}\\sum\\limits_{i=1}^{n+1}(n-i+1) = \\frac{n}{2} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">s</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.4788em;vertical-align:-0.9777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5011em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.4788em;vertical-align:-0.9777em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5011em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0404em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6954em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></li>\n<li>删除（第i个）：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>E</mi><mrow><mi>d</mi><mi>l</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>q</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">E_{dl} = \\sum\\limits_{i=1}^{n}q_i(n-i) = \\frac{1}{n}\\sum\\limits_{i=1}^{n}(n-i) = \\frac{n-1}{2} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></li>\n</ul>\n</li>\n<li>若表长为n，则算法 ListInsert_Sq 和 ListDelete_Sq 的时间复杂度为 O(n) 。</li>\n<li>“求表长”（ListLength_Sq）和“取第i个数据元素”（GetElem_Sq）的时间复杂度为 O(1) 。</li>\n<li>LocateElem_Sq 的时间复杂度为 O(L.length) ， union_Sq（A=A∪B） 的时间复杂度为 O ( La.length × Lb.length ) ， MergeList_Sq（C=A∪B） 的时间复杂度为 O ( La.ListLength + Lb.ListLength ) 。</li>\n</ul>\n</li>\n<li><p>按值查找（顺序查找）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">LocateElem_Sq</span><span class=\"params\">(SqList L, ElemType e, Status (*compare)(ElemType, ElemType))</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//在顺序线性表L中查找第1个值与e满足compare()的元素的位序</span></span><br><span class=\"line\">  <span class=\"comment\">//若找到，则返回其在L中的位序，否则返回0</span></span><br><span class=\"line\">  i = <span class=\"number\">1</span>; <span class=\"comment\">//i的初值为第1个元素的位序</span></span><br><span class=\"line\">  p = L.elem; <span class=\"comment\">//p的初值为第1个元素的存储位置</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(i &lt;= L.length &amp;&amp; !(*compare)(*p ++, e))</span><br><span class=\"line\">    ++i;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i &lt;= L.length)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>线性表的合并（A=A∪B）</p>\n<blockquote>\n<p>将存在于线性表LB中，而<strong>不存在于线性表LA中</strong>的数据元素插入到线性表LA中去。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">union</span><span class=\"params\">(List &amp;La, List &amp;Lb)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//将所有在线性表Lb中但不在La中的数据元素插入到La中</span></span><br><span class=\"line\">  La.len = ListLength(La); Lb.len = ListLength(Lb); <span class=\"comment\">//求线性表的长度</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= Lb.len; i++) &#123;</span><br><span class=\"line\">    GetElem(Lb, i, e); <span class=\"comment\">//取Lb中第i个数据元素赋给e</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!LocateElem(La, e, equal)) ListInsert(La, ++ La_len, e); <span class=\"comment\">//La中不存在和e相同的数据元素，则插入之</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>顺序表的合并（C=A∪B）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MergeList_Sq</span><span class=\"params\">(SqList La, SqList Lb, SqList &amp;Lc)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//已知顺序线性表La和Lb的元素按值非递减排列</span></span><br><span class=\"line\">  <span class=\"comment\">//归并La和Lb得到新的顺序线性表Lc，Lc的元素也按值非递减排列</span></span><br><span class=\"line\">  pa = La.elem; pb = Lb.elem;</span><br><span class=\"line\">  Lc.listsize = Lc.length = La.length + Lb.length;</span><br><span class=\"line\">  pc = Lc.elem = (ElemType *)<span class=\"built_in\">malloc</span>(Lc.listsize*<span class=\"keyword\">sizeof</span>(ElemType));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!Lc.elem) <span class=\"built_in\">exit</span>(OVERFLOW); <span class=\"comment\">//存储分配失败</span></span><br><span class=\"line\">  pa_last = La.elem + La.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  pb_last = Lb.elem + Lb.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) &#123; <span class=\"comment\">//归并</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*pa &lt;= *pb) *pc ++ = *pa ++;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> *pc ++ = *pb ++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (pa &lt;= pa_last) *pc ++ = *pa ++; <span class=\"comment\">//插入La的剩余元素</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (pb &lt;= pb_last) *pc ++ = *pb ++; <span class=\"comment\">//插入Lb的剩余元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"链式表的定义\"><a href=\"#链式表的定义\" class=\"headerlink\" title=\"链式表的定义\"></a>链式表的定义</h3><ul>\n<li>链式表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</li>\n</ul>\n<h3 id=\"链式表的特点\"><a href=\"#链式表的特点\" class=\"headerlink\" title=\"链式表的特点\"></a>链式表的特点</h3><ul>\n<li>用一组任意（可连续，也可不连续）的存储单元存储数据元素，对于每个数据元素都需要一个<u>存储其本身信息</u>的<strong>数据域</strong>和<u>存储直接后继存储位置</u>的<strong>指针域</strong>。</li>\n</ul>\n<h3 id=\"用链式存储结构对线性表基本操作的实现（见下）\"><a href=\"#用链式存储结构对线性表基本操作的实现（见下）\" class=\"headerlink\" title=\"用链式存储结构对线性表基本操作的实现（见下）\"></a>用链式存储结构对线性表基本操作的实现（见下）</h3><h3 id=\"链式存储结构的实现技术（比如）\"><a href=\"#链式存储结构的实现技术（比如）\" class=\"headerlink\" title=\"链式存储结构的实现技术（比如）\"></a>链式存储结构的实现技术（比如）</h3><h4 id=\"单向链表\"><a href=\"#单向链表\" class=\"headerlink\" title=\"单向链表\"></a>单向链表</h4><ul>\n<li>线性表的链式存储又称单链表。它是通过一组任意的存储单元来存储线性表中的数据元素。</li>\n<li>为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息之外，还需要存放一个指向其后继的指针。</li>\n<li>结点类型描述：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span></span><br><span class=\"line\">  ElemType data;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure></li>\n<li>利用单链表可以解决顺序表需要大量连续存储单元的缺点，但附加的指针域，也存在浪费存储空间的缺点。</li>\n<li>由于单链表的元素离散地分布在存储空间中，因此是非随机存取的存储结构，即不能直接找到表中某个特定结点。查找特定结点时，需要从表头开始遍历，依次查找。</li>\n<li>通常用<strong>头指针L（或head等）</strong>来标识一个单链表，<u>指出链表的起始地址</u>，<u>头指针为NULL时表示一个空表</u>。</li>\n<li>此外，为了操作上的方便，在单链表第一个数据结点之前附加一个结点，称为<strong>头结点</strong>。</li>\n<li>头结点的数据域可以不设任何信息，但也可以记录表长等信息。单链表带头结点时，头指针L指向头结点；单链表不带头结点时，头指针指向第一个数据结点。</li>\n<li>表尾结点的指针域为NULL（用“^”表示）。</li>\n<li><strong>头结点和头指针的关系</strong>：不管带不带头结点，头指针都始终指向链表的第一个结点，<u>而头结点是带头结点的链表中的第一个结点</u>，结点内通常不存储信息。</li>\n<li>引入<u>头结点</u>后，可以带来<strong>两个优点</strong>：<ol>\n<li>由于第一个数据结点的位置被存放在头结点的指针域中，因此<strong>在链表的第一个位置上的操作和在表的其他位置上的操作一致</strong>，无须进行特殊处理。</li>\n<li>无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），因此<strong>空表和非空表的处理也就得到了统一</strong>。</li>\n</ol>\n</li>\n<li>初始化（王道）：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//带头结点</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitList</span><span class=\"params\">(LinkList &amp;L)</span> &#123;</span><br><span class=\"line\">  L=(LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">  L-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不带头结点</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitList</span><span class=\"params\">(LinkList &amp;L)</span> &#123;</span><br><span class=\"line\">  L=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>求表长（王道）：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Length</span><span class=\"params\">(LinkList L)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> len=<span class=\"number\">0</span>;</span><br><span class=\"line\">  LNode *p=L;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(p-&gt;next!=<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    p=p-&gt;next;</span><br><span class=\"line\">    len++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>按序号查找结点（王道+书）：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//王道</span></span><br><span class=\"line\">LNode *<span class=\"title function_\">GetElem</span><span class=\"params\">(LinkList L, <span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">  LNode *p = L;</span><br><span class=\"line\">  <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(p != NUll &amp;&amp; j &lt; i) &#123;</span><br><span class=\"line\">    p = p -&gt; next;</span><br><span class=\"line\">    j ++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//书</span></span><br><span class=\"line\">Status <span class=\"title function_\">GetElem_L</span><span class=\"params\">(LinkList L, <span class=\"type\">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class=\"line\">  p = L -&gt; next; j = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class=\"line\">    p = p -&gt; next; ++ j;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!p) <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//表长小于i，没有第i个元素</span></span><br><span class=\"line\">  e = p -&gt; data;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>按值查找表结点（王道）：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LNode *<span class=\"title function_\">LocateElem</span><span class=\"params\">(LinkList L, ElemType e)</span> &#123;</span><br><span class=\"line\">  LNode *p = L -&gt; next;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p != <span class=\"literal\">NULL</span> &amp;&amp; p -&gt; data != e) &#123;</span><br><span class=\"line\">    p = p -&gt; next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>插入结点（王道，书上与王道一致不写了）：</p>\n<blockquote>\n<p>注意，当链表不带头结点时，需要判断插入位置i是否为1，若是，则要做特殊处理，将头指针L指向新的首结点。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//王道，将值为x的新结点插入到第i个位置</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span> &#123;</span><br><span class=\"line\">  LNode *p = L;</span><br><span class=\"line\">  <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p != <span class=\"literal\">NULL</span> &amp;&amp; j &lt; i - <span class=\"number\">1</span> ) &#123;</span><br><span class=\"line\">    p = p -&gt; next;</span><br><span class=\"line\">    j ++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (p == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">//i值不合法</span></span><br><span class=\"line\">  LNode *s=(LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">  s -&gt; data = e;</span><br><span class=\"line\">  s -&gt; next = p -&gt; next;</span><br><span class=\"line\">  p -&gt; next = s;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>可以将前插操作写成后插操作+data互换</p>\n<blockquote>\n<p>在单链表插入算法中，通常都采用后插操作。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//需要将*s插入到*p前，用*s插入到*p后+互换data</span></span><br><span class=\"line\">s -&gt; next = p -&gt; next;</span><br><span class=\"line\">p -&gt; next = s;</span><br><span class=\"line\">temp = p -&gt; data;</span><br><span class=\"line\">p -&gt; data = s -&gt; data;</span><br><span class=\"line\">s -&gt; data = temp;</span><br></pre></td></tr></table></figure></li>\n<li><p>删除结点（王道，书上与王道一致不写了）：</p>\n<blockquote>\n<p>注意，当链表不带头结点时，需要判断插入位置i是否为1，若是，则要做特殊处理，将头指针L指向新的首结点。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListDelete</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class=\"line\">  LNode *p = L;</span><br><span class=\"line\">  <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p != <span class=\"literal\">NULL</span> &amp;&amp; j &lt; i - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    p = p -&gt; next;</span><br><span class=\"line\">    j ++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (p == <span class=\"literal\">NULL</span> || p -&gt; next == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">//i值不合法</span></span><br><span class=\"line\">  LNode *q = p -&gt; next;</span><br><span class=\"line\">  e = q -&gt; data;</span><br><span class=\"line\">  p -&gt; next = q -&gt; next;</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(q);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>可以将删除p写成删除p的后继+交换data</p>\n<blockquote>\n<p>删除结点的通常做法是找到p前驱，然后执行删除操作。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q = p -&gt; next;</span><br><span class=\"line\">p -&gt; data = p -&gt; next -&gt; data;</span><br><span class=\"line\">p -&gt; next = q -&gt; next;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(q);</span><br></pre></td></tr></table></figure></li>\n<li>采用头插法建立单链表（插入头结点之后），可以用来实现链表的逆置。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinkList <span class=\"title function_\">List_HeadInsert</span><span class=\"params\">(LinkList &amp;L)</span> &#123;</span><br><span class=\"line\">  LNode *s; <span class=\"type\">int</span> x; <span class=\"comment\">//定义新结点</span></span><br><span class=\"line\">  L = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode)); <span class=\"comment\">//创建头结点</span></span><br><span class=\"line\">  L -&gt; next = <span class=\"literal\">NULL</span>; <span class=\"comment\">//初始为空链表</span></span><br><span class=\"line\">  <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x); <span class=\"comment\">//输入结点的值</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(x!=<span class=\"number\">9999</span>) &#123; <span class=\"comment\">//输入9999表示结束</span></span><br><span class=\"line\">    s = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode)); <span class=\"comment\">//创建新结点</span></span><br><span class=\"line\">    s -&gt; data = x;</span><br><span class=\"line\">    s -&gt; next = L -&gt; next;</span><br><span class=\"line\">    L -&gt; next = s; <span class=\"comment\">//L为头指针</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>采用尾插法建立单链表。为此必须增加一个尾指针r，使其始终指向当前链表的尾结点。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinkList <span class=\"title function_\">List_TailInsert</span><span class=\"params\">(LinkList &amp;L)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> x;</span><br><span class=\"line\">  L = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode)); <span class=\"comment\">//创建头结点</span></span><br><span class=\"line\">  LNode *s, *r = L; <span class=\"comment\">//r为表尾指针</span></span><br><span class=\"line\">  <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(x != <span class=\"number\">9999</span>) &#123; <span class=\"comment\">//输入9999表示结束</span></span><br><span class=\"line\">    s = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">    s -&gt; data = x;</span><br><span class=\"line\">    r -&gt; next = s;</span><br><span class=\"line\">    r = s; <span class=\"comment\">//r指向新的表尾结点</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  r -&gt; next = <span class=\"literal\">NULL</span>; <span class=\"comment\">//尾结点指针置空</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>归并两个链表（书）<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MergeList_L</span><span class=\"params\">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//已知单链线性表La和Lb的元素按值非递减排列</span></span><br><span class=\"line\">  <span class=\"comment\">//归并La和Lb得到新的单链线性表Lc，Lc的元素也按值非递减排列</span></span><br><span class=\"line\">  pa = La -&gt; next; pb = Lb -&gt; next;</span><br><span class=\"line\">  Lc = pc = La; <span class=\"comment\">//用La的头结点作为Lc的头结点</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(pa &amp;&amp; pb) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pa -&gt; data &lt;= pb -&gt; data) &#123;</span><br><span class=\"line\">      pc -&gt; next = pa; pc = pa; pa = pa -&gt; next; <span class=\"comment\">//将pa所指结点链接到pc所指结点之后</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      pc -&gt; next = pb; pc = pb; pb = pb -&gt; next; <span class=\"comment\">//将pb所指结点链接到pc所指结点之后</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  pc -&gt; next = pa ? pa : pb; <span class=\"comment\">//插入剩余段（pa存在连pa，否则连pb）</span></span><br><span class=\"line\">  <span class=\"built_in\">free</span>(Lb); <span class=\"comment\">//释放Lb的头结点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"静态链表\"><a href=\"#静态链表\" class=\"headerlink\" title=\"静态链表\"></a>静态链表</h4><ul>\n<li>静态链表是用数组来描述线性表的链式存储结构（其他链表为指针型描述），结点也有数据域data和指针域next。</li>\n<li>与其他链表中的指针不同的是，这里的指针是<u>结点在数组中的相对地址（书：相对位置）（数组下标）</u>，又称<strong>游标</strong>。</li>\n<li>和顺序表一样，<strong>静态链表也要预先分配一块连续的内存空间</strong>。</li>\n<li>静态链表的插入、删除操作与动态链表的相同，只需要修改指针，而不需要移动元素，故仍具有链式存储结构的主要优点。</li>\n<li>这种描述方法便于在不支持指针的高级程序设计语言（如Basic）中使用链表结构。</li>\n<li>数组的一个分量表示一个结点，数组的第零分量可看成头结点，其指针域只是链表的第一个结点。</li>\n<li>线性表的静态单链表存储结构：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXSIZE 1000 <span class=\"comment\">//链表的最大长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  ElemType data;</span><br><span class=\"line\">  <span class=\"type\">int</span> cur;</span><br><span class=\"line\">&#125;component, SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure></li>\n<li>定位函数（书）<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">LocateElem_SL</span><span class=\"params\">(SLinkList S, ElemType e)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//在静态单链线性表L中查找第1个值为e的元素</span></span><br><span class=\"line\">  <span class=\"comment\">//若找到，则返回它在L中的位序，否则返回0</span></span><br><span class=\"line\">  i = S[<span class=\"number\">0</span>].cur; <span class=\"comment\">//i表中第一个结点</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(i &amp;&amp; S[i].data != e) i = S[i].cur; <span class=\"comment\">//在表中顺链查找</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>求(A-B)∪(B-A)（书P33，挺复杂的，有时间可看）</li>\n</ul>\n<h4 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h4><ul>\n<li>单链表只能从前往后依次遍历；要访问某个结点的前驱（插入、删除操作时），只能从头开始遍历，访问前驱的时间复杂度为O(n)。</li>\n<li>为了克服单链表的这个缺点，引入了<strong>双链表</strong>，双链表结点中有两个指针prior和next，分别指向其直接前驱和直接后继。</li>\n<li>表头结点的prior域和尾结点的next域都是NULL。</li>\n<li>线性表的双向链表存储结构（书）：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DuLNode</span> &#123;</span></span><br><span class=\"line\">  ElemType data;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DuLNode</span> *<span class=\"title\">prior</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DuLNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"单循环链表\"><a href=\"#单循环链表\" class=\"headerlink\" title=\"单循环链表\"></a>单循环链表</h4><ul>\n<li>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环。</li>\n<li>在循环单链表中，<strong>表尾结点*r的next域指向L</strong>，故表中没有指针域为NULL的结点，因此，循环单链表的<strong>判空条件</strong>不是头结点的指针是否为空，而是<strong>它（头结点的指针）是否等于头指针L</strong>。</li>\n<li>循环单链表的插入、删除算法与单链表的几乎一样，所<strong>不同</strong>的是若操作是在<strong>表尾</strong>进行，则执行的操作不同，以让单链表继续保持循环的性质。</li>\n<li>当然，正是因为循环单链表是一个“环”，所有在任何位置上的插入和删除操作都是等价的，而无须判断是否是表尾。</li>\n<li>在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表<u>可以从表中的任意一个结点开始</u>遍历整个链表。</li>\n<li><strong>有时</strong>对循环单链表不设头指针，<strong>而仅设尾指针</strong>，<u>以使得操作效率更高</u>。其原因是，若设的是头指针，对在表尾插入元素需要O(n)的时间复杂度，而若设的是尾指针r，<strong>r-&gt;next即为头指针</strong>，对在表头或插入元素都只需要O(1)的时间复杂度。</li>\n</ul>\n<h4 id=\"双向循环链表\"><a href=\"#双向循环链表\" class=\"headerlink\" title=\"双向循环链表\"></a>双向循环链表</h4><ul>\n<li>与循环单链表不同的是，在循环双链表中，头结点的prior指针还要指向表尾结点。</li>\n<li><strong>表尾结点*p的next域也指向L</strong>；当循环双链表为<strong>空表</strong>时，其<strong>头结点的prior域和next域都等于L</strong>。</li>\n</ul>\n<h4 id=\"带头结点的链表\"><a href=\"#带头结点的链表\" class=\"headerlink\" title=\"带头结点的链表\"></a>带头结点的链表</h4><p>（对于单链表：）</p>\n<ul>\n<li>头结点的数据域可以不设任何信息，但也可以记录表长等信息。单链表带头结点时，头指针L指向头结点；单链表不带头结点时，头指针指向第一个数据结点。</li>\n<li><strong>头结点和头指针的关系</strong>：不管带不带头结点，头指针都始终指向链表的第一个结点，<u>而头结点是带头结点的链表中的第一个结点</u>，结点内通常不存储信息。</li>\n<li>引入<u>头结点</u>后，可以带来<strong>两个优点</strong>：<ol>\n<li>由于第一个数据结点的位置被存放在头结点的指针域中，因此<strong>在链表的第一个位置上的操作和在表的其他位置上的操作一致</strong>，无须进行特殊处理。</li>\n<li>无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），因此<strong>空表和非空表的处理也就得到了统一</strong>。</li>\n</ol>\n</li>\n<li>初始化（王道）：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//带头结点</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitList</span><span class=\"params\">(LinkList &amp;L)</span> &#123;</span><br><span class=\"line\">  L=(LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">  L-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不带头结点</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitList</span><span class=\"params\">(LinkList &amp;L)</span> &#123;</span><br><span class=\"line\">  L=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>对于插入操作，当链表不带头结点时，需要判断插入位置i是否为1，若是，则要做特殊处理，将头指针L指向新的首结点。</li>\n<li>对于删除操作，当链表不带头结点时，需要判断插入位置i是否为1，若是，则要做特殊处理，将头指针L指向新的首结点。</li>\n</ul>\n<p>（单循环链表，关于头结点的部分）</p>\n<ul>\n<li>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环。</li>\n<li>在循环单链表中，<strong>表尾结点*r的next域指向L</strong>，故表中没有指针域为NULL的结点，因此，循环单链表的<strong>判空条件</strong>不是头结点的指针是否为空，而是<strong>它（头结点的指针）是否等于头指针L</strong>。<br>（双向循环链表，关于头结点的部分）<h4 id=\"双向循环链表-1\"><a href=\"#双向循环链表-1\" class=\"headerlink\" title=\"双向循环链表\"></a>双向循环链表</h4></li>\n<li>与循环单链表不同的是，在循环双链表中，头结点的prior指针还要指向表尾结点。</li>\n<li><strong>表尾结点*p的next域也指向L</strong>；当循环双链表为<strong>空表</strong>时，其<strong>头结点的prior域和next域都等于L</strong>。</li>\n</ul>\n<h3 id=\"线性表的应用\"><a href=\"#线性表的应用\" class=\"headerlink\" title=\"线性表的应用\"></a>线性表的应用</h3><h4 id=\"一元多项式的表示和相加\"><a href=\"#一元多项式的表示和相加\" class=\"headerlink\" title=\"一元多项式的表示和相加\"></a>一元多项式的表示和相加</h4><blockquote>\n<p>这个应该是线性表的应用吧，书P39</p>\n</blockquote>\n<ul>\n<li>代码很复杂，大致思路：</li>\n</ul>\n<ol>\n<li>先将一个一元n次多项式按照升幂写成<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>p</mi><mn>1</mn></msub><msup><mi>x</mi><msub><mi>e</mi><mn>1</mn></msub></msup><mo>+</mo><msub><mi>p</mi><mn>2</mn></msub><msup><mi>x</mi><msub><mi>x</mi><mn>2</mn></msub></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>p</mi><mi>m</mi></msub><msup><mi>x</mi><msub><mi>e</mi><mi>m</mi></msub></msup></mrow><annotation encoding=\"application/x-tex\">P_n(x) = p_1 x^{e_1} + p_2 x^{x_2} + \\cdots + p_m x^{e_m} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8588em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8588em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8588em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1645em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，<br>其中<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>是指数为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">e_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的项的非零系数，且满足<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>e</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>e</mi><mn>2</mn></msub><mo>&lt;</mo><mo>⋯</mo><mo>&lt;</mo><msub><mi>e</mi><mi>m</mi></msub><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">0 \\leq e_1 &lt; e_2 &lt; \\cdots &lt; e_m = n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></li>\n<li>用线性链表表示一元多项式，每个结点表示多项式中的一项，每个结点存储系数和指数。</li>\n<li>实现两个多项式（用两个线性链表表示）的相加：类似于归并，因为指数升序排列，对于指数相同的把系数相加即可。</li>\n<li>实现多项式相乘：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>A</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>A</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mo stretchy=\"false\">[</mo><msub><mi>b</mi><mn>1</mn></msub><msup><mi>x</mi><msub><mi>e</mi><mn>1</mn></msub></msup><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><msup><mi>x</mi><msub><mi>e</mi><mn>2</mn></msub></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>b</mi><mi>n</mi></msub><msup><mi>x</mi><msub><mi>e</mi><mi>n</mi></msub></msup><mo stretchy=\"false\">]</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>b</mi><mi>i</mi></msub><mi>A</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>x</mi><msub><mi>e</mi><mi>i</mi></msub></msup></mrow><annotation encoding=\"application/x-tex\">M(x)=A(x)×B(x)\n    =A(x)×[b_1x^{e_1}+b_2x^{e_2}+\\cdots +b_nx^{e_n}]\n    =\\sum\\limits_{i=1}^n b_i A(x)x^{e_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1645em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3281em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>\n</ol>\n<h3 id=\"具有在实际中选取不同存储结构的判断能力\"><a href=\"#具有在实际中选取不同存储结构的判断能力\" class=\"headerlink\" title=\"具有在实际中选取不同存储结构的判断能力\"></a>具有在实际中选取不同存储结构的判断能力</h3><h4 id=\"顺序表和链表的比较\"><a href=\"#顺序表和链表的比较\" class=\"headerlink\" title=\"顺序表和链表的比较\"></a>顺序表和链表的比较</h4><p>（出自蓝皮书）</p>\n<ul>\n<li>顺序表<ul>\n<li>优点：</li>\n</ul>\n<ol>\n<li>时间上，它可以顺序存储，还可以随机存取，访问速度快；</li>\n<li>空间上，它的存储利用率高，不需要指针。</li>\n</ol>\n<ul>\n<li>缺点：</li>\n</ul>\n<ol>\n<li>时间上，顺序表在插入删除时，如果需要保持原来的顺序，必须平均移动一半的元素，更新速度慢；</li>\n<li>空间上，如果采用静态分配的存储结构，一旦存储数组的空间已满，不能扩充，再插入元素将导致溢出。</li>\n</ol>\n</li>\n<li>链表<ul>\n<li>优点：</li>\n</ul>\n<ol>\n<li>时间上，插入删除不需要大量移动元素，只需修改指针，更新速度快；</li>\n<li>空间上，链表基本没有满和溢出的问题，只要内存可以分配节点，就可以扩充。</li>\n</ol>\n<ul>\n<li>缺点：</li>\n</ul>\n<ol>\n<li>时间上，链表只能顺序访问，所以查找一个元素平均要搜索半个表，访问速度慢；</li>\n<li>空间上，每个元素需要附加一个指针，存储利用率较低。</li>\n<li>此外，由于链表的单线联系的特性，如果操作不慎，导致断链，将会丢失后面的所有元素。</li>\n</ol>\n</li>\n</ul>\n<p>（出自王道）</p>\n<ol>\n<li>存取（读/写）方式<ul>\n<li>顺序表可以顺序存取，也可以随机存；</li>\n<li>链表只能从表头开始依次顺序存取。</li>\n</ul>\n</li>\n<li>逻辑结构与物理结构<ul>\n<li>采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻；</li>\n<li>采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。</li>\n</ul>\n</li>\n<li>查找、插入和删除操作<ul>\n<li>对于按值查找，<ul>\n<li>顺序表无序时，两者的时间复杂度均为O(n)；</li>\n<li>顺序表有序时，可采用折半查找，此时的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log_2n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n</li>\n<li>对于按序号查找，<ul>\n<li>顺序表支持随机访问，时间复杂度为O(1)；</li>\n<li>链表的平均时间复杂度为O(n)。</li>\n</ul>\n</li>\n<li>插入、删除操作<ul>\n<li>顺序表平均需要移动半个表长的元素；</li>\n<li>链表只需修改相关结点的指针域即可。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>空间分配<ul>\n<li>顺序存储<ul>\n<li>在静态存储分配情形下，<ul>\n<li>一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，因此需要预先分配足够大的存储空间。</li>\n<li>预先分配过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成溢出。</li>\n</ul>\n</li>\n<li>在动态存储分配情形下，<ul>\n<li>虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低；</li>\n<li>而且若内存中没有更大块的连续存储空间，则会导致分配失败。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>链式存储<ul>\n<li>结点空间只在需要时申请分配，</li>\n<li>只要有内存就可以分配，</li>\n<li>操作灵活、高效。</li>\n<li>此外，由于链表的每个结点都带有指针域，因此存储密度不够大。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"在实际中怎样选取存储结构\"><a href=\"#在实际中怎样选取存储结构\" class=\"headerlink\" title=\"在实际中怎样选取存储结构\"></a>在实际中怎样选取存储结构</h4><p>（出自王道）</p>\n<ol>\n<li>基于存储的考虑<ul>\n<li>难以估计线性表的长度或存储规模时，不宜采用顺序表；</li>\n<li>但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。</li>\n</ul>\n</li>\n<li>基于运算的考虑<ul>\n<li>若经常做的运算是按序号访问数据元素，<strong>顺序表优于链表</strong>。<ul>\n<li>在顺序表中按序号访问<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的时间复杂度为O(1)；</li>\n<li>链表中按序号访问的时间复杂度为O(n)。</li>\n</ul>\n</li>\n<li>关于插入、删除操作。<ul>\n<li>在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的；</li>\n<li>在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然<strong>链表优于顺序表</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>基于环境的考虑<ul>\n<li>顺序表容易实现，任何高级语言中都有数组类型；</li>\n<li>链表的操作是基于指针的，相对来讲，前者实现较为简单，这也是用户考虑的一个因素。</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>总之，两种存储结构各有长短，选择哪一种由实际问题的主要因素决定。</li>\n<li>通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表（即动态性较强）宜选择链式存储。</li>\n</ul>\n<h3 id=\"广义表\"><a href=\"#广义表\" class=\"headerlink\" title=\"广义表\"></a>广义表</h3><blockquote>\n<p>不记得在哪的知识点了，先写在这儿了。<br>内容来自<a href=\"https://www.cnblogs.com/kuailest/p/16743376.html\">博客</a>。</p>\n</blockquote>\n<h4 id=\"广义表的定义\"><a href=\"#广义表的定义\" class=\"headerlink\" title=\"广义表的定义\"></a>广义表的定义</h4><ul>\n<li><strong>线性表</strong> 线性表指的是n≥0个元素a1, a2, a3…的有序数列，并且线性表的元素具有原子性，即结构上是不可分割的一个整体。</li>\n<li><strong>广义表(Generalized list)</strong> 而广义表则是线性表的一种扩展延伸。相对于线性表，广义表最大的特点在于其元素既可以是一个确定的类型，同时也可以是另一个有不定数量的元素组成的表（广义表）。<br>不难看出从广义表的定义是递归的。广义表是线性表的递归数据结构。</li>\n</ul>\n<h4 id=\"广义表的基本概念\"><a href=\"#广义表的基本概念\" class=\"headerlink\" title=\"广义表的基本概念\"></a>广义表的基本概念</h4><ul>\n<li><strong>广义表的表示</strong><br>我们通常可以用 GL = (a1, a2, a3… an)来表示一个广义表，其中n为表的长度，n≥0，当n==0时，我们称广义表为空表，GL为广义表的名字。<br>为了能更好的区分广义表中的元素我们有以下定义：<br><strong>原子</strong> 如果ai是单个元素，我们称之为GL的原子<br><strong>子表</strong> 如果ai是一个广义表，我们陈之为GL的子表<br>我们通常把广义表中的原子用小写字母表示，而子表用大写字母表示。例如<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A=() //空表</span><br><span class=\"line\">B=(e) //只含有一个原子的广义表</span><br><span class=\"line\">C=(a,(b,c,d)) //含有一个原子和一个子表的广义表</span><br><span class=\"line\">D=(A,B,C)=((),(e),(a,(b,c,d))) //含有三个子表的广义表，且第一个表为空表</span><br><span class=\"line\">E=(a,E) //广义表 E 中有两个元素，原子 a 和它本身。这是一个递归广义表，等同于：E = (a,(a,(a,…)))。</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>广义表的深度和长度</strong><br><strong>广义表的长度</strong>： 广义表中元素的个数（包括原子和子表）<br><strong>广义表的深度</strong>： 广义表中括号的最大层数叫广义表的深度</p>\n</li>\n<li><p><strong>广义表的表头和表尾</strong><br><strong>表头</strong>： 当广义表不为空表时，第一个元素（可能为子表和原子）称为表头<br><strong>表尾</strong>： 除去表头，剩余元素组成的新广义表称为表尾<br>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LS=(1,(1,2,3),5), 其中表头Head(LS)为原子1，表尾为Tail(LS)=((1,2,3),5)</span><br><span class=\"line\">LS=(1), 其中表头Head(LS)为原子1，表尾为空表</span><br></pre></td></tr></table></figure>\n<h4 id=\"广义表的存储结构\"><a href=\"#广义表的存储结构\" class=\"headerlink\" title=\"广义表的存储结构\"></a>广义表的存储结构</h4><p>广义表是一种递归的数据结构，它的元素有两种类型，因此很难为广义表分配固定的存储空间，所以其存储结构适合用链式存储结构。<br>为了能使原子和子表在结构上保持一致，又容易区分我们通常采用如下结构：<br><strong>广义表的第一种存储结构</strong><br><img src=\"/articles/9eb01842/GL_1.png\" width=80% height=70% /></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span>ATOM,LIST &#125; ElemTag; <span class=\"comment\">//ATOM==0:表示原子,LIST==1:表示子表</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GLNode</span> &#123;</span></span><br><span class=\"line\">  ElemTag tag; <span class=\"comment\">//公共部分，用以区分原子部分和表结点</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span> <span class=\"comment\">//原子部分和表结点的联合部分</span></span><br><span class=\"line\">    AtomType atom; <span class=\"comment\">//atom是原子结点的值域,  AtomType由用户定义</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GLNode</span> *<span class=\"title\">hp</span>, *<span class=\"title\">tp</span>;</span>&#125; ptr;</span><br><span class=\"line\">    <span class=\"comment\">// ptr是表结点的指针域,ptr.hp和ptr.tp分别指向表头和表尾</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125; *Glist; <span class=\"comment\">//广义表类型</span></span><br></pre></td></tr></table></figure>\n<p>e.g. 表示（a,(b,c,d)）<br><img src=\"/articles/9eb01842/GL_11.png\" width=100% height=70% /></p>\n</li>\n</ul>\n<p><strong>广义表的第二种存储结构</strong><br><img src=\"/articles/9eb01842/GL_2.png\" width=80% height=70% /><br>第二种表示形式实际上就只是在原子中添加了tp指针指向下一个原子或子表<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Typedef <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span> ATOM,LIST&#125; ElemTag;</span><br><span class=\"line\"><span class=\"comment\">//ATOM==0:表示原子,LIST==1:表示子表</span></span><br><span class=\"line\">Typedef <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GLNode</span> &#123;</span></span><br><span class=\"line\">  ElemTag tag; <span class=\"comment\">//公共部分，用以区分原子部分和表结点</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span> <span class=\"comment\">//原子部分和表结点的联合部分</span></span><br><span class=\"line\">    AtomType atom; <span class=\"comment\">//原子结点的值域</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GLNode</span> *<span class=\"title\">hp</span>;</span> <span class=\"comment\">//表结点的表头指针</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GLNode</span> *<span class=\"title\">tp</span>;</span></span><br><span class=\"line\">  <span class=\"comment\">//相当于线性链表的next，指向下一个元素结点</span></span><br><span class=\"line\">&#125; *Glist; <span class=\"comment\">//广义表类型Glist 是一种扩展的线性链表</span></span><br></pre></td></tr></table></figure><br>e.g. 表示（a,(b,c,d)）<br><img src=\"/articles/9eb01842/GL_22.png\" width=100% height=70% /></p>\n<h4 id=\"广义表的计算（以第二种存储结构为例）\"><a href=\"#广义表的计算（以第二种存储结构为例）\" class=\"headerlink\" title=\"广义表的计算（以第二种存储结构为例）\"></a>广义表的计算（以第二种存储结构为例）</h4><p>（<a href=\"https://zh.wikipedia.org/wiki/%E5%B9%BF%E4%B9%89%E8%A1%A8\">wiki</a>）D=(( ),(e),(a,(b,c,d)))是多层次的广义表，长度为3，深度为3。<br><strong>广义表长度的计算</strong>（类似于链表的长度，直接统计tp）<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">GLLength</span><span class=\"params\">(GLNode *g)</span> &#123; <span class=\"comment\">//g为一个广义表头节点的指针</span></span><br><span class=\"line\">  <span class=\"type\">int</span> n=<span class=\"number\">0</span>;</span><br><span class=\"line\">  g=g-&gt;hp; <span class=\"comment\">//g指向广义表的第一个元素</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (g!=<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    n++;</span><br><span class=\"line\">    g=g-&gt;tp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>广义表的深度</strong>（括号的最大层数）<br>对于带头节点的广义表g,广义表深度的递归定义是它等于所有子表中表的最大深度加1。若g为原子,其深度为0。<br><img src=\"/articles/9eb01842/GL_3.png\" width=70% height=70% /><br>求广义表深度的递归模型f()如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">GLDepth</span><span class=\"params\">(GLNode *g)</span> &#123; <span class=\"comment\">//求带头节点的广义表g的深度</span></span><br><span class=\"line\">  <span class=\"type\">int</span> max=<span class=\"number\">0</span>,dep;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g-&gt;tag==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">//为原子时返回0</span></span><br><span class=\"line\">  g=g-&gt;hp; <span class=\"comment\">//g指向第一个元素</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">//为空表时返回1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (g!=<span class=\"literal\">NULL</span>) &#123; <span class=\"comment\">//遍历表中的每一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g-&gt;tag==<span class=\"number\">1</span>) &#123;　<span class=\"comment\">//元素为子表的情况</span></span><br><span class=\"line\">      dep=GLDepth(g); <span class=\"comment\">//递归调用求出子表的深度</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (dep&gt;max) max=dep;</span><br><span class=\"line\">      <span class=\"comment\">//max为同一层所求过的子表中深度的最大值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    g=g-&gt;tp; <span class=\"comment\">//使g指向下一个元素</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>(max+<span class=\"number\">1</span>); <span class=\"comment\">//返回表的深度</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、栈和队列\"><a href=\"#四、栈和队列\" class=\"headerlink\" title=\"四、栈和队列\"></a>四、栈和队列</h2><blockquote>\n<p>博客：<br><a href=\"https://cloud.tencent.com/developer/article/2456014\">栈的深度解析：顺序栈与链栈的实现</a><br><a href=\"https://cloud.tencent.com/developer/article/2456015\">队列的深度解析：链式队列的实现</a></p>\n</blockquote>\n<h3 id=\"栈的定义\"><a href=\"#栈的定义\" class=\"headerlink\" title=\"栈的定义\"></a>栈的定义</h3><ul>\n<li><strong>栈</strong>是一种后进先出（LIFO）的线性表，只允许在表尾进行插入和删除操作。</li>\n<li><strong>栈顶</strong>——<u>表尾端</u>（线性表允许进行插入和删除操作的那一端）。</li>\n<li><strong>栈底</strong>——<u>表头端</u>（线性表不允许进行插入和删除操作的那一端）。</li>\n<li><strong>空栈</strong>——不含任何元素的空表。</li>\n</ul>\n<h3 id=\"栈的逻辑结构\"><a href=\"#栈的逻辑结构\" class=\"headerlink\" title=\"栈的逻辑结构\"></a>栈的逻辑结构</h3><ul>\n<li>栈是操作受限的线性表，可被称为限定性的数据结构，其操作特性是后进先出（Last In First Out，LIFO）。</li>\n<li>栈是只允许在一端进行插入和删除操作的线性表，允许进行插入和删除操作的那一端称为栈顶，不允许进行插入和删除操作的另一端称为栈底。</li>\n</ul>\n<h3 id=\"栈的特点（考点没写）\"><a href=\"#栈的特点（考点没写）\" class=\"headerlink\" title=\"栈的特点（考点没写）\"></a>栈的特点（考点没写）</h3><ul>\n<li><strong>操作限制：</strong>只能在栈顶进行元素的添加（入栈）和移除（出栈）。</li>\n<li><strong>栈顶元素：</strong>当前可以访问和操作的元素。</li>\n<li><strong>空栈：</strong>栈为空时，无法进行出栈操作。</li>\n</ul>\n<h3 id=\"栈的操作特性（考点没写）\"><a href=\"#栈的操作特性（考点没写）\" class=\"headerlink\" title=\"栈的操作特性（考点没写）\"></a>栈的操作特性（考点没写）</h3><ul>\n<li>后进先出（Last In First Out，LIFO）</li>\n</ul>\n<h3 id=\"栈的基本操作\"><a href=\"#栈的基本操作\" class=\"headerlink\" title=\"栈的基本操作\"></a>栈的基本操作</h3><ul>\n<li><strong>入栈（Push）：</strong>将新元素添加到栈顶。</li>\n<li><strong>出栈（Pop）：</strong>移除并返回栈顶元素。</li>\n<li><strong>查看栈顶元素（GetTop）：</strong>返回栈顶元素，但不删除它。</li>\n<li><strong>判断是否为空（IsEmpty）：</strong>检查栈是否没有元素。</li>\n<li><strong>统计栈的大小（Size）：</strong>获取栈中有效元素个数。</li>\n</ul>\n<h3 id=\"栈的数学性质（考点没写）\"><a href=\"#栈的数学性质（考点没写）\" class=\"headerlink\" title=\"栈的数学性质（考点没写）\"></a>栈的数学性质（考点没写）</h3><ul>\n<li>当n个不同元素进栈时，出栈元素不同排列的个数为<br><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><msubsup><mi mathvariant=\"normal\">C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{n+1}\\mathrm{C}_{2n}^{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2484em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.4519em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span></span></span></span>。这个公式称为卡特兰数（Catalan）公式。</li>\n<li>证明：</li>\n</ul>\n<ol>\n<li>画个n*n条路（边）的方格，从一个顶点走到另一个斜对角的端点总共要走2n条边，从中选择n条边为竖着走或横着走（类比为进栈或出栈），剩下n条为横着走或竖着走，得到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">\\mathrm{C}_{2n}^{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9314em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.4519em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span></span></span></span>种方式。</li>\n<li>过了斜对角线的路径是有问题的，就是在某个前缀操作里边出栈次数多于入栈了（拿鬼出栈啊），求出这些非法路径的数目。</li>\n<li>设不能越过的对角线为y=x，从(0,0)→(n,n)。画出y=x+1，作为对称轴。若越过y=x，与y=x+1就会有交点，把第一次碰到y=x+1以后的部分关于y=x+1对称，路径变为(0,0)→(n-1,n+1)。显然每一条非法路径都可以这么变为(0,0)→(n-1,n+1)，而任何合法方案由于不接触直线y=x+1，无论从哪个点对称都不是一条连续的路径。</li>\n<li>非法路径条数为(0,0)→(n-1,n+1)的方案数，为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">\\mathrm{C}_{2n}^{n-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1205em;vertical-align:-0.2663em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8542em;\"><span style=\"top:-2.4337em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.1031em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2663em;\"><span></span></span></span></span></span></span></span></span></span>。</li>\n<li>合法路径数=<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup><mo>−</mo><msubsup><mi mathvariant=\"normal\">C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow><mrow><mi>n</mi><mo stretchy=\"false\">!</mo><mi>n</mi><mo stretchy=\"false\">!</mo></mrow></mfrac><mo>−</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mrow><mi>n</mi><mo stretchy=\"false\">!</mo><mi>n</mi><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mfrac><mo>−</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo><mi>n</mi></mrow><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi>n</mi><mo stretchy=\"false\">!</mo><mi>n</mi><mo stretchy=\"false\">!</mo></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo stretchy=\"false\">[</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>−</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo><mi>n</mi></mrow><mrow><mi>n</mi><mo stretchy=\"false\">!</mo><mi>n</mi><mo stretchy=\"false\">!</mo></mrow></mfrac><mo stretchy=\"false\">]</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><msubsup><mi mathvariant=\"normal\">C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">\\mathrm{C}_ {2n}^{n}-\\mathrm{C}_{2n}^{n-1} =\\frac{(2n)!}{n!n!}-\\frac{(2n)!}{(n+1)!(n-1)!} =\\frac{(2n)!(n+1)}{n!n!(n+1)}-\\frac{(2n)!n}{(n+1)n!n!} =\\frac{1}{n+1}[\\frac{(2n)!(n+1)-(2n)!n}{n!n!}] =\\frac{1}{n+1} \\mathrm{C}_{2n}^{n} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9314em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.4519em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1205em;vertical-align:-0.2663em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8542em;\"><span style=\"top:-2.4337em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.1031em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2663em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)!</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.53em;vertical-align:-0.52em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)!</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)!</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)!</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.53em;vertical-align:-0.52em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)!</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.53em;vertical-align:-0.52em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)!</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.4133em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)!</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mbin mtight\">−</span><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)!</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2484em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.4519em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span></span></span></span></li>\n</ol>\n<h3 id=\"顺序栈的定义\"><a href=\"#顺序栈的定义\" class=\"headerlink\" title=\"顺序栈的定义\"></a>顺序栈的定义</h3><ul>\n<li><strong>顺序栈</strong>：采用顺序存储的栈，利用一组地址连续的存储单元依次存放<u>自栈底到栈顶</u>的数据元素，同时附设一个指针top指示栈顶元素在顺序栈中的位置。</li>\n</ul>\n<h3 id=\"链式栈的定义\"><a href=\"#链式栈的定义\" class=\"headerlink\" title=\"链式栈的定义\"></a>链式栈的定义</h3><ul>\n<li><strong>链栈</strong>：采用链式存储的栈。优点是便于多个栈共享存储空间和提高其效率，且不易发生栈溢出。</li>\n<li>通常用单链表实现，并规定所有操作都是在单链表的表头进行的。</li>\n</ul>\n<h3 id=\"顺序栈和链式栈的特点\"><a href=\"#顺序栈和链式栈的特点\" class=\"headerlink\" title=\"顺序栈和链式栈的特点\"></a>顺序栈和链式栈的特点</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>特点</strong></th>\n<th><strong>顺序栈 (Sequential Stack)</strong></th>\n<th><strong>链式栈 (Linked Stack)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存储结构</strong></td>\n<td>基于数组实现</td>\n<td>基于链表实现</td>\n</tr>\n<tr>\n<td><strong>内存布局</strong></td>\n<td>内存连续</td>\n<td>内存不连续，元素间通过指针连接</td>\n</tr>\n<tr>\n<td><strong>内存管理</strong></td>\n<td>静态分配（可动态扩容）</td>\n<td>动态分配</td>\n</tr>\n<tr>\n<td><strong>空间效率</strong></td>\n<td>容量固定（可动态扩容，若超出初始容量则可能浪费空间）</td>\n<td>动态扩展，使用的空间与元素个数相匹配</td>\n</tr>\n<tr>\n<td><strong>访问速度</strong></td>\n<td>O(1) 时间复杂度</td>\n<td>O(1) 时间复杂度</td>\n</tr>\n<tr>\n<td><strong>空间复杂度</strong></td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td><strong>栈溢出</strong></td>\n<td>容易发生，尤其在固定容量情况下</td>\n<td>不易发生，除非系统内存耗尽</td>\n</tr>\n<tr>\n<td><strong>实现简单性</strong></td>\n<td>实现较为简单，适用于容量已知的情况</td>\n<td>实现复杂，需处理节点的动态分配与释放</td>\n</tr>\n<tr>\n<td><strong>元素访问</strong></td>\n<td>只能访问栈顶元素</td>\n<td>只能访问栈顶元素</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>适合对栈容量有明确限制的场景</td>\n<td>适合不确定栈容量，且需频繁变化元素的场景</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"顺序栈的基本操作\"><a href=\"#顺序栈的基本操作\" class=\"headerlink\" title=\"顺序栈的基本操作\"></a>顺序栈的基本操作</h3><ul>\n<li><p>定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STACK_INIT_SIZE 100 <span class=\"comment\">//存储空间初始分配量</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STACKINCREMENT 10 <span class=\"comment\">//存储空间分配增量</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  SELemType *base;</span><br><span class=\"line\">  SElemType *top;</span><br><span class=\"line\">  <span class=\"type\">int</span> stacksize; <span class=\"comment\">//栈的当前可使用的最大容量</span></span><br><span class=\"line\">&#125;SqStack;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">InitStack</span><span class=\"params\">(SqStack &amp;S)</span> &#123;</span><br><span class=\"line\">  S.base = (SElemType *)<span class=\"built_in\">malloc</span>(STACK_INIT_SIZE*<span class=\"keyword\">sizeof</span>(SElemType));</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!S.base) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">  S.top = S.base;</span><br><span class=\"line\">  S.stacksize = STACK_INIT_SIZE;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看栈顶元素</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">GetTop</span><span class=\"params\">(SqStack S, ElemType &amp;e)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(S.top == S.base) <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//栈空</span></span><br><span class=\"line\">  e = *(S.top<span class=\"number\">-1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>入栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 插入元素e为新的栈顶元素</span></span><br><span class=\"line\">Status <span class=\"title function_\">Push</span><span class=\"params\">(SqStack &amp;S, SElemType e)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(S.top - S.base &gt;= S.stacksize) &#123; <span class=\"comment\">//栈满，追加存储空间</span></span><br><span class=\"line\">    S.base = (SElemType *)<span class=\"built_in\">realloc</span>((S.stacksize+STACKINCREMENT)*<span class=\"keyword\">sizeof</span>(ElemType));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!S.base) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">    S.top = S.base + S.stacksize;</span><br><span class=\"line\">    S.stacksize +=STACKINCREMENT;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  *S.top ++ = e;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>出栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">Pop</span><span class=\"params\">(SqStack &amp;S, ElemType &amp;e)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(S.top == S.base) <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//栈空</span></span><br><span class=\"line\">  e = *--S.top;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>注</strong>：验证过<code>*S.top++ = e</code>和<code>e = *--S.top</code>，代码如下，输入结果为1。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *top;</span><br><span class=\"line\">    <span class=\"type\">int</span> *base;</span><br><span class=\"line\">    <span class=\"type\">int</span> stacksize;</span><br><span class=\"line\">&#125; SqStack;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    SqStack S;</span><br><span class=\"line\">    S.base = (<span class=\"type\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>*<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    S.top = S.base;</span><br><span class=\"line\">    *S.top ++ = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cout&lt;&lt;*--S.top&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>情况分析：<code>S.top = -1</code> 和 <code>S.top = 0</code>。注意：声明struct的时候，用的是<code>ElemType data[Maxsize]</code>，所以不要出现<code>top==Maxsize</code>时<code>S.data[top]</code>，先把top降掉。</p>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>属性</strong></th>\n<th><strong>当 <code>S.top = -1</code> 时</strong></th>\n<th><strong>当 <code>S.top = 0</code> 时</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>初始时</strong></td>\n<td><code>S.top = -1</code></td>\n<td><code>S.top = 0</code></td>\n</tr>\n<tr>\n<td><strong>栈的第一个元素</strong></td>\n<td><code>S.data[0]</code></td>\n<td><code>S.data[0]</code></td>\n</tr>\n<tr>\n<td><strong>栈顶指针指向</strong></td>\n<td>指向栈顶元素</td>\n<td>指向栈顶元素的后一个元素</td>\n</tr>\n<tr>\n<td><strong>栈满条件</strong></td>\n<td><code>top == MAX_SIZE - 1</code></td>\n<td><code>top == MAX_SIZE</code></td>\n</tr>\n<tr>\n<td><strong>栈空条件</strong></td>\n<td><code>top == -1</code></td>\n<td><code>top == 0</code></td>\n</tr>\n<tr>\n<td><strong>进栈操作</strong></td>\n<td><code>判栈满，S.data[++top] = x;</code></td>\n<td><code>判栈满，S.data[top++] = x;</code></td>\n</tr>\n<tr>\n<td><strong>出栈操作</strong></td>\n<td><code>判栈空，x = S.data[top--];</code></td>\n<td><code>判栈空，x = S.data[--top];</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"链栈的基本操作\"><a href=\"#链栈的基本操作\" class=\"headerlink\" title=\"链栈的基本操作\"></a>链栈的基本操作</h3><ul>\n<li><p>声明（王道）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Linknode</span> &#123;</span></span><br><span class=\"line\">  ElemType data;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Linknode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;ListStack;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>链栈通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。</p>\n</li>\n<li>这里规定链栈没有头结点，Lhead指向栈顶元素。</li>\n</ul>\n<h3 id=\"共享栈（考点没写）\"><a href=\"#共享栈（考点没写）\" class=\"headerlink\" title=\"共享栈（考点没写）\"></a>共享栈（考点没写）</h3><ul>\n<li>利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。</li>\n<li>共享栈时为了更有效地利用存储空间，两个栈的空间相互调节，只有再整个存储空间被占满时才发生上溢。</li>\n<li>其存取数据的时间复杂度均为O(1)，所以对存取效率没什么影响。</li>\n</ul>\n<table>\n  <tr>\n    <th>共享栈</th>\n    <th>0号栈</th>\n    <th>1号栈</th>\n  </tr>\n  <tr>\n    <td>初始时</td>\n    <td>top0 = -1</td>\n    <td>top1 = Maxsize</td>\n  </tr>\n  <tr>\n    <td>栈的第一个元素</td>\n    <td>S.data[0]</td>\n    <td>S.data[Maxsize]</td>\n  </tr>\n  <tr>\n    <td>栈顶指针指向</td>\n    <td>指向栈顶元素</td>\n    <td>指向栈顶元素</td>\n  </tr>\n  <tr>\n    <td>栈满条件</td>\n    <td colspan=\"2\">top1 - top0 == 1</td>\n  </tr>\n  <tr>\n    <td>栈空条件</td>\n    <td>top0 == -1，0号栈空</td>\n    <td>top1 == Maxsize，1号栈空</td>\n  </tr>\n  <tr>\n    <td>进栈操作</td>\n    <td>判栈满，S.data[++top0] = x;</td>\n    <td>判栈满，S.data[--top1] = x;</td>\n  </tr>\n  <tr>\n    <td>出栈操作</td>\n    <td>判栈空，x = S.data[top0--];</td>\n    <td>判栈空，x = S.data[top1++];</td>\n  </tr>\n</table>\n\n<h3 id=\"队列的定义\"><a href=\"#队列的定义\" class=\"headerlink\" title=\"队列的定义\"></a>队列的定义</h3><ul>\n<li><strong>队列（Queue）简称队，</strong>是一种先进先出（First In  First Out, FIFO）的线性表，它只允许在表的一端进行插入，而在另一端删除元素。</li>\n<li>这和我们日常生活中的排队是一致的，最早进入队列的元素最早离开。</li>\n<li><strong>队尾（Front）</strong>——允许插入的一端。</li>\n<li><strong>队头（Rear）</strong>——允许删除的一端。</li>\n<li><strong>空队列</strong>——不含任何元素的空表。</li>\n</ul>\n<h3 id=\"队列的逻辑结构\"><a href=\"#队列的逻辑结构\" class=\"headerlink\" title=\"队列的逻辑结构\"></a>队列的逻辑结构</h3><ul>\n<li>队列是一种操作受限的线性表，只允许在表的一端进行插入，而在另一端删除元素，服从先进先出原则。允许插入的一端叫做队尾，允许删除的一端称为队头，队列为空时无法进行出队操作。</li>\n</ul>\n<h3 id=\"队列的操作特性（考点没写）\"><a href=\"#队列的操作特性（考点没写）\" class=\"headerlink\" title=\"队列的操作特性（考点没写）\"></a>队列的操作特性（考点没写）</h3><ul>\n<li>先进先出（FIFO）</li>\n</ul>\n<h3 id=\"队列的特点\"><a href=\"#队列的特点\" class=\"headerlink\" title=\"队列的特点\"></a>队列的特点</h3><ul>\n<li><strong>先进先出（FIFO）</strong>：最先进入的元素最先被移除。</li>\n<li><strong>操作限制</strong>：只能在队列的尾部入队，头部出队。</li>\n<li><strong>队首元素</strong>：队首是当前可以访问和移除的元素。</li>\n<li><strong>空队列</strong>：队列为空时无法进行出队操作。</li>\n<li><strong>动态大小</strong>：可以根据需要扩展或收缩。</li>\n</ul>\n<h3 id=\"队列的基本操作\"><a href=\"#队列的基本操作\" class=\"headerlink\" title=\"队列的基本操作\"></a>队列的基本操作</h3><ul>\n<li><strong>入队（Push）</strong>：将一个元素添加到队列的尾部。</li>\n<li><strong>出队（Pop）</strong>：从队列的头部移除并返回一个元素。</li>\n<li><strong>取队首元素（Front）</strong>：返回队首的元素，但不删除它。</li>\n<li><strong>取队尾元素（Back）</strong>：返回队尾的元素，但不删除它。</li>\n<li><strong>队列判空（isEmpty）</strong>：判断队列中是否有元素。</li>\n<li><strong>获取队列长度（Size）</strong>：获取队列中有效元素个数。</li>\n</ul>\n<h3 id=\"顺序队列的定义\"><a href=\"#顺序队列的定义\" class=\"headerlink\" title=\"顺序队列的定义\"></a>顺序队列的定义</h3><ul>\n<li><strong>顺序队列：</strong>采用顺序存储的队列，利用一块连续的存储单元存放队列中的元素，并附设两个指针front和rear分别指示队头和队尾元素在顺序队列中的位置。</li>\n</ul>\n<h3 id=\"链式队列的定义\"><a href=\"#链式队列的定义\" class=\"headerlink\" title=\"链式队列的定义\"></a>链式队列的定义</h3><ul>\n<li><strong>链队列</strong>是队列的链式表示，它实际上是一个同时有队头指针和队尾指针的单链表。<strong>头指针</strong>指向队头结点，尾指针指向<strong>队尾结点</strong>。</li>\n</ul>\n<h3 id=\"顺序队列和链式队列的特点\"><a href=\"#顺序队列和链式队列的特点\" class=\"headerlink\" title=\"顺序队列和链式队列的特点\"></a>顺序队列和链式队列的特点</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>特点</th>\n<th>顺序队列</th>\n<th>链式队列</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存储结构</strong></td>\n<td>使用数组实现，连续存储元素</td>\n<td>使用链表实现，非连续存储元素</td>\n</tr>\n<tr>\n<td><strong>固定大小</strong></td>\n<td>队列的大小在创建时固定</td>\n<td>可以根据需要动态扩展</td>\n</tr>\n<tr>\n<td><strong>入队和出队效率</strong></td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><strong>空间浪费</strong></td>\n<td>可能存在未使用的数组空间</td>\n<td>无空间浪费</td>\n</tr>\n<tr>\n<td><strong>队满判断</strong></td>\n<td>需要判定是否队满</td>\n<td>不需要判定队满</td>\n</tr>\n<tr>\n<td><strong>额外开销</strong></td>\n<td>无额外开销</td>\n<td>每个元素需存储指针，空间开销较大</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"顺序队列的基本操作\"><a href=\"#顺序队列的基本操作\" class=\"headerlink\" title=\"顺序队列的基本操作\"></a>顺序队列的基本操作</h3><p>（例如，还有其他变换，比如=1）这四个变换是用来锻炼思维和熟练度的，理清楚就可以举一反三了。</p>\n<table border=\"1\" style=\"border-collapse: collapse; text-align: center; width: 100%; height: 100px;\">\n  <tr>\n    <td style=\"position: relative; width: 24%; height: 80px;\">\n      <div style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to top right, transparent 49%, black 50%, transparent 51%);\"></div>\n      <div style=\"position: absolute; bottom: 0; left: 0; width: 50%; height: 50%; display: flex; justify-content: center; align-items: center; font-size: 14px;\">\n        队头指针front\n      </div>\n      <div style=\"position: absolute; top: 0; right: 0; width: 50%; height: 50%; display: flex; justify-content: center; align-items: center; font-size: 14px;\">\n        队尾指针rear\n      </div>\n    </td>\n    <td style=\"font-size: 14px; width: 38%;\">① 指向队尾元素</td>\n    <td style=\"font-size: 14px; width: 38%;\">② 指向队尾元素的后一个位置</td>\n  </tr>\n  <tr>\n    <td style=\"font-size: 14px;\">① 指向队头元素</td>\n    <td>\n      <table border=\"1\" style=\"border: 2px solid; width: 100%; text-align: left;\">\n        <tr>\n          <td>初始时</td>\n          <td>Q.front=0; Q.rear=-1;</td>\n        </tr>\n        <tr>\n          <td>判空</td>\n          <td>Q.front==Q.rear+1</td>\n        </tr>\n        <tr>\n          <td>判满（若有限制长度为len）</td>\n          <td>Q.rear-Q.front==len-1</td>\n        </tr>\n        <tr>\n          <td>判再入队一个值，是否会“上溢出”</td>\n          <td>Q.rear+1>=Maxsize</td>\n        </tr>\n        <tr>\n          <td>进队</td>\n          <td>判“上溢出”和“满（若有）”，Q.rear++，赋值</td>\n        </tr>\n        <tr>\n          <td>出队</td>\n          <td>判空，取值，Q.front++</td>\n        </tr>\n      </table>\n    </td>\n    <td>\n      <table border=\"1\" style=\"border: 2px solid; width: 100%; text-align: left;\">\n        <tr>\n          <td>初始时</td>\n          <td>Q.front=Q.rear=0</td>\n        </tr>\n        <tr>\n          <td>判空</td>\n          <td>Q.front==Q.rear</td>\n        </tr>\n        <tr>\n          <td>判满（若有限制长度为len）</td>\n          <td>Q.rear-Q.front==len</td>\n        </tr>\n        <tr>\n          <td>判再入队一个值，是否会“上溢出”</td>\n          <td>Q.rear>=Maxsize</td>\n        </tr>\n        <tr>\n          <td>进队</td>\n          <td>判“上溢出”和“满（若有）”，赋值，Q.rear++</td>\n        </tr>\n        <tr>\n          <td>出队</td>\n          <td>判空，取值，Q.front++</td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"font-size: 14px;\">② 指向队头元素的前一个位置</td>\n    <td>\n      <table border=\"1\" style=\"border: 2px solid; width: 100%; text-align: left;\">\n        <tr>\n          <td>初始时</td>\n          <td>Q.front=-1; Q.rear=-1;</td>\n        </tr>\n        <tr>\n          <td>判空</td>\n          <td>Q.front==Q.rear</td>\n        </tr>\n        <tr>\n          <td>判满（若有限制长度为len）</td>\n          <td>Q.rear-Q.front==len</td>\n        </tr>\n        <tr>\n          <td>判再入队一个值，是否会“上溢出”</td>\n          <td>Q.rear+1>=Maxsize</td>\n        </tr>\n        <tr>\n          <td>进队</td>\n          <td>判“上溢出”和“满（若有）”，Q.rear++，赋值</td>\n        </tr>\n        <tr>\n          <td>出队</td>\n          <td>判空，Q.front++，取值</td>\n        </tr>\n      </table>\n    </td>\n    <td>\n      <table border=\"1\" style=\"border: 2px solid; width: 100%; text-align: left;\">\n        <tr>\n          <td>初始时</td>\n          <td>Q.front=-1; Q.rear=0;</td>\n        </tr>\n        <tr>\n          <td>判空</td>\n          <td>Q.front+1==Q.rear</td>\n        </tr>\n        <tr>\n          <td>判满（若有限制长度为len）</td>\n          <td>Q.rear-Q.front-1==len</td>\n        </tr>\n        <tr>\n          <td>判再入队一个值，是否会“上溢出”</td>\n          <td>Q.rear>=Maxsize</td>\n        </tr>\n        <tr>\n          <td>进队</td>\n          <td>判“上溢出”和“满（若有）”，赋值，Q.rear++</td>\n        </tr>\n        <tr>\n          <td>出队</td>\n          <td>判空，Q.front++，取值</td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n\n\n\n<h3 id=\"链队列的基本操作\"><a href=\"#链队列的基本操作\" class=\"headerlink\" title=\"链队列的基本操作\"></a>链队列的基本操作</h3><ul>\n<li>头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点。</li>\n<li><strong>不带头结点时</strong>，当<code>Q.front==NULL &amp;&amp; Q.rear==NULL</code>时，链式队列为空。</li>\n<li>入队时，建立一个新结点，将新结点插入到链表的尾部，并让Q.rear指向这个新插入的结点（若原队列为空队，则令Q.front也指向该结点 <strong>（带头结点时不用操作Q.front，因为它指向头结点）</strong>）。</li>\n<li>出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中摘除，并让Q.front指向下一个结点（若该结点为最后一个结点，则置Q.front和Q.rear都为NULL <strong>（带头结点时只需修改Q.front-&gt;next为下一个结点，Q.front不用动，Q.rear置为指向头结点）</strong>）。</li>\n<li>不难看出，不带头结点的链式队列在操作上往往比较麻烦，因此通常将链式队列设计成一个<strong>带头结点</strong>的单链表，<strong>这样插入和删除操作就统一了</strong>。</li>\n<li>用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。</li>\n<li>另外，假如程序中要使用多个队列，与多个栈的情形一样，最好使用链式队列，这样就不会出现存储分配不合理和“溢出”的问题。</li>\n<li><p>带头结点和不带头结点的操作是不一样的，要注意。</p>\n</li>\n<li><p>单链队列——队列的链式存储结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> &#123;</span></span><br><span class=\"line\">  QElemType data;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;QNode, *QueuePtr;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  QueuePtr front; <span class=\"comment\">//队头指针</span></span><br><span class=\"line\">  QueuePtr rear;</span><br><span class=\"line\">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">InitQueue</span> <span class=\"params\">(LinkQueue &amp;Q)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//构造一个空队列</span></span><br><span class=\"line\">  Q.front = Q.rear = (QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!Q.front) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">  Q.front -&gt; next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>销毁队列Q</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stauts <span class=\"title function_\">DestroyQueue</span> <span class=\"params\">(LinkQueue &amp;Q)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(Q.front) &#123;</span><br><span class=\"line\">    Q.rear = Q.front -&gt; next;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(Q.front);</span><br><span class=\"line\">    Q.front = Q.rear;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>入队——插入元素e为Q的新的队尾元素</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">EnQueue</span> <span class=\"params\">(LinkQueue &amp;Q, ElemType e)</span> &#123;</span><br><span class=\"line\">  p = (QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!p) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">  p -&gt; data = e;</span><br><span class=\"line\">  p -&gt; next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  Q.rear -&gt; next = p;</span><br><span class=\"line\">  Q.rear = p; <span class=\"comment\">//别忘记这句！！！</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>出队——若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">DeQueue</span><span class=\"params\">(LinkQueue &amp;Q, QElemType &amp;e)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(Q.front == Q.rear) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">  p = Q.front -&gt; next;</span><br><span class=\"line\">  e = p -&gt; data;</span><br><span class=\"line\">  Q.front -&gt; next = p -&gt; next;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(Q.rear == p) Q.rear = Q.front;</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"顺序存储结构中实现循环队列的具体要求\"><a href=\"#顺序存储结构中实现循环队列的具体要求\" class=\"headerlink\" title=\"顺序存储结构中实现循环队列的具体要求\"></a>顺序存储结构中实现循环队列的具体要求</h3><ul>\n<li>在顺序队列中，<code>Q.rear==Maxsize</code>并不能作为判断队列满的条件，但在此时如果再插入新的队尾元素，会发生数组越界问题；</li>\n<li>但此时又不宜像顺序栈那样通过 再分配 来扩大数组空间，因为队列的实际可用空间可能并未占满。这便是一种“假溢出”。</li>\n<li>为解决这种“假溢出”问题，引出了<strong>循环队列</strong>的概念。将顺序队列臆造为一个环状的空间，即把存储队列元素的表<strong>从逻辑上</strong>视为一个环，称为<strong>循环队列</strong>。</li>\n<li>当队首指针或队尾指针到达Maxsize-1后，若要再前进一个位置就自动到0，这里可以通过取模(%)的方式实现。</li>\n<li>初始时：Q.front=Q.rear=0</li>\n<li>队首指针进1：Q.front=(Q.front+1)%Maxszie</li>\n<li>队尾指针进1：Q.rear=(Q.rear+1)%Maxsize</li>\n<li>队列长度：(Q.rear+Maxsize-Q.front)%Maxsize</li>\n<li>出队入队时：指针都按顺时针方向进1</li>\n<li><p><strong>为了区分是队空还是堆满的情况，</strong>有3种处理方式：</p>\n<ol>\n<li>牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法，约定以“队头指针在队尾指针的下一个位置作为队满的标志”。<br>队满条件：(Q.rear+1)%Maxsize==Q.front；<br>队空条件：Q.front == Q.rear；<br>队列中元素的个数：(Q.rear-Q.front+Maxsize)%Maxsize。</li>\n<li>类型中增设size数据成员，表示元素个数。删除成功size—，插入成功size++。<br>队空条件：Q.size==0；<br>队满条件：Q.size==Maxsize。<br>两种情况都有Q.front==Q.rear。</li>\n<li>类型中增设tag数据成员，以区分是队满还是队空。<br>删除成功置tag=0，若导致Q.front==Q.rear，则为队空；<br>插入成功置tag=1，若导致Q.front==Q.rear，则为队满。</li>\n</ol>\n</li>\n<li><p>在C语言中不能用动态分配的一维数组来实现循环队列。如果用户的应用程序中设有循环队列，则必须为它设定一个最大队列长度；若用户无法预估所用的队列的最大长度，则宜采用链队列。</p>\n</li>\n<li>这里会有很多变式，考试的时候随机应变，用手模特殊值，然后换成未知量的形式来做题即可。主要是记住队尾rear是入队，队头front是出队。</li>\n</ul>\n<h4 id=\"循环队列——队列的顺序存储结构\"><a href=\"#循环队列——队列的顺序存储结构\" class=\"headerlink\" title=\"循环队列——队列的顺序存储结构\"></a>循环队列——队列的顺序存储结构</h4><ul>\n<li><p>类型声明</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXQSIZE 100 <span class=\"comment\">//最大队列长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  QElemType *base;</span><br><span class=\"line\">  <span class=\"type\">int</span> front;</span><br><span class=\"line\">  <span class=\"type\">int</span> rear;</span><br><span class=\"line\">&#125;SqQueue;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span> &#123;</span><br><span class=\"line\">  Q.base = (QElemType *)alloc(MAXQSIZE*<span class=\"keyword\">sizeof</span>(QElemType));</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!Q.base) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">  Q.front = Q.rear = <span class=\"number\">0</span>; <span class=\"comment\">//合法操作，在C语言中，赋值操作不仅会将值赋给变量，还会返回这个值本身</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回Q的元素个数，即队列的长度</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">QueueLength</span><span class=\"params\">(SqQueue Q)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (Q.rear-Q.front+MAXQSIZE)%MAXSIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>入队</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q, QElemType e)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>((Q.rear+<span class=\"number\">1</span>) % MAXQSIZE == Q.front) <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//队满</span></span><br><span class=\"line\">  Q.base[Q.rear] = e;</span><br><span class=\"line\">  Q.rear = (Q.rear + <span class=\"number\">1</span>) % MAXQSIZE;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>出队</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">DeQueue</span><span class=\"params\">(SqQueue &amp;Q, QElemType &amp;e)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(Q.front == Q.rear) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">  e = Q.base[Q.front];</span><br><span class=\"line\">  Q.front = (Q.front + <span class=\"number\">1</span>) % MAXQSIZE;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"理解递归调用和栈之间的关系\"><a href=\"#理解递归调用和栈之间的关系\" class=\"headerlink\" title=\"理解递归调用和栈之间的关系\"></a>理解递归调用和栈之间的关系</h3><ul>\n<li><strong>什么是递归？</strong><br>在数学及程序设计方法学中，若一个对象部分包含它自己，或者用它自己定义自己，则称这个对象是递归的；若一个过程直接或间接地调用自己，则称这个过程是递归的过程。</li>\n<li><strong>递归</strong>是一种重要的程序设计方法。简单地说，若在一个<u>函数、过程或数据结构</u>的定义中又应用了它自身，则这个<u>函数、过程、数据结构</u>被称为是递归定义的，简称递归。<br>它通常把一个大型的复杂问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的代码就可以描述出解题过程所需要的多次重复计算，<strong>大大减少了程序的代码量</strong>。但在通常情况下，<strong>它的效率并不是太高</strong>。</li>\n<li>一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做<strong>递归函数</strong>。</li>\n<li><p>栈还有一个重要作用是在程序设计语言中实现递归。（可见栈可以用来实现递归）</p>\n</li>\n<li><p>阶乘函数</p>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Fact</mtext><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>n</mi><mo>×</mo><mtext>Fact</mtext><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">\\text{Fact}(n) =\n\\begin{cases}\n1 &amp; \\text{if } n = 0 \\\\\nn \\times \\text{Fact}(n - 1) &amp; \\text{if } n &gt; 0\n\\end{cases}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Fact</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord text\"><span class=\"mord\">Fact</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// 0 的阶乘为 1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>); <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>Fibonacci数列</p>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Fibo</mtext><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>Fibo</mtext><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mtext>Fibo</mtext><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">\\text{Fibo}(n) =\n\\begin{cases}\n0 &amp; \\text{if } n = 0 \\\\\n1 &amp; \\text{if } n = 1 \\\\\n\\text{Fibo}(n - 1) + \\text{Fibo}(n - 2) &amp; \\text{if } n &gt; 1\n\\end{cases}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Fibo</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:4.32em;vertical-align:-1.91em;\"></span><span class=\"minner\"><span class=\"mopen\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.35em;\"><span style=\"top:-2.2em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎩</span></span></span><span style=\"top:-2.192em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span style=\"height:0.316em;width:0.8889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.8889em\" height=\"0.316em\" style=\"width:0.8889em\" viewBox=\"0 0 888.89 316\" preserveAspectRatio=\"xMinYMin\"><path d=\"M384 0 H504 V316 H384z M384 0 H504 V316 H384z\"/></svg></span></span><span style=\"top:-3.15em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎨</span></span></span><span style=\"top:-4.292em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span style=\"height:0.316em;width:0.8889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.8889em\" height=\"0.316em\" style=\"width:0.8889em\" viewBox=\"0 0 888.89 316\" preserveAspectRatio=\"xMinYMin\"><path d=\"M384 0 H504 V316 H384z M384 0 H504 V316 H384z\"/></svg></span></span><span style=\"top:-4.6em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎧</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.85em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.41em;\"><span style=\"top:-4.41em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-2.97em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-1.53em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Fibo</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord text\"><span class=\"mord\">Fibo</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.91em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.41em;\"><span style=\"top:-4.41em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span><span style=\"top:-2.97em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-1.53em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.91em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fibonacci</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// F(0) = 0</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// F(1) = 1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fibonacci(n - <span class=\"number\">1</span>) + fibonacci(n - <span class=\"number\">2</span>); <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Ackerman函数<br>Ackermann 函数的定义通常限制 m 和 n 为非负整数。</p>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Ack</mtext><mo stretchy=\"false\">(</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>m</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>Ack</mtext><mo stretchy=\"false\">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>m</mi><mo>&gt;</mo><mn>0</mn><mtext> and </mtext><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>Ack</mtext><mo stretchy=\"false\">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mtext>Ack</mtext><mo stretchy=\"false\">(</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>m</mi><mo>&gt;</mo><mn>0</mn><mtext> and </mtext><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">\\text{Ack}(m, n) =\n\\begin{cases}\nn + 1 &amp; \\text{if } m = 0 \\\\\n\\text{Ack}(m - 1, 1) &amp; \\text{if } m &gt; 0 \\text{ and } n = 0 \\\\\n\\text{Ack}(m - 1, \\text{Ack}(m, n - 1)) &amp; \\text{if } m &gt; 0 \\text{ and } n &gt; 0\n\\end{cases}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Ack</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:4.32em;vertical-align:-1.91em;\"></span><span class=\"minner\"><span class=\"mopen\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.35em;\"><span style=\"top:-2.2em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎩</span></span></span><span style=\"top:-2.192em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span style=\"height:0.316em;width:0.8889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.8889em\" height=\"0.316em\" style=\"width:0.8889em\" viewBox=\"0 0 888.89 316\" preserveAspectRatio=\"xMinYMin\"><path d=\"M384 0 H504 V316 H384z M384 0 H504 V316 H384z\"/></svg></span></span><span style=\"top:-3.15em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎨</span></span></span><span style=\"top:-4.292em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span style=\"height:0.316em;width:0.8889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.8889em\" height=\"0.316em\" style=\"width:0.8889em\" viewBox=\"0 0 888.89 316\" preserveAspectRatio=\"xMinYMin\"><path d=\"M384 0 H504 V316 H384z M384 0 H504 V316 H384z\"/></svg></span></span><span style=\"top:-4.6em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎧</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.85em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.41em;\"><span style=\"top:-4.41em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-2.97em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Ack</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span><span style=\"top:-1.53em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Ack</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">Ack</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">))</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.91em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.41em;\"><span style=\"top:-4.41em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span><span style=\"top:-2.97em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span><span class=\"mord text\"><span class=\"mord\"> and </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span><span style=\"top:-1.53em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span><span class=\"mord text\"><span class=\"mord\"> and </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.91em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ackermann</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (m != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            n = <span class=\"number\">1</span>; <span class=\"comment\">// 当 n 为 0 时，设置 n 为 1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 递归调用，使用一个栈来存储 m 和 n 的值</span></span><br><span class=\"line\">            n = ackermann(m, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m--; <span class=\"comment\">// 减小 m 的值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n + <span class=\"number\">1</span>; <span class=\"comment\">// 返回 n + 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归是程序设计中一个强有力的工具<ol>\n<li>很多数学函数是递归定义的，比如以上三种；</li>\n<li>有的数据结构，如<strong>二叉树、广义表</strong>等，由于结构本身固有的递归特性，则它们的操作可递归地描述；</li>\n<li>还有一类问题，虽然问题本身没有明显的递归结构，但用递归求解比迭代求解更简单，如<strong>八皇后问题、Hanoi塔问题</strong>等。</li>\n</ol>\n</li>\n<li><p>八皇后问题<br>八皇后问题是一个经典的回溯算法问题，其目标是在 8×8 的国际象棋棋盘上放置 8 个皇后，使得它们彼此之间不能互相攻击。皇后可以在同一行、同一列或对角线上攻击其他皇后。因此，解决八皇后问题的关键在于找到一种摆放方式，使得任意两个皇后不在同一行、同一列或同一对角线上。</p>\n<p><strong>问题描述：</strong></p>\n<ol>\n<li>将 8 个皇后放置在 8×8 的棋盘上。</li>\n<li>每一行放置一个皇后，最终找到一种摆放方案满足互不攻击的条件。</li>\n</ol>\n<p><strong>算法思路：</strong></p>\n<ol>\n<li>从第 1 行开始，每一行尝试放置一个皇后。</li>\n<li>对于当前行的每一列，检查该位置是否安全（即，不与前面的皇后冲突）。</li>\n<li>如果安全，则将皇后放置在该位置，递归地求解下一行。</li>\n<li>如果不安全或无法为下一行找到合法位置，则回溯到上一步，尝试在该行的下一个位置放置皇后。</li>\n</ol>\n<p><strong>判定位置安全性：</strong></p>\n<ol>\n<li>检查该列是否已有皇后。</li>\n<li>检查主对角线和副对角线上是否已有皇后（即，使用两条对角线数组记录状态）。</li>\n</ol>\n<p><strong>C语言实现</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N 8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> board[N]; <span class=\"comment\">// board[i] 表示第 i 行皇后所在的列索引</span></span><br><span class=\"line\"><span class=\"type\">int</span> solution_count = <span class=\"number\">0</span>; <span class=\"comment\">// 解的计数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断当前位置是否安全</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">isSafe</span><span class=\"params\">(<span class=\"type\">int</span> row, <span class=\"type\">int</span> col)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; row; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查列冲突和对角线冲突</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (board[i] == col || <span class=\"built_in\">abs</span>(board[i] - col) == <span class=\"built_in\">abs</span>(i - row)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归回溯求解八皇后问题</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">solve</span><span class=\"params\">(<span class=\"type\">int</span> row)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (row == N) &#123;</span><br><span class=\"line\">        solution_count++;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Solution %d:\\n&quot;</span>, solution_count);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; N; j++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(board[i] == j ? <span class=\"string\">&quot; Q &quot;</span> : <span class=\"string\">&quot; . &quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; N; col++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isSafe(row, col)) &#123;</span><br><span class=\"line\">            board[row] = col; <span class=\"comment\">// 放置皇后</span></span><br><span class=\"line\">            solve(row + <span class=\"number\">1</span>); <span class=\"comment\">// 递归放置下一行的皇后</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    solve(<span class=\"number\">0</span>); <span class=\"comment\">// 从第 0 行开始</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Total solutions: %d\\n&quot;</span>, solution_count);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>运行结果</strong><br>每种解法都会在棋盘上打印出 Q 表示皇后的位置，. 表示空位。最后输出总共找到的解的数量。</p>\n</li>\n<li><p>Hanoi塔问题<br>汉诺塔问题（Tower of Hanoi）是一个经典的递归问题，起源于一个古老的传说。假设有三根柱子和一组大小不同（最小圆盘编号为1，最大圆盘编号为n）的圆盘，圆盘一开始按从大到小的顺序（下面大，上面小）堆叠在第一根柱子上。目标是将所有圆盘移动到第三根柱子上，并满足以下规则：</p>\n<ol>\n<li>每次只能移动一个圆盘。</li>\n<li>圆盘只能放在柱子上，并且必须保持小圆盘在大圆盘之上。</li>\n</ol>\n<p><strong>问题描述</strong><br>给定 n 个圆盘，设柱子分别为 A、B 和 C，将圆盘从 A 移动到 C，并使用 B 作为辅助柱子。<br><strong>递归思路</strong><br>汉诺塔问题可以用递归解决，通过将问题分解为子问题逐步求解：</p>\n<ol>\n<li>基本情况：当只有一个圆盘时，直接将圆盘从 A 移动到 C。</li>\n<li>递归情况：<br>(1) 先将 n-1 个圆盘从 A 移动到 B（使用 C 作为辅助柱）。<br>(2) 将第 n 个圆盘从 A 移动到 C。<br>(3) 将 n-1 个圆盘从 B 移动到 C（使用 A 作为辅助柱）。<br>每次递归地解决 n-1 个圆盘的子问题，直到所有圆盘都被移动到目标柱上。<br><strong>C语言实现</strong></li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">hanoi</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">char</span> from, <span class=\"type\">char</span> to, <span class=\"type\">char</span> aux)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Move disk 1 from %c to %c\\n&quot;</span>, from, to);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hanoi(n - <span class=\"number\">1</span>, from, aux, to);  <span class=\"comment\">// 将 n-1 个盘子从 from 移到 aux</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Move disk %d from %c to %c\\n&quot;</span>, n, from, to); <span class=\"comment\">// 将第 n 个盘子移到目标柱</span></span><br><span class=\"line\">    hanoi(n - <span class=\"number\">1</span>, aux, to, from);  <span class=\"comment\">// 将 n-1 个盘子从 aux 移到 to</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Enter the number of disks: &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    hanoi(n, <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>输出示例</strong><br>若n=3</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Move disk 1 from A to C</span><br><span class=\"line\">Move disk 2 from A to B</span><br><span class=\"line\">Move disk 1 from C to B</span><br><span class=\"line\">Move disk 3 from A to C</span><br><span class=\"line\">Move disk 1 from B to A</span><br><span class=\"line\">Move disk 2 from B to C</span><br><span class=\"line\">Move disk 1 from A to C</span><br></pre></td></tr></table></figure>\n<p><strong>时间复杂度</strong><br>汉诺塔问题的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(2^n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，因为每次增加一个盘子，操作数会翻倍。因此，汉诺塔问题适合用递归解法，但当 n 很大时计算量会非常大。</p>\n</li>\n<li>利用栈实现递归调用<br>（gpt给出的）<br><strong>递归调用的定义：</strong><br>递归是一种编程技术，其中一个函数直接或间接地调用自身。递归通常由两个部分组成：<strong>基例（终止条件）</strong>和<strong>递归步骤（即函数如何调用自身）</strong>。<br><strong>栈的作用：</strong><br>在计算机中，递归调用会使用调用栈（Call Stack）来管理函数调用。每当一个函数被调用时，系统会将<strong>该函数的状态（包括参数、局部变量、返回地址等）</strong>压入栈中。当函数执行完毕后，状态会从栈中弹出，<strong>并返回到调用该函数的位置</strong>。<br><strong>栈的增长：</strong><br>当递归调用发生时，每次调用都会在栈上增加一个新的帧（Frame）（调用栈中的每一层，它包含了特定函数调用的所有信息，如参数、局部变量、返回地址等）。如果递归深度较大，栈的空间可能会被耗尽，导致栈溢出（Stack Overflow）错误。<br><strong>基例的重要性：</strong><br>基例是防止无限递归的重要机制。如果没有适当的基例，递归会不断调用自身，直到耗尽栈空间。<br><strong>步骤：</strong><ol>\n<li>初始化栈：创建一个栈，用于存储待处理的函数状态（如参数和局部变量）。</li>\n<li>入栈操作：将初始参数（或状态）压入栈中。</li>\n<li>循环处理：使用循环来处理栈中的元素：<br>(1) 从栈中弹出一个状态。<br>(2) 检查是否满足基例（一个或多个不需要再次递归的情况），如果满足，则处理结果（例如返回值）。<br>(3) 如果不满足基例，计算递归步骤，并将新的状态（参数）压入栈中。</li>\n<li>返回结果：继续处理直到栈为空，最终返回结果。<br>（书上的说法↓）<br>为了保证递归函数正确执行，系统需设立一个“递归工作栈”作为整个递归函数运行期间使用的数据存储区。每一层递归所需信息构成一个“工作记录”，其中包括所有的实在参数、所有的局部变量以及上一层的返回地址。每进入一层递归，就从栈顶弹出一个工作记录，则当前执行层的工作记录必是递归工作栈栈顶的工作记录，称这个记录为“活动记录”，并称指示活动记录的栈顶指针为“当前环境指针”。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"掌握栈和队列的经典应用\"><a href=\"#掌握栈和队列的经典应用\" class=\"headerlink\" title=\"掌握栈和队列的经典应用\"></a>掌握栈和队列的经典应用</h3><h4 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h4><ul>\n<li>递归调用↑</li>\n<li>数制转换<br>十进制→八进制：从低位到高位产生八进制数的各个数位，从高位到地位顺序输出。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">conversion</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  InitStack(S);</span><br><span class=\"line\">  <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;N);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(N) &#123;</span><br><span class=\"line\">    Push(S, N % <span class=\"number\">8</span>);</span><br><span class=\"line\">    N = N / <span class=\"number\">8</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!StackEmpty(S)) &#123;</span><br><span class=\"line\">    Pop(S, e);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>括号匹配的检验</li>\n</ul>\n<ol>\n<li>在算法中设置一个栈，每读入一个括号，若是右括号，则要么使置于栈顶的最急迫的期待得以消解，要么是不合法的情况；</li>\n<li>若是左括号，则作为一个新的更急迫的期待压入栈中，自然使原有的在栈中的所有未消解的期待的急迫性都降了一级。</li>\n<li>另外，在算法的开始和结束时，栈都应该是空的。</li>\n</ol>\n<ul>\n<li>行编辑程序<br>一个简单的行编辑程序的功能是：接受用户的从终端输入的程序或数据，并存入用户的数据区。由于用户在终端上进行输入时，不能保证不出差错，因此，若在编辑程序中，“每接受一个字符即存入用户数据区”的做法显然不是最恰当的。<br>较好的做法是，设立一个输入缓冲区，用以接受用户输入的一行字符，然后逐行存入用户数据区。允许用户输入出差错，并在发现有误时可以及时更正。<br>例如，当用户发现刚刚键入的一个字符是错的时，可补进一个退格符“#”，以表示前一个字符无效；如果发现当前键入的行内差错较多或难以补救，则可以键入一个退行符“@”，以表示当前行中的字符均无效。<br>例如，假设从终端接受了这样的两行字符：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whli##ilr#e(s#*s)</span><br><span class=\"line\">  outcha@putchar(*s++);</span><br></pre></td></tr></table></figure>\n<p>则实际有效的是下列两行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(*s)</span><br><span class=\"line\">  putchar(*s++);</span><br></pre></td></tr></table></figure>\n<p>为此，可设这个输入缓冲区为一个栈结构，每当从终端接受了一个字符之后先作如下判别：</p>\n<ol>\n<li>如果它既不是退格符也不是退行符，则将该字符压入栈顶；</li>\n<li>如果是一个退格符，则从栈顶删去一个字符；</li>\n<li>如果它是一个退行符，则将字符栈清为空栈。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LineEdit</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  InitStack(S);</span><br><span class=\"line\">  ch = getchar(); <span class=\"comment\">//从终端接收第一个字符</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(ch!=EOF) &#123; <span class=\"comment\">//EOF为全文结束符</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch!=EOF&amp;&amp;ch!=<span class=\"string\">&#x27;\\n&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span>(ch) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;#&#x27;</span>: Pop(S, c); <span class=\"keyword\">break</span>; <span class=\"comment\">//仅当栈非空时退栈</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;@&#x27;</span>: ClearStack(S); <span class=\"keyword\">break</span>; <span class=\"comment\">//重置S为空栈</span></span><br><span class=\"line\">        <span class=\"keyword\">default</span>: Push(S,ch); <span class=\"keyword\">break</span>; <span class=\"comment\">//有效字符进栈，未考虑栈满情形</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      ch = getchar(); <span class=\"comment\">//从终端接收下一个字符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    将从栈底到栈顶的栈内字符传送至调用过程的数据区;</span><br><span class=\"line\">    ClearStack(S); <span class=\"comment\">//重置S为空栈</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ch != EOF) ch = getchar();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  DestroyStack(S);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>迷宫求解<br>BFS用队列，DFS用栈。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//BFS</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> directions[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">isValid</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">int</span> n, <span class=\"type\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;&gt;&amp; maze, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;&gt;&amp; visited)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &gt;= <span class=\"number\">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class=\"number\">0</span> &amp;&amp; y &lt; m &amp;&amp; maze[x][y] == <span class=\"number\">0</span> &amp;&amp; !visited[x][y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">bfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;&gt;&amp; maze)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = maze.size();</span><br><span class=\"line\">    <span class=\"type\">int</span> m = maze[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;&gt; visited(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(m, <span class=\"literal\">false</span>));</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Starting point</span></span><br><span class=\"line\">    q.push(&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">    visited[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> steps = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> size = q.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> [x, y] = q.front();</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Check if we reached the end</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x == n - <span class=\"number\">1</span> &amp;&amp; y == m - <span class=\"number\">1</span>) <span class=\"keyword\">return</span> steps;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; dir : directions) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> nx = x + dir[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> ny = y + dir[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isValid(nx, ny, n, m, maze, visited)) &#123;</span><br><span class=\"line\">                    q.push(&#123;nx, ny&#125;);</span><br><span class=\"line\">                    visited[nx][ny] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        steps++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// If there&#x27;s no path to the destination</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//DFS</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> directions[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;&gt;&amp; maze, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;&gt;&amp; visited, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">int</span> n, <span class=\"type\">int</span> m)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If out of bounds or not a path, return false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span> || x &gt;= n || y &lt; <span class=\"number\">0</span> || y &gt;= m || maze[x][y] == <span class=\"number\">1</span> || visited[x][y]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check if reached destination</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == n - <span class=\"number\">1</span> &amp;&amp; y == m - <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    visited[x][y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; dir : directions) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> nx = x + dir[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> ny = y + dir[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dfs(maze, visited, nx, ny, n, m)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// Path found</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// No path found from this cell</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">hasPathDFS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;&gt;&amp; maze)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = maze.size();</span><br><span class=\"line\">    <span class=\"type\">int</span> m = maze[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;&gt; visited(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(m, <span class=\"literal\">false</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(maze, visited, <span class=\"number\">0</span>, <span class=\"number\">0</span>, n, m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//书上写的（用栈）</span></span><br><span class=\"line\"><span class=\"comment\">//看不下去，太乱了</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>表达式求值<br><code>#</code>是表达式的结束符，为了算法简洁，在表达式的最左边也虚设一个<code>#</code>构成整个表达式的一对括号。<br><code>(</code>和<code>)</code>相遇时，表示括号内的运算已经完成，<code>#</code>和<code>#</code>相遇时表示整个表达式求值完毕。<br>两个工作栈，OPTR寄存运算符，OPND寄存操作数或运算结果。<br>对算术表达式<code>3*(7-2)</code>求值</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th><code>OPTR</code> 栈</th>\n<th><code>OPND</code> 栈</th>\n<th>输入字符</th>\n<th>主要操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><code>#</code></td>\n<td></td>\n<td>3*(7-2)#</td>\n<td><code>PUSH(OPND, &#39;3&#39;)</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>#</code></td>\n<td>3</td>\n<td>*(7-2)#</td>\n<td><code>PUSH(OPTR, &#39;*&#39;)</code></td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>#*</code></td>\n<td>3</td>\n<td>(7-2)#</td>\n<td><code>PUSH(OPTR, &#39;(&#39;)</code></td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>#*(</code></td>\n<td>3</td>\n<td>7-2)#</td>\n<td><code>PUSH(OPND, &#39;7&#39;)</code></td>\n</tr>\n<tr>\n<td>5</td>\n<td><code>#*(</code></td>\n<td>3 7</td>\n<td>-2)#</td>\n<td><code>PUSH(OPTR, &#39;-&#39;)</code></td>\n</tr>\n<tr>\n<td>6</td>\n<td><code>#*(-</code></td>\n<td>3 7</td>\n<td>2)#</td>\n<td><code>PUSH(OPND, &#39;2&#39;)</code></td>\n</tr>\n<tr>\n<td>7</td>\n<td><code>#*(-</code></td>\n<td>3 7 2</td>\n<td>)#</td>\n<td><code>OPERATE(&#39;7&#39;, &#39;-&#39;, &#39;2&#39;)</code></td>\n</tr>\n<tr>\n<td>8</td>\n<td><code>#*(</code></td>\n<td>3 5</td>\n<td>)#</td>\n<td><code>POP(OPTR)&#123;消去一对括号&#125;</code></td>\n</tr>\n<tr>\n<td>9</td>\n<td><code>#*</code></td>\n<td>3 5</td>\n<td>#</td>\n<td><code>OPERATE(&#39;3&#39;, &#39;*&#39;, &#39;5&#39;)</code></td>\n</tr>\n<tr>\n<td>10</td>\n<td><code>#</code></td>\n<td>15</td>\n<td>#</td>\n<td><code>RETURN(GETTOP(OPND))</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>前缀、中缀、后缀表达式（书p129）<br>前缀表达式：- + A <em> B - C D / E F<br>中缀表达式：A + B </em> (C - D) - E / F<br>后缀表达式：A B C D - * + E F / -<br>前缀、中缀、后缀表达式分别对应表达式树的先序、中序、后序遍历。中缀表达式的括号是必须的。</li>\n</ul>\n<p><strong>转换中缀表达式为前缀表达式的步骤</strong></p>\n<ol>\n<li>首先构造一个运算符栈（也可放置括号），栈中的运算符（以括号为分界点）按照<strong>越往栈顶优先级不降低</strong>的原则进行排列。</li>\n<li>从右至左扫描中缀表达式，从右边第一个字符开始判断：<ul>\n<li>如果当前字符是数字，则分析到数字串的结尾并将数字串直接输出。</li>\n<li>如果是运算符，则比较优先级：<ul>\n<li>如果当前运算符的<strong>优先级大于等于</strong>栈顶运算符的优先级（当栈顶是括号时，直接入栈），则将运算符直接<strong>入栈</strong>。</li>\n<li>否则，将栈顶运算符出栈并输出，直到当前运算符的优先级大于等于栈顶运算符的优先级（当栈顶是括号时，直接入栈），再将当前运算符入栈。</li>\n</ul>\n</li>\n<li>如果是括号，则根据括号的方向进行处理：<ul>\n<li>如果是右括号，则直接入栈；</li>\n<li>否则，在遇到左括号之前，将所有的运算符全部出栈并输出；遇到右括号后将左右括号一起出栈（但不输出）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>重复步骤 2，直到扫描结束，将栈内剩余运算符全部出栈并输出。最后逆序输出字符串，中缀表达式就转换为前缀表达式了。</li>\n</ol>\n<p><strong>转换示例表格</strong><br>将中缀表达式“1+((2+3)*4)-5”转换为前缀表达式。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>中缀表达式</th>\n<th>前缀表达式</th>\n<th>运算符栈（栈顶）</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5</td>\n<td>5</td>\n<td>空</td>\n<td><code>5</code> 是数字串，直接输出</td>\n</tr>\n<tr>\n<td>-</td>\n<td>5</td>\n<td>-</td>\n<td><code>-</code> 栈内无运算符，直接入栈</td>\n</tr>\n<tr>\n<td>)</td>\n<td>5</td>\n<td>- )</td>\n<td><code>)</code> 直接入栈</td>\n</tr>\n<tr>\n<td>4</td>\n<td>5 4</td>\n<td>- )</td>\n<td><code>4</code> 是数字串，直接输出</td>\n</tr>\n<tr>\n<td>*</td>\n<td>5 4</td>\n<td>- ) *</td>\n<td><code>*</code> 栈顶是括号，直接入栈</td>\n</tr>\n<tr>\n<td>)</td>\n<td>5 4</td>\n<td>- ) * )</td>\n<td><code>)</code> 直接入栈</td>\n</tr>\n<tr>\n<td>3</td>\n<td>5 4 3</td>\n<td>- ) * )</td>\n<td><code>3</code> 是数字串，直接输出</td>\n</tr>\n<tr>\n<td>+</td>\n<td>5 4 3</td>\n<td>- ) * ) +</td>\n<td><code>+</code> 栈顶是括号，直接入栈</td>\n</tr>\n<tr>\n<td>2</td>\n<td>5 4 3 2</td>\n<td>- ) * ) +</td>\n<td><code>2</code> 是数字串，直接输出</td>\n</tr>\n<tr>\n<td>(</td>\n<td>5 4 3 2 +</td>\n<td>- ) *</td>\n<td><code>(</code> 抵消栈中最后一个 <code>)</code> 并释放它们之间的 <code>+</code></td>\n</tr>\n<tr>\n<td>(</td>\n<td>5 4 3 2 + *</td>\n<td>-</td>\n<td><code>(</code> 抵消方法同上</td>\n</tr>\n<tr>\n<td>+</td>\n<td>5 4 3 2 + *</td>\n<td>- +</td>\n<td><code>+</code> 优先级大于等于栈顶运算符，直接入栈</td>\n</tr>\n<tr>\n<td>1</td>\n<td>5 4 3 2 + * 1</td>\n<td>- +</td>\n<td><code>1</code> 是数字串，直接输出</td>\n</tr>\n<tr>\n<td>空</td>\n<td>5 4 3 2 + * 1 + -</td>\n<td>空</td>\n<td>扫描结束，将栈内剩余运算符全部出栈并输出</td>\n</tr>\n<tr>\n<td>空</td>\n<td>- + 1 * + 2 3 4 5</td>\n<td>空</td>\n<td>逆序输出字符串</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>中缀表达式转后缀表达式的步骤</strong></p>\n<ol>\n<li>设定一个运算符栈。</li>\n<li>假设表达式的结束符为 <code>#</code>，并预设运算符栈底元素也为 <code>#</code>。</li>\n<li>扫描表达式，按以下规则处理每个字符：<ul>\n<li>如果当前字符是操作数，则直接添加到后缀表达式中。</li>\n<li>如果当前字符是运算符且优先级<strong>高于</strong>栈顶运算符，则将其入栈；否则，将从栈顶开始，依次<strong>弹出</strong>栈中<strong>优先级高于或等于</strong>当前运算符的所有运算符，并加入后缀表达式，然后将当前运算符入栈。</li>\n<li>如果当前字符是结束符 <code>#</code>，则依次将栈中剩余的运算符出栈并添加到后缀表达式。</li>\n<li>如果当前字符是左括号 <code>(</code>，则直接入栈。</li>\n<li>如果当前字符是右括号 <code>)</code>，则从栈顶开始，依次将运算符出栈并添加到后缀表达式，直到遇到左括号 <code>(</code>。将 <code>(</code> 出栈，但不添加到后缀表达式中，然后继续扫描表达式。</li>\n</ul>\n</li>\n</ol>\n<p>（详见gpt和王道p93，书上没看到有写,2018真题有考小题目）</p>\n<h4 id=\"队列的应用\"><a href=\"#队列的应用\" class=\"headerlink\" title=\"队列的应用\"></a>队列的应用</h4><ul>\n<li>离散事件模拟<br>书p65。讲的是模拟银行业务，不同的客户在随机时间到达，如果前边有其他客户还在办理业务则需要等待。计算客户的平均逗留时间。<br>每个窗口都被设置成一个<strong>队列</strong>，客户到达银行时排队排在人数最少的那个队伍后边。总之就是用到了<strong>队列</strong>。</li>\n<li>队列在层次遍历（BFS）中需要用到。</li>\n<li>数据缓冲区</li>\n<li><p>CPU（即中央处理器，它包括运算器和控制器）资源的竞争。在一个带有多终端的计算机系统上，有多个用户需要CPU各自运行自己的程序，它们分别通过各自的终端向操作系统提出占用CPU的请求。操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个<strong>队列</strong>，每次把CPU分配给队首请求的用户使用。当相应的程序运行结束或用完规定的时间间隔后，令其出队，再把CPU分配给新的队首请求的用户使用。这样既满足每个用户的请求，又使CPU能够正常运行。</p>\n</li>\n<li><p>（看一下书p49、p65，王道里也有内容别忘记）</p>\n</li>\n</ul>\n<h2 id=\"五、二叉树、树和森林\"><a href=\"#五、二叉树、树和森林\" class=\"headerlink\" title=\"五、二叉树、树和森林\"></a>五、二叉树、树和森林</h2><h3 id=\"二叉树、树、森林的定义以及它们之间的异同点\"><a href=\"#二叉树、树、森林的定义以及它们之间的异同点\" class=\"headerlink\" title=\"二叉树、树、森林的定义以及它们之间的异同点\"></a>二叉树、树、森林的定义以及它们之间的异同点</h3><h4 id=\"二叉树的定义\"><a href=\"#二叉树的定义\" class=\"headerlink\" title=\"二叉树的定义\"></a>二叉树的定义</h4><ul>\n<li><strong>二叉树</strong>是一种树型结构，它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。</li>\n</ul>\n<ol>\n<li>二叉树可以为<strong>空</strong>，或由一个根节点和两个互不相交的分别被称为左子树和右子树的二叉树组成。</li>\n<li>二叉树是有序树。<br>(1) 若将其左、右子树颠倒，则成为另一棵不同的二叉树。<br>(2) 即使树中结点只有一棵子树，也要区分它是左子树还是右子树。</li>\n<li>二叉树与度为2的有序树的区别：<br>(1) 度为2的树至少有3个结点（因为至少要有一个结点的度为2）。<br>(2) 度为2的有序树，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序；而二叉树不管孩子是否是2个，都区分次序。</li>\n<li>非空二叉树上的<strong>叶结点数</strong>等于<strong>度为2的结点数</strong>加<strong>1</strong>，即n0=n2+1。<blockquote>\n<p><strong>证明：</strong> ①结点总数n=n0+n1+n2 ②除根节点外，其余结点都有一个<strong>分支进入</strong>，n=B（分支总数）+1 ③这些分支是由度为1或2的结点<strong>射出</strong>的，B=n1+2n2 ④n0+n1+n2=n1+2n2+1，则n0=n2+1。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li><strong>度为m的树和m叉树的区别</strong><br>度为m的树：至少有一个节点的度为m。<br>m叉树：允许所有节点的度&lt;m，可以是空树。</li>\n</ul>\n<table>\n  <tr>\n    <th style=\"text-align: center;\"></th>\n    <th style=\"text-align: center;\">度为 m</th>\n    <th style=\"text-align: center;\">m 叉树</th>\n  </tr>\n  <tr>\n    <td style=\"text-align: center;\">结点数与度数</td>\n    <td colspan=\"2\" style=\"text-align: center;\">结点数 = 度数 + 1</td>\n  </tr>\n  <tr>\n    <td style=\"text-align: center;\">第 i 层上结点数</td>\n    <td colspan=\"2\" style=\"text-align: center;\">第 i 层上最多有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">m^{i-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点（<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i \\geq 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7955em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>）</td>\n  </tr>\n  <tr>\n    <td style=\"text-align: center;\">高度为 h，总结点数</td>\n    <td colspan=\"2\" style=\"text-align: center;\">至多有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{m^h - 1}{m - 1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.4463em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0429em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.927em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 个结点</td>\n  </tr>\n  <tr>\n    <td style=\"text-align: center;\"><b>高度为 h，总结点数</b></td>\n    <td style=\"text-align: center;\"><b>至少有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">h + m - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 个结点</b></td>\n    <td style=\"text-align: center;\"><b>至少有 h 个结点</b></td>\n  </tr>\n  <tr>\n    <td style=\"text-align: center;\">有 n 个结点，</td>\n    <td colspan=\"2\" style=\"text-align: center;\">最小高度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>m</mi></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil \\log_m(n(m - 1) + 1) \\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mop\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0573em;\"><span style=\"top:-2.4559em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2441em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)⌉</span></span></span></span>，根据<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≤</mo><mfrac><mrow><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">n \\leq \\frac{m^h - 1}{m - 1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.4463em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0429em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.927em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>得出</td>\n  </tr>\n  <tr>\n    <td style=\"text-align: center;\"><b>有 n 个结点，</b></td>\n    <td style=\"text-align: center;\"><b>最大高度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n - m + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></b></td>\n    <td style=\"text-align: center;\"><b>最大高度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></b></td>\n  </tr>\n</table>\n\n<ul>\n<li><strong>满二叉树</strong><br>一棵高度为h，且有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^h-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9324em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>个结点的二叉树称为<strong>满二叉树</strong>，即二叉树中的每层都含有最多的结点。<br>（与树相似，二叉树也以递归的形式定义）</li>\n</ul>\n<ol>\n<li><strong>叶结点</strong>都集中在二叉树的<strong>最下一层</strong></li>\n<li>除叶结点外的每个结点<strong>度数均为2</strong>。</li>\n<li>可以按照层次对满二叉树进行编号，自上而下，自左向右。对于编号为<code>i</code>的结点，<ul>\n<li>若有双亲（<code>i&gt;1</code>），则其<strong>双亲</strong>为<code>⌊i/2⌋</code></li>\n<li>若有左孩子，则其<strong>左孩子</strong>为<code>2i</code></li>\n<li>若有有孩子，则其<strong>右孩子</strong>为<code>2i+1</code></li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/articles/9eb01842/满二叉树.jpg\" /></p>\n<ul>\n<li><strong>完全二叉树</strong><br>高度为h，有n个结点的二叉树，<strong>当且仅当</strong>其每个结点都与高度为h的<strong>满二叉树</strong>中编号为1～n的结点<strong>一一对应</strong>时，称为<strong>完全二叉树</strong>。</li>\n</ul>\n<ol>\n<li>若<code>i≤⌊n/2⌋</code>，则结点<code>i</code>为<strong>分支节点</strong>，<u>否则为叶结点</u>。</li>\n<li><strong>叶结点</strong>只可能在<strong>层次最大的两层上</strong>出现。对于<strong>最大层次</strong>中的叶结点，都依次排列在该层<strong>最左边</strong>的位置上。</li>\n<li>若有<strong>度为1的结点</strong>，则<strong>最多只可能有一个</strong>，且该结点<strong>只有左孩子</strong>而无右孩子。</li>\n<li><strong>按层次编号后</strong>，一旦出现某结点（编号为i）<strong>为叶结点或只有左孩子</strong>，则<strong>编号大于i</strong>的结点均为<strong>叶结点</strong>。</li>\n<li>若<strong>n为奇数</strong>，则<strong>每个分支节点都有左孩子和右孩子</strong>；若<strong>n为偶数</strong>，则编号最大的分支节点（编号为<strong>n/2</strong>）<strong>只有左孩子</strong>，没有右孩子，其余分支节点左、右孩子都有。</li>\n<li>（和满二叉树一样）对于编号为<code>i</code>的结点，<ul>\n<li>若有双亲（<code>i&gt;1</code>），则其<strong>双亲</strong>为<code>⌊i/2⌋</code></li>\n<li>若有左孩子，则其<strong>左孩子</strong>为<code>2i</code></li>\n<li>若有有孩子，则其<strong>右孩子</strong>为<code>2i+1</code></li>\n</ul>\n</li>\n<li>结点<code>i</code>所在层次（深度）为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil log_2(i+1) \\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)⌉</span></span></span></span>或<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>i</mi><mo stretchy=\"false\">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\lfloor log_2 i \\rfloor + 1 </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">⌋</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>（情况与8一致，证明见下）</li>\n<li>有n(n&gt;0)个结点的完全二叉树的高度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil log_2(n+1) \\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)⌉</span></span></span></span>或<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\lfloor log_2 n \\rfloor + 1 </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">⌋</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。<blockquote>\n<p><strong>证明：</strong>①<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>&lt;</mo><mi>n</mi><mo>≤</mo><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn><mtext>或者</mtext><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≤</mo><mi>n</mi><mo>&lt;</mo><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^{h-1}-1 &lt; n \\leq 2^h-1 或者 2^{h-1} \\leq n &lt; 2^h </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9324em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">h</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9324em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9851em;vertical-align:-0.136em;\"></span><span class=\"mord\">1</span><span class=\"mord cjk_fallback\">或者</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">h</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span></span></span></span> ②得<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>≤</mo><msup><mn>2</mn><mi>h</mi></msup><mo separator=\"true\">,</mo><mtext>  </mtext><mi>h</mi><mo>−</mo><mn>1</mn><mo>&lt;</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>≤</mo><mi>h</mi><mtext>  </mtext><mtext>或者得</mtext><mtext>  </mtext><mi>h</mi><mo>−</mo><mn>1</mn><mo>≤</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>&lt;</mo><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">2^{h-1} &lt; n+1 \\leq 2^h, \\; h-1 &lt; log_2 (n+1) \\leq h \\; 或者得 \\; h-1 \\leq log_2 n &lt; h </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8882em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">h</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0435em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord cjk_fallback\">或者得</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span> ③∴ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mo>=</mo><mo stretchy=\"false\">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">⌉</mo><mtext>或者</mtext><mi>h</mi><mo>=</mo><mo stretchy=\"false\">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">h=\\lceil log_2(n+1) \\rceil 或者 h=\\lfloor log_2 n \\rfloor +1 </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)⌉</span><span class=\"mord cjk_fallback\">或者</span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">⌋</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"/articles/9eb01842/完全二叉树.jpg\" /></p>\n<ul>\n<li><p><strong>二叉排序树</strong><br>左子树上所有结点的关键字均小于根节点的关键字；右子树上所有结点的关键字均大于根节点的关键字；左子树和右子树又各是一棵二叉排序树。</p>\n</li>\n<li><p><strong>平衡二叉树</strong><br>树中任意一个结点的左子树和右子树的高度之差的绝对值不超过1。</p>\n</li>\n<li><p><strong>正则二叉树</strong><br>树中每个分支结点都有2个孩子，即<strong>树中只有度为0或2的结点</strong>。</p>\n</li>\n</ul>\n<h4 id=\"树的定义\"><a href=\"#树的定义\" class=\"headerlink\" title=\"树的定义\"></a>树的定义</h4><ul>\n<li>树是n(n≥0)个结点的有限集。当n=0时，称为<strong>空树</strong>。</li>\n<li>在任意一个非空树中应满足：<ol>\n<li>有且仅有一个特定的称为<strong>根</strong>的结点。</li>\n<li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">T_1,T_2,\\cdots,T_m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，其中每个集合本身又是一棵树，并且称为根的<strong>子树</strong>。</li>\n</ol>\n</li>\n<li>显然，树的定义是递归的（二叉树也是），即<strong>在树的定义中又用到了其自身</strong>，树是一种递归的数据结构。树作为一种<strong>逻辑结构</strong>，同时也是一种<strong>分层结构</strong>，具有以下两个特点：<ol>\n<li>树的根节点没有前驱，除根节点外的所有结点有且只有一个前驱。</li>\n<li>树中所有结点都可以有零个或多个后继。</li>\n</ol>\n</li>\n<li><p>树适用于表示<strong>具有层次结构的数据</strong>。树中的某个结点（除根节点外）<strong>最多</strong>只和上一层的一个结点（即其父结点）有<strong>直接关系</strong>，根节点没有直接上层结点，因此在n个结点的树中有n-1条边。而树中每个结点与其下一层的0个或多个结点（即其孩子结点）都有直接关系。</p>\n</li>\n<li><p><strong>基本术语</strong></p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        A</span><br><span class=\"line\">      / | \\</span><br><span class=\"line\">    B   C   D</span><br><span class=\"line\">   / \\  |  /|\\</span><br><span class=\"line\">  E   F G H I J</span><br><span class=\"line\"> / \\      |</span><br><span class=\"line\">K   L     M</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p><strong>祖先：</strong>考虑结点K，从根A到结点K的唯一路径上的所有其他结点，称为结点K的祖先。</p>\n<blockquote>\n<p><strong>注：</strong>双亲也算祖先！！！</p>\n</blockquote>\n</li>\n<li><p><strong>子孙：</strong>如果结点B是结点K的祖先，则K是B的子孙。</p>\n<blockquote>\n<p><strong>注：</strong>孩子也算子孙！！！</p>\n</blockquote>\n</li>\n<li><p><strong>双亲结点：</strong>路径上最接近K的结点E称为K的双亲。根A是树中唯一没有双亲的结点。</p>\n</li>\n<li><strong>孩子结点：</strong>而K为E的孩子。</li>\n<li><strong>兄弟结点：</strong>有相同双亲的结点称为兄弟，K和L为兄弟。</li>\n<li><strong>堂兄弟结点：</strong><u>双亲在同一层的结点互为堂兄弟。</u><blockquote>\n<p><strong>注意：</strong>G与E，F，H，I，J互为堂兄弟！！！！！</p>\n</blockquote>\n</li>\n<li><strong>结点的度：</strong>树中一个结点的孩子个数称为该结点的度。</li>\n<li><strong>树的度：</strong>树中结点的<strong>最大度数（要存在以这个数为度的结点）</strong>称为树的度。</li>\n<li><strong>分支结点：</strong>度大于0的结点称为分支结点（又称<strong>非终端结点</strong>）。每个结点的分支数就是该结点的度。</li>\n<li><strong>叶结点：</strong>度为0（没有孩子结点）的结点称为叶结点（又称<strong>终端结点</strong>）。</li>\n<li><strong>结点的层次：</strong>从树根开始定义，根节点为第1层，它的孩子为第2层，以此类推。（↓）</li>\n<li><strong>结点的深度：</strong>就是结点所在的层次。（↓）</li>\n<li><strong>结点的高度：</strong>是<strong>以该结点为根的子树</strong>的高度。（↑）<blockquote>\n<p>结点的层次＝深度≠高度；树的最大层次＝深度＝高度。 王道P129，书P120</p>\n</blockquote>\n</li>\n<li><strong>有序树和无序树：</strong>树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，否则称为无序树。若将有序树的子结点位置互换，则变成一棵不同的树。</li>\n<li><strong>路径：</strong>树中<strong>两个结点之间的路径</strong>是由这两个结点之间所经过的<strong>结点序列</strong>构成的。</li>\n<li><strong>路径长度：</strong>是路径上所经过的<strong>边</strong>的个数。</li>\n</ol>\n<ul>\n<li><strong>树的性质</strong></li>\n</ul>\n<ol>\n<li>树的结点数n等于所有结点的度数之和加1。树中所有结点的度数之和等于树中的边数之和。<br><a href=\"./9eb01842.html#二叉树的定义\">（其他在二叉树的“度为m的树和m叉树的区别”表格里有）</a></li>\n</ol>\n<h4 id=\"森林的定义\"><a href=\"#森林的定义\" class=\"headerlink\" title=\"森林的定义\"></a>森林的定义</h4><ul>\n<li>森林是m(m≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以森林和树相互递归的定义来描述树。</li>\n</ul>\n<h4 id=\"二叉树、树、森林的异同点\"><a href=\"#二叉树、树、森林的异同点\" class=\"headerlink\" title=\"二叉树、树、森林的异同点\"></a>二叉树、树、森林的异同点</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>树</th>\n<th>二叉树</th>\n<th>森林</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>根节点</td>\n<td>有且仅有一个根节点</td>\n<td>有且仅有一个根节点</td>\n<td>每棵树有一个根节点</td>\n</tr>\n<tr>\n<td>子节点数</td>\n<td>不限</td>\n<td>每个节点最多两个子节点</td>\n<td>每棵树的节点数不限</td>\n</tr>\n<tr>\n<td>节点顺序</td>\n<td>没有严格顺序</td>\n<td>子节点有左右之分</td>\n<td>各棵树和节点无顺序</td>\n</tr>\n<tr>\n<td>连通性</td>\n<td>必须连通</td>\n<td>必须连通</td>\n<td>每棵树是连通的</td>\n</tr>\n<tr>\n<td>结构关系</td>\n<td>是一种特殊的无向无环图</td>\n<td>是树的一种特殊类型</td>\n<td>是多个树的集合</td>\n</tr>\n<tr>\n<td>应用</td>\n<td>文件系统、家谱等</td>\n<td>表达式树、二叉搜索树等</td>\n<td>多棵树的集合作为林</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"二叉树的实现（包括）\"><a href=\"#二叉树的实现（包括）\" class=\"headerlink\" title=\"二叉树的实现（包括）\"></a>二叉树的实现（包括）</h3><blockquote>\n<p>理解二叉树采用顺序存储结构和链式存储结构的差异性</p>\n</blockquote>\n<h4 id=\"顺序存储结构\"><a href=\"#顺序存储结构\" class=\"headerlink\" title=\"顺序存储结构\"></a>顺序存储结构</h4><ul>\n<li>二叉树的顺序存储是指用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为<code>i</code>的结点元素存储在一维数组下标为<code>i-1</code>的分量中。（书上讲的就是<code>i-1</code>哦）</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     1</span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  2     3</span><br><span class=\"line\">   \\     \\</span><br><span class=\"line\">    4     5</span><br><span class=\"line\">   /</span><br><span class=\"line\">  6</span><br><span class=\"line\"></span><br><span class=\"line\">1 2 3 0 4 0 5 0 0 6</span><br></pre></td></tr></table></figure>\n<ul>\n<li>会导致很多空间被浪费。在最坏的情况下，一个深度为k且只有k个结点的单支树（树中不存在度为2的结点）需要长度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^k-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9324em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>的一维数组。因此顺序存储结构仅适用于完全二叉树。</li>\n</ul>\n<h4 id=\"链式存储结构\"><a href=\"#链式存储结构\" class=\"headerlink\" title=\"链式存储结构\"></a>链式存储结构</h4><ul>\n<li>由于顺序存储的空间利用率低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉树中的每个结点。</li>\n<li>链表的头指针指向二叉树的根节点。</li>\n<li><p><strong>二叉链表</strong><br>由二叉树的定义得知，二叉树的结点由一个数据元素和分别指向其左、右子树的两个分支构成，则表示二叉树的链表中的结点至少包含3个域：数据域和左、右指针域。</p>\n<table>\n  <tr>\n    <td style=\"border: 1px solid; text-align: center;\">lchild</td>\n    <td style=\"border: 1px solid; text-align: center;\">data</td>\n    <td style=\"border: 1px solid; text-align: center;\">rchild</td>\n  </tr>\n</table>\n\n<p><strong>注意：容易证得，在含有n个结点的二叉链表中有n+1个空链域。</strong></p>\n</li>\n<li><p><strong>三叉链表</strong><br>有时，为了便于找到结点的双亲，则还可以在结点结构中增加一个指向其双亲结点的指针域。 </p>\n<table>\n  <tr>\n    <td style=\"border: 1px solid; text-align: center;\">lchild</td>\n    <td style=\"border: 1px solid; text-align: center;\">data</td>\n    <td style=\"border: 1px solid; text-align: center;\">parent</td>\n    <td style=\"border: 1px solid; text-align: center;\">rchild</td>\n  </tr>\n</table>\n</li>\n<li><p><strong>如果要找结点x的双亲结点，在三叉链表很容易实现，而在二叉链表中则需从根指针出发巡查。</strong></p>\n</li>\n</ul>\n<h3 id=\"二叉树的遍历（四种）\"><a href=\"#二叉树的遍历（四种）\" class=\"headerlink\" title=\"二叉树的遍历（四种）\"></a>二叉树的遍历（四种）</h3><blockquote>\n<p>掌握二叉树的四种遍历，并具有能够依赖遍历完成对二叉树进行操作的能力<br>书p128<br><a href=\"https://cloud.tencent.com/developer/article/1511790\">二叉树—层序、前序中序后序(递归、非递归)遍历详解</a>这篇博客光是先序遍历的非递归算法就包含了两种，不错，可以看一下</p>\n</blockquote>\n<ul>\n<li>遍历二叉树是以一定规则将二叉树中结点排列成一个线性序列，得到二叉树中结点的先序序列或中序序列或后序序列。这实质上是对一个非线性结构进行线性化操作，使每个结点（除第一个结点和最后一个外）在这些线性序列中有且仅有一个直接前驱和直接后继。</li>\n</ul>\n<p>L-&gt;遍历左子树；D-&gt;访问根节点；R-&gt;遍历右子树。<br>则可有DLR、LDR、LRD、DRL、RDL、RLD这6种方案。<br>若限定先左后右，则只有前3种情况。<br>基于二叉树的递归定义，可得下述遍历二叉树的递归定义。</p>\n<h4 id=\"先序遍历\"><a href=\"#先序遍历\" class=\"headerlink\" title=\"先序遍历\"></a>先序遍历</h4><p>先序遍历二叉树的操作定义为：<br>若二叉树为空，则空操作；否则</p>\n<ol>\n<li>访问根节点；</li>\n<li>先序遍历左子树；</li>\n<li>先序遍历右子树。</li>\n</ol>\n<p><strong>递归算法</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">preorder</span><span class=\"params\">(BiTree T)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (T!=<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(T);                  <span class=\"comment\">// 访问根节点</span></span><br><span class=\"line\">    <span class=\"built_in\">preorder</span>(T-&gt;lchild);      <span class=\"comment\">// 递归遍历左子树</span></span><br><span class=\"line\">    <span class=\"built_in\">preorder</span>(T-&gt;rchild);     <span class=\"comment\">// 递归遍历右子树</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>非递归算法</strong><br>第一种，<code>这个节点，再右节点进栈，左节点进栈</code><br><img src=\"/articles/9eb01842/先序遍历非递归法一.jpeg\" width=100% height=70% /></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">preorderIterative</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    stack&lt;TreeNode*&gt; s;</span><br><span class=\"line\">    s.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        TreeNode* node = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        cout &lt;&lt; node-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;      <span class=\"comment\">// 访问根节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;right) s.<span class=\"built_in\">push</span>(node-&gt;right);   <span class=\"comment\">// 先将右子节点压栈</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;left) s.<span class=\"built_in\">push</span>(node-&gt;left);     <span class=\"comment\">// 再将左子节点压栈</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二种，传统（王道p148）。遍历左子结点的链，直到没有左子结点，然后回溯处理右子结点。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">preorderIterativeAlt</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    stack&lt;TreeNode*&gt; s;</span><br><span class=\"line\">    TreeNode* current = root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span> || !s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; current-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;   <span class=\"comment\">// 访问当前节点</span></span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(current);               <span class=\"comment\">// 当前节点入栈</span></span><br><span class=\"line\">            current = current-&gt;left;       <span class=\"comment\">// 向左子树移动</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        current = current-&gt;right;          <span class=\"comment\">// 处理右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p>中序遍历二叉树的操作定义为：<br>若二叉树为空，则空操作；否则</p>\n<ol>\n<li>中序遍历左子树；</li>\n<li>访问根节点；</li>\n<li>中序遍历右子树。</li>\n</ol>\n<p><strong>递归算法</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inorderRecursive</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">inorderRecursive</span>(root-&gt;left);       <span class=\"comment\">// 递归遍历左子树</span></span><br><span class=\"line\">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;           <span class=\"comment\">// 访问根节点</span></span><br><span class=\"line\">    <span class=\"built_in\">inorderRecursive</span>(root-&gt;right);      <span class=\"comment\">// 递归遍历右子树</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>非递归算法</strong><br>第一种，类似于先序遍历的第一种，只不过引入了标记。（已经用很多特殊的二叉树例子运行完整代码来验证过了，且手模了一下，没发现什么问题）<br>每次取出栈顶结点：</p>\n<ul>\n<li><strong>如果节点未被标记</strong>，意味着我们还没有访问它。因此：<ul>\n<li>按照<strong>中序遍历的顺序</strong>，需要先遍历左子树，再访问根节点，最后遍历右子树。</li>\n<li>为此，我们首先将<strong>右子结点</strong>入栈（如果存在），然后将<strong>当前结点重新入栈并标记为已访问</strong>，最后将<strong>左子结点</strong>入栈（如果存在）。</li>\n</ul>\n</li>\n<li><strong>如果节点已被标记</strong>，意味着这是第二次从栈中取出它。此时，我们可以访问该节点，因为它的左子树已经处理过了。、<br>这样处理的效果就是，在中序遍历的顺序上保证了左子树→根节点→右子树的顺序。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">StackNode</span> &#123;</span><br><span class=\"line\">    TreeNode* node;</span><br><span class=\"line\">    <span class=\"type\">bool</span> visited;  <span class=\"comment\">// true 表示该节点的左子树已访问</span></span><br><span class=\"line\">    <span class=\"built_in\">StackNode</span>(TreeNode* n, <span class=\"type\">bool</span> v) : <span class=\"built_in\">node</span>(n), <span class=\"built_in\">visited</span>(v) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inorderIterativeWithMark</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    stack&lt;StackNode&gt; s;</span><br><span class=\"line\">    s.<span class=\"built_in\">push</span>(<span class=\"built_in\">StackNode</span>(root, <span class=\"literal\">false</span>));  <span class=\"comment\">// 初始根节点未访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        StackNode current = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.visited) &#123;</span><br><span class=\"line\">            cout &lt;&lt; current.node-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>; <span class=\"comment\">// 访问已标记的当前节点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将节点标记为已访问并重新压入栈中</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (current.node-&gt;right) s.<span class=\"built_in\">push</span>(<span class=\"built_in\">StackNode</span>(current.node-&gt;right, <span class=\"literal\">false</span>)); <span class=\"comment\">// 右子节点</span></span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(<span class=\"built_in\">StackNode</span>(current.node, <span class=\"literal\">true</span>));  <span class=\"comment\">// 标记当前节点为已访问（表示左子树已访问）</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (current.node-&gt;left) s.<span class=\"built_in\">push</span>(<span class=\"built_in\">StackNode</span>(current.node-&gt;left, <span class=\"literal\">false</span>));   <span class=\"comment\">// 左子节点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二种，（传统，王道p148），类似于先序遍历的第二种<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inorderIterative</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    stack&lt;TreeNode*&gt; s;</span><br><span class=\"line\">    TreeNode* current = root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span> || !s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">            current = current-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        cout &lt;&lt; current-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;    <span class=\"comment\">// 访问根节点</span></span><br><span class=\"line\">        current = current-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p>后序遍历二叉树的操作定义为：<br>若二叉树为空，则空操作；否则</p>\n<ol>\n<li>后序遍历左子树；</li>\n<li>后序遍历右子树；</li>\n<li>访问根节点。</li>\n</ol>\n<p><strong>递归算法</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">postorderRecursive</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">postorderRecursive</span>(root-&gt;left);     <span class=\"comment\">// 递归遍历左子树</span></span><br><span class=\"line\">    <span class=\"built_in\">postorderRecursive</span>(root-&gt;right);    <span class=\"comment\">// 递归遍历右子树</span></span><br><span class=\"line\">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;           <span class=\"comment\">// 访问根节点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>非递归算法</strong><br>第一种（双栈）<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">postorderIterative</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    stack&lt;TreeNode*&gt; s1, s2;</span><br><span class=\"line\">    s1.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!s1.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        TreeNode* node = s1.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        s1.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        s2.<span class=\"built_in\">push</span>(node);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;left) s1.<span class=\"built_in\">push</span>(node-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;right) s1.<span class=\"built_in\">push</span>(node-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!s2.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; s2.<span class=\"built_in\">top</span>()-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        s2.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二种，（传统，王道p167-168，03题）<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">postorderIterative</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    stack&lt;TreeNode*&gt; s;</span><br><span class=\"line\">    TreeNode* prev = <span class=\"literal\">nullptr</span>;  <span class=\"comment\">// 记录上一个访问的节点</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!s.<span class=\"built_in\">empty</span>() || root != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(root);  <span class=\"comment\">// 将当前节点压入栈中</span></span><br><span class=\"line\">            root = root-&gt;left;  <span class=\"comment\">// 继续向左子树深入</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            TreeNode* node = s.<span class=\"built_in\">top</span>();  <span class=\"comment\">// 获取栈顶节点</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果当前节点的右子树未被访问过，先访问右子树</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node-&gt;right != <span class=\"literal\">nullptr</span> &amp;&amp; node-&gt;right != prev) &#123;</span><br><span class=\"line\">                root = node-&gt;right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cout &lt;&lt; node-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;  <span class=\"comment\">// 后序遍历的访问节点</span></span><br><span class=\"line\">                prev = node;  <span class=\"comment\">// 标记当前节点为已访问</span></span><br><span class=\"line\">                s.<span class=\"built_in\">pop</span>();  <span class=\"comment\">// 弹出栈顶节点</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为什么需要标记？<br>答：如果栈顶节点的右子树已经访问过，说明当前节点已经是后序遍历顺序中的最后一个步骤（即根节点），我们可以访问这个节点并将其从栈中弹出。</p>\n<h4 id=\"层次遍历\"><a href=\"#层次遍历\" class=\"headerlink\" title=\"层次遍历\"></a>层次遍历</h4><p>利用队列，BFS<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">levelOrder</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        TreeNode* node = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        cout &lt;&lt; node-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;       <span class=\"comment\">// 访问节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;left) q.<span class=\"built_in\">push</span>(node-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;right) q.<span class=\"built_in\">push</span>(node-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"二叉树的遍历和表达式的关系\"><a href=\"#二叉树的遍历和表达式的关系\" class=\"headerlink\" title=\"二叉树的遍历和表达式的关系\"></a>二叉树的遍历和表达式的关系</h4><p>书p129<br>前缀表达式（波兰式）对应先序遍历<br>中缀表达式对应中序遍历<br>后缀表达式（逆波兰式）对应后序遍历</p>\n<h4 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h4><table>\n  <tr>\n    <td style=\"border: 1px solid; text-align: center;\">lchild</td>\n    <td style=\"border: 1px solid; text-align: center;\">LTag</td>\n    <td style=\"border: 1px solid; text-align: center;\">data</td>\n    <td style=\"border: 1px solid; text-align: center;\">RTag</td>\n    <td style=\"border: 1px solid; text-align: center;\">rchild</td>\n  </tr>\n</table>\n\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi>T</mi><mi>a</mi><mi>g</mi><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>l</mi><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mtext> 指示结点的左孩子</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>l</mi><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mtext> 指示结点的前驱</mtext></mrow></mstyle></mtd></mtr></mtable></mrow><mspace width=\"1em\"/><mi>R</mi><mi>T</mi><mi>a</mi><mi>g</mi><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>r</mi><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mtext> 指示结点的右孩子</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>r</mi><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mtext> 指示结点的后继</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">LTag = \\begin{cases} \n    0 &amp; lchild \\text{ 指示结点的左孩子} \\\\ \n    1 &amp; lchild \\text{ 指示结点的前驱} \n\\end{cases} \n\\quad \nRTag = \\begin{cases} \n    0 &amp; rchild \\text{ 指示结点的右孩子} \\\\ \n    1 &amp; rchild \\text{ 指示结点的后继} \n\\end{cases}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">d</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">指示结点的左孩子</span></span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">d</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">指示结点的前驱</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">RT</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">rc</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">d</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">指示结点的右孩子</span></span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">rc</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">d</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">指示结点的后继</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>\n<ul>\n<li>以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做<strong>线索链表</strong>，其中指向结点前驱和后继的指针，叫做<strong>线索</strong>。</li>\n<li>加上线索的二叉树称之为<strong>线索二叉树</strong>。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做<strong>线索化</strong>。</li>\n<li>在后序线索树上招后继时需知道结点的双亲，即需带标志域的三叉链表作存储结构。</li>\n<li>若在某程序中所用二叉树需经常遍历或查找结点在遍历所得线性序列中的前驱和后继，应采用线索链表作存储结构。</li>\n<li>为方便起见，仿照线性表的存储结构，在二叉树的线索链表上也添加一个头结点，并令其lchild域的指针指向二叉树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点；令二叉树中序序列中的第一个结点的lchild域指针和最后一个结点rchild域的指针均指向头结点。这好比为二叉树建立了一个双向线索链表，既可以从第一个结点其顺后继进行遍历，也可从最后一个结点起顺前驱进行遍历。</li>\n</ul>\n<p><strong>中序线索化</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 中序线索化二叉树</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inThread</span><span class=\"params\">(ThreadedTreeNode* root, ThreadedTreeNode*&amp; pre)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 先线索化左子树</span></span><br><span class=\"line\">    <span class=\"built_in\">inThread</span>(root-&gt;left, pre);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 线索化当前节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left) &#123;</span><br><span class=\"line\">        root-&gt;lTag = <span class=\"literal\">true</span>;  <span class=\"comment\">// 左子树为空，指向前驱</span></span><br><span class=\"line\">        root-&gt;left = pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre &amp;&amp; !pre-&gt;right) &#123;</span><br><span class=\"line\">        pre-&gt;rTag = <span class=\"literal\">true</span>;  <span class=\"comment\">// 右子树为空，指向后继</span></span><br><span class=\"line\">        pre-&gt;right = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pre = root;  <span class=\"comment\">// 更新前驱节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 线索化右子树</span></span><br><span class=\"line\">    <span class=\"built_in\">inThread</span>(root-&gt;right, pre);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>中序线索化后，找结点a的后继</strong></p>\n<ol>\n<li>若其右标志为“1”，则右链为线索，指示其后继；</li>\n<li>否则遍历右子树中第一个访问的结点（右子树中最左下的结点）。找到其右子树的根节点<code>b</code>，然后顺其左指针往下至其左标志为1（无左孩子，且线索指向<code>b</code>）的结点，即为<code>a</code>的后继。</li>\n</ol>\n<p><strong>中序线索化后，找结点a的前驱</strong></p>\n<ol>\n<li>若其左标志为“1”，则左链为线索，指示其前驱；</li>\n<li>否则遍历左子树时最后访问的一个结点（左子树中最右下的结点）为其前驱。</li>\n</ol>\n<p><strong>先序线索化</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先序线索化二叉树</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">preThread</span><span class=\"params\">(ThreadedTreeNode* root, ThreadedTreeNode*&amp; pre)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 线索化当前节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left) &#123;</span><br><span class=\"line\">        root-&gt;lTag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        root-&gt;left = pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre &amp;&amp; !pre-&gt;right) &#123;</span><br><span class=\"line\">        pre-&gt;rTag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        pre-&gt;right = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre = root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 先线索化左子树</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;lTag) <span class=\"built_in\">preThread</span>(root-&gt;left, pre);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后线索化右子树</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;rTag) <span class=\"built_in\">preThread</span>(root-&gt;right, pre);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>先序线索化后，找结点a的后继</strong></p>\n<ol>\n<li>若有左孩子，则左孩子就是其后继；</li>\n<li>若无左孩子，但有右孩子，则右孩子就是其后继；</li>\n<li>若为叶结点，则右链域直接指示了结点的后继。</li>\n</ol>\n<p><strong>先序线索化后，找结点a的前驱</strong>（书上没有，自己写的）</p>\n<ol>\n<li>若无左孩子，则左链域直接指示了结点的前驱；</li>\n<li>若有左孩子，<br>①若<code>a</code>无双亲结点，即其为整棵树的根节点，则无前驱；<br>②若<code>a</code>有双亲结点，且<code>a</code>为双亲结点的左孩子，则其前驱为双亲结点；<br>③若<code>a</code>有双亲结点，且<code>a</code>为双亲结点的右孩子，则其前驱为双亲结点的左子树按照先序遍历下的最后一个结点，不一定是左子树的最右侧结点，因为可以是最右侧结点<code>b</code>的左孩子<code>c</code>（<code>b</code>没有右孩子的情况下）</li>\n</ol>\n<p><strong>注：</strong>这个应该也需要三叉链表，因为需要知道其双亲结点。</p>\n<p><strong>后序线索化</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 后序线索化二叉树</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">postThread</span><span class=\"params\">(ThreadedTreeNode* root, ThreadedTreeNode*&amp; pre)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 先线索化左子树</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;lTag) <span class=\"built_in\">postThread</span>(root-&gt;left, pre);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 再线索化右子树</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;rTag) <span class=\"built_in\">postThread</span>(root-&gt;right, pre);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 线索化当前节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left) &#123;</span><br><span class=\"line\">        root-&gt;lTag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        root-&gt;left = pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre &amp;&amp; !pre-&gt;right) &#123;</span><br><span class=\"line\">        pre-&gt;rTag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        pre-&gt;right = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pre = root;  <span class=\"comment\">// 更新前驱节点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>后序线索化后，找结点a的后继</strong></p>\n<ol>\n<li>若结点<code>a</code>是二叉树的根，则其后继为空；</li>\n<li>若结点<code>a</code>是①<u>其双亲结点的右孩子</u>或是②<u>其双亲的左孩子且其双亲没有右子树</u>，则其后继即为双亲结点；</li>\n<li>若结点<code>a</code>是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按照后序遍历列出的第一个结点。</li>\n</ol>\n<p><strong>注：</strong>可见，在后序线索化树上找后继时需知道结点双亲，即需带标志域的三叉链表作存储结构。</p>\n<p><strong>后序线索化后，找结点a的前驱</strong>（书上没有，自己写的）</p>\n<ol>\n<li>若结点<code>a</code>无左孩子，则其前驱为左链域所指示的结点。</li>\n<li>若结点<code>a</code>有左孩子，若其有右孩子则前驱为右孩子，若其无右孩子则前驱为左孩子。</li>\n</ol>\n<h3 id=\"二叉树结构下的应用及扩展（例如）\"><a href=\"#二叉树结构下的应用及扩展（例如）\" class=\"headerlink\" title=\"二叉树结构下的应用及扩展（例如）\"></a>二叉树结构下的应用及扩展（例如）</h3><blockquote>\n<p>掌握利用二叉树及其扩展下的检索技术；掌握Huffman编码、堆的<strong>实现及应用</strong></p>\n</blockquote>\n<h4 id=\"二叉检索树\"><a href=\"#二叉检索树\" class=\"headerlink\" title=\"二叉检索树\"></a>二叉检索树</h4><p>二叉排序树(BST)、二叉查找树、二叉搜索树</p>\n<ul>\n<li><strong>二叉排序树</strong>或者是一棵空树；或者是具有下列性质的二叉树：</li>\n</ul>\n<ol>\n<li>若它的左子树不空，则左子树上<strong>所有</strong>结点的值<strong>均小于</strong>它的根结点的值；</li>\n<li>若它的右子树不空，则右子树上<strong>所有</strong>结点的值<strong>均大于</strong>它的根结点的值；</li>\n<li>它的左、右子树也分别为二叉排序树。</li>\n</ol>\n<ul>\n<li>通常可取<strong>二叉链表</strong>作为二叉排序树的<strong>存储结构</strong>。</li>\n<li>和次优二叉树相对，二叉排序树是一种动态树表。其特点是，树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字（所以结点不能重复）等于给定值的结点时再进行插入。<br>新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查找的关键字序列：&#123;45, 24, 53, 45, 12, 24, 90&#125;</span><br><span class=\"line\">生成的二叉排序树：</span><br><span class=\"line\">        45</span><br><span class=\"line\">      /    \\</span><br><span class=\"line\">     24     53</span><br><span class=\"line\">    /         \\</span><br><span class=\"line\">   12         90</span><br></pre></td></tr></table></figure>\n<ul>\n<li>二叉排序树既拥有类似于折半查找的特性，又采用了链表作为存储结构，因此是动态查找表的一种适宜表示。</li>\n<li>同样，在二叉排序树上删去一个结点也很方便。<br>对于一般的二叉树来说，删去树中一个结点是没有意义的。因为它将使以被删结点为根的子树成为森林，破坏了整棵树的结构。<br>然而，对于二叉排序树，删去树上一个结点相当于删去有序序列中的一个记录，只要在删除某个结点之后依旧保持二叉排序树的特性即可。</li>\n<li>设被删结点为<code>*p</code>，其双亲结点为<code>*f</code>，且不失一般性，可设<code>*p</code>是<code>*f</code>的左孩子。</li>\n</ul>\n<ol>\n<li>若<code>*p</code>结点为叶子结点，即<code>P_L</code>（<code>*p</code>的左子树）和<code>P_R</code>（右子树）均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。</li>\n<li>若<code>*p</code>结点只有左子树<code>P_L</code>或者只有右子树<code>P_R</code>，此时只要令<code>P_L</code>或<code>P_R</code>直接成为其双亲结点<code>*f</code>的左子树即可。显然，作此修改也不破坏二叉排序树的特性。</li>\n<li>若<code>*p</code>结点的左子树和右子树均不空。</li>\n</ol>\n<p><img src=\"/articles/9eb01842/BST_del.jpg\" width=100% /></p>\n<ul>\n<li>ASL(书P231)<br>查找成功的平均查找长度ASL=(Σ每层结点数*深度)/结点总数<br>二叉排序树的查找效率，主要取决于树的高度。</li>\n</ul>\n<ol>\n<li>（和折半查找的判定树相同，最好情况，和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">log_2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span></span></span></span>成正比）若二叉排序树的左、右子树的高度之差的绝对值不超过1（平衡二叉树），它的平均查找长度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log_2n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>（先后插入的关键字有序，单支树，和顺序查找相同，最坏情况，=<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n+1}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>）若二叉排序树是一个只有右（左）孩子的单支树（类似于有序的单链表），则其平均查找长度为O(n)。</li>\n<li>随机情况下，二叉排序树的平均查找长度和logn是等数量级的。</li>\n</ol>\n<ul>\n<li>二分（折半）查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入的顺序不同可能生成不同的二叉排序树（如有序，则生成单支树）。</li>\n<li>当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其查找操作；若有序表是动态查找表，则应选择二叉排序树作为其逻辑结构。</li>\n</ul>\n<h4 id=\"2-3-4树\"><a href=\"#2-3-4树\" class=\"headerlink\" title=\"2-3-4树\"></a>2-3-4树</h4><blockquote>\n<p><a href=\"https://oi-wiki.org/ds/2-3-tree/\">oiwiki 2-3树</a><br><a href=\"https://oi-wiki.org/ds/2-3-4-tree/\">oiwiki 2-3-4树</a></p>\n</blockquote>\n<h4 id=\"B树-B\"><a href=\"#B树-B\" class=\"headerlink\" title=\"B树(B-)\"></a>B树(B-)</h4><blockquote>\n<p><a href=\"https://oi-wiki.org/ds/b-tree/\">oiwiki B树</a></p>\n</blockquote>\n<p>B 树是一种平衡的多路搜索树，广泛用于数据库和文件系统中，以支持高效的数据插入、删除和查找操作。B 树的设计目标是最大限度减少磁盘 I/O 操作，因此特别适合处理大量数据的场景。</p>\n<p><strong>B 树的结构与特性</strong><br>B 树的关键特性如下：</p>\n<ol>\n<li><p><strong>多路搜索树</strong>：  </p>\n<ul>\n<li>B 树的每个结点可以包含多个数据项和多个子结点。</li>\n<li>对于一个 m 阶的 B 树，每个结点最多可以有 m 个子结点，至少有 ⌈m/2⌉ 个子结点（除了根结点可以少于此数目）。</li>\n</ul>\n</li>\n<li><p><strong>数据项的有序性</strong>：  </p>\n<ul>\n<li>每个结点中的数据项按从小到大的顺序排列。</li>\n<li>每个子树对应的值范围在当前结点的数据项之间。<ul>\n<li>比如，如果结点包含数据项 <code>[A, B, C]</code>，则其子树的数据项满足：<ul>\n<li>第一个子树的数据项小于 <code>A</code>；</li>\n<li>第二个子树的数据项在 <code>A</code> 和 <code>B</code> 之间；</li>\n<li>第三个子树的数据项在 <code>B</code> 和 <code>C</code> 之间；</li>\n<li>第四个子树的数据项大于 <code>C</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>平衡性</strong>：  </p>\n<ul>\n<li>B 树是平衡树，所有叶子结点的深度相同，从根到任一叶子结点的路径长度一致。这使得查找的时间复杂度在 <code>O(log n)</code> 范围内。</li>\n</ul>\n</li>\n<li><p><strong>高度控制</strong>：  </p>\n<ul>\n<li>B 树的高度相对较低，通常通过较大的分支因子（m 的值较大）来控制树的高度，使得每个结点包含更多数据，从而减少查找路径长度。</li>\n<li>对于磁盘存储，树的高度越低，磁盘 I/O 次数越少，因此性能越高。</li>\n</ul>\n</li>\n</ol>\n<p><strong>B 树的基本操作</strong><br>B 树的基本操作主要包括查找、插入和删除：</p>\n<ol>\n<li><p><strong>查找</strong>：<br>查找操作与二叉搜索树类似，通过与每个结点的数据项逐一比较，进入对应范围的子树。由于 B 树是平衡的，所以查找的时间复杂度为 <code>O(log n)</code>。</p>\n</li>\n<li><p><strong>插入</strong>：<br>插入操作包括以下几个步骤：</p>\n<ul>\n<li><strong>定位叶结点</strong>：先从根结点查找，找到适合插入新数据项的叶结点。</li>\n<li><strong>插入数据项</strong>：将新数据项插入到叶结点中，并保持结点中的数据项顺序。</li>\n<li><strong>分裂结点</strong>：如果插入后结点的数据项数量超过 m-1，则该结点需要分裂。分裂时，选择中间的数据项上移到父结点，分裂后的两个新结点分别成为父结点的子结点。</li>\n<li><strong>上溢处理</strong>：如果父结点也满了，则父结点同样需要分裂，这可能导致分裂操作逐层向上传播，甚至需要分裂根结点，从而使树的高度增加。</li>\n</ul>\n</li>\n<li><p><strong>删除</strong>：<br>删除操作分为以下几种情况：</p>\n<ul>\n<li><strong>删除叶结点的数据项</strong>：直接删除数据项即可，但要检查该结点是否满足最小数据项数要求（即至少含有 ⌈m/2⌉ 个数据项）。</li>\n<li><strong>删除内部结点的数据项</strong>：可以通过以下策略进行替换：<ul>\n<li>找到左子树的最大值或右子树的最小值来替换该数据项。</li>\n<li>然后在对应子树中递归删除这个替换的数据项。</li>\n</ul>\n</li>\n<li><strong>借用和合并</strong>：如果删除后某结点数据项不足，可从相邻的兄弟结点中“借”一个数据项，或将该结点与兄弟结点合并。如果合并导致父结点数据项不足，则继续向上递归调整，直到树重新平衡。</li>\n</ul>\n</li>\n</ol>\n<p><strong>B 树的应用场景</strong><br>B 树广泛应用于数据库系统、文件系统、键-值存储等，因为它能够有效地支持大量数据的动态存储与管理，并优化磁盘 I/O 操作。在实际应用中，通常会用 B+ 树或 B* 树，因为它们对顺序访问进行了进一步优化。</p>\n<p><strong>B 树的优点</strong>  </p>\n<ul>\n<li><strong>平衡性</strong>：自动保持平衡，避免了二叉搜索树退化为链表的情况。</li>\n<li><strong>高效的磁盘访问</strong>：B 树的高度较低，结点中包含多个数据项，因此每次磁盘读取获取更多数据，有效减少磁盘 I/O 次数。</li>\n<li><strong>支持范围查找</strong>：B 树中的数据项有序排列，因此支持按范围查找（例如查找所有小于某个值的项）。</li>\n</ul>\n<p><strong>B 树的缺点</strong>  </p>\n<ul>\n<li><strong>实现复杂性</strong>：插入、删除需要多种特殊情况处理，尤其是分裂和合并操作。</li>\n<li><strong>内存利用率</strong>：B 树的内存利用率不如二叉树，因为每个结点中可能存在未使用的指针。</li>\n</ul>\n<p>通过这些特性，B 树能够很好地管理大量有序数据，使得查找、插入和删除都在 <code>O(log n)</code> 时间内完成，非常适合高效管理大规模数据。</p>\n<blockquote>\n<p><strong>B树和2-3-4树有什么区别？</strong></p>\n<ol>\n<li>2-3-4 树是 B 树的一个特例，阶数为 4 的 B 树。</li>\n<li>2-3-4 树和 B 树的主要区别在于 B 树的阶数 m 更为灵活，而 2-3-4 树的阶数固定为 4。</li>\n<li>在结构上，2-3-4 树的结点数目（子结点和数据项数目）正好符合 B 树的一个具体实现。</li>\n</ol>\n</blockquote>\n<h4 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h4><blockquote>\n<p><a href=\"https://oi-wiki.org/ds/bplus-tree/\">oiwiki B+树</a></p>\n</blockquote>\n<h4 id=\"Huffman编码\"><a href=\"#Huffman编码\" class=\"headerlink\" title=\"Huffman编码\"></a>Huffman编码</h4><ul>\n<li><strong>路径：</strong>从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。</li>\n<li><strong>路径长度：</strong>路径上的分支数目。</li>\n<li><strong>权：</strong>树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。</li>\n<li><strong>带权路径长度：</strong>从树的根到一个结点的路径长度与该结点上权值的乘积，称为该结点的权。<br>树中所有<strong>叶结点</strong>的带权路径长度之和称为<strong>该树的带权路径长度</strong>，记为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>w</mi><mi>i</mi></msub><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">WPL=\\sum\\limits_{i=1}^{n}w_i l_i </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</li>\n<li><strong>哈夫曼树：</strong>在含有n各带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称<strong>最优二叉树</strong>。</li>\n<li><p><strong>哈夫曼树的构造：</strong>给定n各权值分别为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>w</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">w_1, w_2, \\cdots, w_n </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的结点，构造哈夫曼树的算法描述如下：</p>\n<ol>\n<li>将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。</li>\n<li>构造一个新结点，从F中选取两棵<strong>根节点权值最小</strong>的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。</li>\n<li>从F中删除刚才选出的两棵树，同时将新得到的树加入F中。</li>\n<li>重复步骤2和3，直至F中只剩下一棵树为止。</li>\n</ol>\n</li>\n<li><p><strong>哈夫曼树的性质：</strong>从上述构造过程中可以看出哈夫曼树具有如下特点：</p>\n<ol>\n<li>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。</li>\n<li>构造过程中共新建了n-1个结点（双分支结点），因此哈夫曼树的<strong>结点总数为2n-1</strong>。</li>\n<li>每次构造都选择2棵树作为新结点的孩子，因此<strong>哈夫曼树中不存在度为1的结点</strong>。</li>\n</ol>\n</li>\n<li><p><strong>哈夫曼编码：</strong></p>\n<ul>\n<li><strong>固定长度编码：</strong>在数据通信中，若对每个字符用相等长度的二进制表示，称这种编码方式为固定长度编码。</li>\n<li><strong>可变长度编码：</strong>若允许对不同字符用不等长的二进制位表示，则这种编码方式称为可变长度编码。</li>\n<li><strong>可变长度编码比固定长度编码要好得多</strong>，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。</li>\n<li><strong>前缀编码：</strong>若没有一个编码是另一个编码的前缀，则称这样的编码为<strong>前缀编码</strong>。<ul>\n<li><code>e.g.</code> 0, 10, 110</li>\n</ul>\n</li>\n<li><p>可以利用二叉树来设计<strong>二进制前缀编码</strong>。<br><img src=\"/articles/9eb01842/前缀编码.jpg\" width=60% /></p>\n</li>\n<li><p>哈夫曼编码是一种非常有效的<strong>数据压缩编码</strong>。<br><img src=\"/articles/9eb01842/哈夫曼编码.jpg\" width=60% /><br>这棵哈夫曼树的WPL=1×45+3×(12+13+16)+4×(5+9)=224<br>此处的WPL可视为最终编码得到二进制编码的长度，共224位。若采用3位固定长度编码，则得到的二进制编码长度为300位(45+12+13+16+5+9=100)，因此<strong>哈夫曼树可以设计出总长度最短的二进制前缀编码</strong>。</p>\n</li>\n<li>左分支和右分支究竟是表示0还是表示1没有明确规定，因此构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度WPL相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但WPL必然相同且为最优。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h4><ul>\n<li>n个关键字序列L[1…n]称为堆，当且仅当该序列满足：<ol>\n<li>L(i)≥L(2i)且L(i)≥L(2i+1) （大根堆）或</li>\n<li>L(i)≤L(2i)且L(i)≤L(2i+1) (1≤i≤⌊n/2⌋) （小根堆）</li>\n</ol>\n</li>\n<li><strong>堆一定是完全二叉树。</strong></li>\n<li><strong>堆的插入</strong><br>先将新结点放在堆的末端，再对这个新结点向上执行调整操作。<br><img src=\"/articles/9eb01842/堆插入.jpg\" width=100% /></li>\n</ul>\n<h3 id=\"平衡二叉树的定义和意义-AVL\"><a href=\"#平衡二叉树的定义和意义-AVL\" class=\"headerlink\" title=\"平衡二叉树的定义和意义(AVL)\"></a>平衡二叉树的定义和意义(AVL)</h3><h3 id=\"平衡因子的定义\"><a href=\"#平衡因子的定义\" class=\"headerlink\" title=\"平衡因子的定义\"></a>平衡因子的定义</h3><h3 id=\"平衡二叉树的旋转操作-TODO\"><a href=\"#平衡二叉树的旋转操作-TODO\" class=\"headerlink\" title=\"平衡二叉树的旋转操作(TODO)\"></a>平衡二叉树的旋转操作(TODO)</h3><h3 id=\"树和森林的存储结构\"><a href=\"#树和森林的存储结构\" class=\"headerlink\" title=\"树和森林的存储结构\"></a>树和森林的存储结构</h3><blockquote>\n<p>掌握树、森林能够采用的各种存储方式的差异性</p>\n</blockquote>\n<p>树和森林在计算机中有多种不同的存储方式，每种方式各有优缺点，适合不同的应用场景。下面介绍几种常见的树和森林的存储方法及它们的差异性。</p>\n<h4 id=\"1-链式存储方式\"><a href=\"#1-链式存储方式\" class=\"headerlink\" title=\"1. 链式存储方式\"></a>1. 链式存储方式</h4><p>链式存储方式使用<strong>指针</strong>来表示树结点之间的父子关系，常见的有<strong>双亲表示法</strong>、<strong>孩子表示法</strong>和<strong>孩子兄弟表示法</strong>。链式存储适合<strong>不定度的树</strong>（即每个结点的子结点数不确定的树），例如文件目录结构、HTML DOM 树等。</p>\n<p><strong>a. 双亲表示法</strong><br>每个结点使用一个结构体表示，并包含一个指向其<strong>父结点</strong>的指针或索引。适合查找父结点，但查找子结点效率较低。</p>\n<p><img src=\"/articles/9eb01842/双亲表示法.jpg\" width=100% /></p>\n<ul>\n<li><strong>结构</strong>：每个结点存储自己的值和父结点的指针或索引。</li>\n<li><strong>优点</strong>：利用了每个结点（根结点除外）只有唯一双亲地性质，查找父结点很方便。</li>\n<li><strong>缺点</strong>：查找子结点不方便，需要遍历整个数组来找到该结点的所有子结点。</li>\n</ul>\n<p><strong>b. 孩子表示法</strong><br>为每个结点分配一个<strong>孩子链表</strong>，链表中的每个结点包含指向一个子结点的指针。</p>\n<p><img src=\"/articles/9eb01842/孩子表示法.jpg\" width=100% /></p>\n<ul>\n<li><strong>结构</strong>：每个结点存储自己的值，以及一个链表指针指向其所有的子结点。</li>\n<li><strong>优点</strong>：方便查找子结点，适合不定度的树。</li>\n<li><strong>缺点</strong>：存储结构较为复杂，查找父结点不方便，需要从根结点遍历。</li>\n</ul>\n<p><strong>c. 孩子兄弟表示法（又称二叉树表示法）</strong><br>将树转化为<strong>二叉树</strong>来存储。每个结点使用两个指针：一个指向其<strong>第一个孩子</strong>，另一个指向其<strong>下一个兄弟</strong>。这种方法特别适合存储<strong>森林</strong>结构。</p>\n<p><img src=\"/articles/9eb01842/孩子兄弟表示法.jpg\" width=100% /></p>\n<ul>\n<li><strong>结构</strong>：每个结点存储自己的值，一个孩子指针和一个兄弟指针。</li>\n<li><strong>优点</strong>：适合任意度的树，且能够高效地存储森林结构。</li>\n<li><strong>缺点</strong>：编程逻辑复杂，查找特定的孩子结点或兄弟结点需要遍历。</li>\n</ul>\n<h4 id=\"2-其他存储方式\"><a href=\"#2-其他存储方式\" class=\"headerlink\" title=\"2. 其他存储方式\"></a>2. 其他存储方式</h4><p><strong>a. 数组表示法（用于完全二叉树）</strong><br>对完全二叉树的结点按层次从左到右编号，可以使用数组存储。对于父结点在<strong>数组中的索引（从0开始）</strong>为<code>i</code>：</p>\n<ul>\n<li><strong>左子结点</strong>在位置<code>2*i + 1</code></li>\n<li><strong>右子结点</strong>在位置<code>2*i + 2</code></li>\n</ul>\n<p>这种方法适合<strong>完全二叉树</strong>或<strong>近似完全二叉树</strong>。</p>\n<ul>\n<li><strong>优点</strong>：占用空间小，定位子结点和父结点的效率高。</li>\n<li><strong>缺点</strong>：如果是一般的树或不规则的二叉树，会浪费大量空间，且不适合查找任意度的树。</li>\n</ul>\n<p><strong>b. 邻接矩阵或邻接表（用于森林）</strong><br>可以用邻接矩阵或邻接表来表示森林，将每棵树的结点当作一个图的顶点，将父子关系当作图的边。</p>\n<ul>\n<li><strong>优点</strong>：适合表示复杂的关系，特别是用于图结构的算法。</li>\n<li><strong>缺点</strong>：邻接矩阵会占用大量空间；邻接表适合稀疏图结构，不适合高密度的父子关系。</li>\n</ul>\n<h4 id=\"存储方式的对比总结\"><a href=\"#存储方式的对比总结\" class=\"headerlink\" title=\"存储方式的对比总结\"></a>存储方式的对比总结</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>存储方式</th>\n<th>适用场景</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>双亲表示法</strong></td>\n<td>查找父节点频繁的场景</td>\n<td>查找父节点方便</td>\n<td>查找子节点效率低</td>\n</tr>\n<tr>\n<td><strong>孩子表示法</strong></td>\n<td>查找子节点频繁、不定度的树结构</td>\n<td>查找子节点方便</td>\n<td>查找父节点困难，数据结构复杂</td>\n</tr>\n<tr>\n<td><strong>孩子兄弟表示法</strong></td>\n<td>不定度的树、森林</td>\n<td>适合任意度的树，能存储森林</td>\n<td>逻辑复杂，查找指定孩子或兄弟节点时不便</td>\n</tr>\n<tr>\n<td><strong>数组表示法</strong></td>\n<td>完全二叉树、近似完全二叉树</td>\n<td>占用空间小，定位节点快</td>\n<td>不适合非完全二叉树，存储一般树浪费空间</td>\n</tr>\n<tr>\n<td><strong>邻接矩阵/表</strong></td>\n<td>复杂的森林结构、图结构</td>\n<td>表示关系灵活，特别适合图算法</td>\n<td>邻接矩阵空间大；邻接表不适合高密度父子关系的树</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>根据树的结构和操作需求选择合适的存储方式，可以有效提高数据操作的效率并节省空间。</p>\n<h3 id=\"树和森林的遍历\"><a href=\"#树和森林的遍历\" class=\"headerlink\" title=\"树和森林的遍历\"></a>树和森林的遍历</h3><blockquote>\n<p>掌握树、森林在遍历方面和二叉树的不同以及相关性</p>\n</blockquote>\n<p>树和森林的遍历是理解数据结构中结点访问顺序的关键部分。树的遍历有不同的策略，包括深度优先遍历（如先序、中序、后序遍历）和广度优先遍历（层次遍历）。对于森林，遍历也遵循类似的策略。与二叉树的遍历相比，树和森林的遍历在实现上有一些独特的地方，尤其是当树的度（每个结点的子结点数）不固定时。</p>\n<h4 id=\"1-树的遍历\"><a href=\"#1-树的遍历\" class=\"headerlink\" title=\"1. 树的遍历\"></a>1. 树的遍历</h4><p>树的遍历与二叉树的遍历类似，但树的每个结点可能有多个子结点，因此其遍历方式会有所调整。树的遍历方法一般包括<strong>先根遍历</strong>、<strong>后根遍历</strong>和<strong>层次遍历</strong>，但在每个结点的子结点的访问顺序上有所不同。</p>\n<p><strong>a. 树的先根遍历</strong><br>对于一般树（多子树的树），<strong>前根遍历</strong>访问顺序为：<br>（若树非空）</p>\n<ol>\n<li>访问根结点。</li>\n<li>遍历根结点的每一个子结点，按从左到右的顺序递归遍历每个子结点。</li>\n</ol>\n<p>其遍历序列与这棵树相应的<strong>二叉树的先序序列</strong>相同。</p>\n<p><strong>b. 树的后根遍历</strong><br>对于一般树的<strong>后根遍历</strong>，访问顺序为：<br>（若树非空）</p>\n<ol>\n<li>递归遍历每个子结点（从左到右）。</li>\n<li>访问根结点。</li>\n</ol>\n<p>其遍历序列与这棵树相应的<strong>二叉树的中序序列</strong>相同。</p>\n<p><strong>c. 树的层次遍历</strong><br>树的<strong>层次遍历</strong>类似于二叉树的层次遍历，按层次逐层从上到下、从左到右访问每个结点。这通常通过队列来实现：</p>\n<ol>\n<li>将根结点加入队列。</li>\n<li>取出队列中的结点并访问它。</li>\n<li>如果该结点有子结点，将子结点按顺序加入队列。</li>\n</ol>\n<h4 id=\"3-森林的遍历\"><a href=\"#3-森林的遍历\" class=\"headerlink\" title=\"3. 森林的遍历\"></a>3. 森林的遍历</h4><p>森林是多个树的集合，因此森林的遍历可以看作是对每一棵树进行遍历。在遍历森林时，通常会对森林中的每一棵树单独进行遍历，遍历的方法与树的遍历方法相同。</p>\n<p><strong>先序遍历森林</strong><br>（若森林非空）</p>\n<ol>\n<li>访问森林中第一棵树的根结点。</li>\n<li>先序遍历第一棵树中根结点的子树森林。</li>\n<li>先序遍历除去第一棵之后剩余的树构成的森林。</li>\n</ol>\n<p>其遍历序列与这个森林对应的<strong>二叉树的先序序列</strong>相同。</p>\n<p><strong>中序遍历森林</strong>（类似于树的后根遍历，先子树后根）<br>（若森林非空）</p>\n<ol>\n<li>中序遍历森林中第一棵树的根结点的子树森林。</li>\n<li>访问第一棵树的根结点。</li>\n<li>中序遍历除去第一棵树之后剩余的树构成的森林。</li>\n</ol>\n<p>其遍历序列与这个森林相应的<strong>二叉树的中序序列</strong>相同。</p>\n<h3 id=\"森林与二叉树的转换\"><a href=\"#森林与二叉树的转换\" class=\"headerlink\" title=\"森林与二叉树的转换\"></a>森林与二叉树的转换</h3><ul>\n<li>二叉树和树都可以用二叉链表作为存储结构。从物理结构上看，树的孩子兄弟表示法与二叉树的二叉链表表示法是相同的，因此可以用同一存储结构的不同解释将一棵树转换为二叉树。</li>\n</ul>\n<p><strong>1. 树转换为二叉树</strong></p>\n<p><img src=\"/articles/9eb01842/树变二叉树.jpg\" width=100%/></p>\n<p>树转换为二叉树的画法：</p>\n<ol>\n<li>在兄弟结点之间加一条线；</li>\n<li>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；</li>\n<li>以树根为轴心，顺时针旋转45°。</li>\n</ol>\n<p><strong>2. 森林转换为二叉树</strong><br>将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任意一棵树对应的二叉树的右子树必空，若把森林中第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应的二叉树当作第一棵二叉树根的右子树，将第三棵树对应的二叉树当作第二课二叉树根的右子树，以此类推，就可以将森林转换为二叉树。<br>森林转换为二叉树的画法：</p>\n<ol>\n<li>将森林中的每棵树转换成相应的二叉树；</li>\n<li>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；</li>\n<li>以第一棵树的根为轴心，顺时针旋转45°。</li>\n</ol>\n<p><strong>3. 二叉树转换为森林</strong></p>\n<p><img src=\"/articles/9eb01842/二叉树变森林.jpg\" width=100%/></p>\n<h3 id=\"森林结构的应用（例如）\"><a href=\"#森林结构的应用（例如）\" class=\"headerlink\" title=\"森林结构的应用（例如）\"></a>森林结构的应用（例如）</h3><h4 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h4><blockquote>\n<p>理解并查集的意义，以及掌握并查集的基本操作的实现</p>\n</blockquote>\n<p><strong>并查集的概念</strong><br>并查集是一种简单的集合表示，它支持以下3种操作：</p>\n<ol>\n<li>Initia(S): 将集合S中的每个元素都初始化为只有一个单元素的子集合。</li>\n<li>Union(S, Root1, Root2): 把集合S中的子集合Root2并入子集合Root1。要求Root1和Root2互不相交，否则不执行合并。</li>\n<li>Find(S, x): 查找集合S中单元素x所在的子集合，并返回该子集合的根结点。</li>\n</ol>\n<p><strong>并查集的存储结构</strong><br>通常用<strong>树的双亲表示</strong>作为并查集的存储结构，每个子集合以一棵树表示。所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内。<br>通常用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲域为负数（可设置为该子集合元素数量的相反数）。</p>\n<p><img src=\"/articles/9eb01842/并查集.jpg\" width=100%/></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//并查集的结构定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE 100</span></span><br><span class=\"line\"><span class=\"type\">int</span> UFSets[SIZE];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//并查集的初始化操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Initial</span><span class=\"params\">(<span class=\"type\">int</span> S[])</span> </span>&#123; <span class=\"comment\">//S即为并查集</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class=\"line\">    s[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查找操作</span></span><br><span class=\"line\"><span class=\"comment\">//判断两个元素是否属于同一个集合，只需分别找到它们的根，再比较根是否相同即可。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(S[x] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    x = S[x];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//合并操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> Root1, <span class=\"type\">int</span> Root2)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(Root1 == Root2) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  S[Root2] = S[Root1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//并查集实现的优化</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">在极端情况下，n个元素构成的集合树的深度为n，则Find操作的最坏时间复杂度为O(n)</span></span><br><span class=\"line\"><span class=\"comment\">改进：令根结点的绝对值＝集合树的成员数量，将小树合并到大树</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> Root1, <span class=\"type\">int</span> Root2)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(Root1 == Root2) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">abs</span>(S[Root2]) &lt; <span class=\"built_in\">abs</span>(S[Root1])) &#123; <span class=\"comment\">//Root2结点数更少</span></span><br><span class=\"line\">    S[Root1] += S[Root2];</span><br><span class=\"line\">    S[Root2] = Root1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    S[Root2] += S[Root1];</span><br><span class=\"line\">    S[Root1] = Root2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">采用这种方法构造得到的集合树，其深度不超过⌊log_2 n⌋+1</span></span><br><span class=\"line\"><span class=\"comment\">随着子集逐对合并，集合树的深度越来越大，</span></span><br><span class=\"line\"><span class=\"comment\">为了进一步减少确定元素所在集合的时间，还可优化Find操作，</span></span><br><span class=\"line\"><span class=\"comment\">即将从根到元素x路径上的所有元素都变成根的孩子</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> root = x;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(S[root] &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    root = S[root];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(x != root) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> t = S[x];</span><br><span class=\"line\">    S[x] = root;</span><br><span class=\"line\">    x = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">通过Find操作的“压缩路径”优化后，可使集合树的深度不超过O(α(n))，</span></span><br><span class=\"line\"><span class=\"comment\">其中α(n)是一个增长极其缓慢的函数，对于常见的正整数n，通常α(n)≤4。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或递归</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (S[x] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> S[x] = <span class=\"built_in\">Find</span>(S, S[x]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>什么是并查集？并查集主要用在什么地方？</strong><br>答：并查集又称为不相交集合，是表示集合的不相交子集合的一种集合表示，它主要有三种操作：初始化，查找和合并。并查集主要用于判断和构造等价类。</p>\n<p><strong>为什么并查集的实现采用树或森林的双亲数组？</strong><br>答：一般集合的实现采用位数组或有序链表，但这两种存储表示对于<strong>描述子集合的集合、查找某个集合元素在哪个子集合</strong>有一定的困难。<br>采用树或森林的双亲表示数组，同一子集合的元素位于同一棵树中，子集合的集合用森林表示，可以方便地实现查找和合并操作。</p>\n<p><strong>为什么在并查集的双亲数组中树（子集合）的根的双亲指针为负数？</strong><br>答：子集合用树的根来标识，根的双亲指针为负数，可区别树的根结点和树中的其他结点。该负数的绝对值可能表示的是树中结点的个数，也可能表示的是树的高度。</p>\n<p><strong>在合并操作<code>Merge(S, R1, R2)</code>中，为什么规定<code>R1</code>和<code>R2</code>是两棵树的根？</strong><br>答：若允许<code>R1</code>和<code>R2</code>是两棵树的任意结点，如让<code>R2</code>的双亲指针指向<code>R1</code>，可能会把以<code>R2</code>为根的子树从原来<code>R2</code>所在的树中脱离出去，造成运算错误。</p>\n<h2 id=\"六、图\"><a href=\"#六、图\" class=\"headerlink\" title=\"六、图\"></a>六、图</h2><h3 id=\"图的定义（包括）\"><a href=\"#图的定义（包括）\" class=\"headerlink\" title=\"图的定义（包括）\"></a>图的定义（包括）</h3><p>图G由顶点集V和边集E组成，记为G=(V,E)，其中V(G)表示图G中顶点的有限非空集，E(G)表示图G中顶点之间的关系（边）的集合。<br>若<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>=</mo><mrow><msub><mi>v</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>n</mi></msub></mrow></mrow><annotation encoding=\"application/x-tex\">V={v_1, v_2, \\cdots, v_n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>，则用|V|表示图G中顶点的个数，E={(u,v)|u∈V,v∈V}，用|E|表示图G中边的条数。</p>\n<h4 id=\"完全图（又称简单完全图）\"><a href=\"#完全图（又称简单完全图）\" class=\"headerlink\" title=\"完全图（又称简单完全图）\"></a>完全图（又称简单完全图）</h4><p>用n表示图中顶点数目，不考虑顶点到其自身的弧或边的情况下，<br>（无向图的边数目的取值范围：0到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{2}n(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，有向图的弧数目的取值范围：0到n(n-1)。）<br>有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{2}n(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>条边的无向图称为<strong>完全图</strong>；<br>有n(n-1)条弧的有向图称为<strong>有向完全图</strong>。<br>有很少条边或弧（如 e &lt; nlogn）的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong>。</p>\n<h4 id=\"连通图\"><a href=\"#连通图\" class=\"headerlink\" title=\"连通图\"></a>连通图</h4><p><strong>在无向图中</strong>，如果从顶点v到顶点w有路径存在，则称v和w是<strong>连通</strong>的。<br>若图中任意两个顶点都是连通的，则称其为<strong>连通图</strong>，否则称为<strong>非连通图</strong>。<br><strong>连通分量</strong>：<strong>无向图</strong>中的极大连通子图。</p>\n<p><strong>在有向图中</strong>，若有一对顶点v和w，从v到w和从w到v之间都有路径，则称这两个顶点是<strong>强连通</strong>的。<br>若图中任意一对顶点都是强连通的，则称此图为<strong>强连通图</strong>。<br><strong>强连通分量</strong>：<strong>有向图</strong>中的极大强连通子图。<br>若一张有向图的节点两两互相可达，则称这张图是<strong>强连通</strong>的 (strongly connected)。<br>若一张有向图的边替换为无向边后可以得到一张连通图，则称原来这张有向图是<strong>弱连通</strong>的 (weakly connected)。<br><strong>弱连通分量</strong>(weakly connected component)（极大弱连通子图）<br><strong>强连通分量</strong>(strongly connected component)（极大强连通子图）。</p>\n<h4 id=\"简单路径\"><a href=\"#简单路径\" class=\"headerlink\" title=\"简单路径\"></a>简单路径</h4><p><strong>路径：</strong>一个顶点到另一个顶点之间的<strong>顶点序列</strong>。<br><strong>路径长度：</strong>路径上的<strong>边（无向图）或弧（有向图）</strong>的数目。<br><strong>距离：</strong>从顶点u出发到顶点v的<strong>最短</strong>路径若存在，则<strong>此路径的长度</strong>称为从u到v的距离。若从u到v根本不存在路径，则记该距离为无穷（∞）。<br><strong>回路或环：</strong>第一个顶点和最后一个顶点相同的<strong>路径</strong>（说明是顶点序列）称为<strong>回路</strong>或<strong>环</strong>。<br><strong>简单路径：</strong>序列中顶点不重复出现的路径。<br><strong>简单回路或环：</strong>除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路。<br><strong>简单图：</strong>①不存在重复边；②不存在顶点到自身的边；的图。<br><strong>多重图：</strong>存在某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联的图。</p>\n<h4 id=\"有向图\"><a href=\"#有向图\" class=\"headerlink\" title=\"有向图\"></a>有向图</h4><p>有向图（Digraph）是由一组顶点和一组有向边组成的图。在有向图中，边有方向，即一条边从一个顶点指向另一个顶点。若存在一条边从顶点 A 指向顶点 B，则只能从 A 到 B，不能从 B 到 A。<br>弧是顶点地有序对，记为<v,w>，v称为<strong>弧尾</strong>，w称为<strong>弧头</strong>。</p>\n<p><v,w>称为从v到w的弧，也称v邻接到w。</p>\n<h4 id=\"无向图\"><a href=\"#无向图\" class=\"headerlink\" title=\"无向图\"></a>无向图</h4><p>无向图（Undigraph）是由一组顶点和一组无向边组成的图。在无向图中，边没有方向，即如果存在一条边连接顶点 A 和顶点 B，则可以从 A 到 B，也可以从 B 到 A。<br>边是顶点的无序对，记为(v, w)或(w,v)。<br>可以说w和v互为邻接点。<br>边(v,w)依附于w和v，或称边(v,w)和v，w相关联。</p>\n<h4 id=\"无环图\"><a href=\"#无环图\" class=\"headerlink\" title=\"无环图\"></a>无环图</h4><p><strong>在无环图中，从任何一个顶点出发，沿着图中的边所走的路径都不能回到该顶点。</strong><br>无环图有两种常见的类型：<strong>有向无环图（DAG）</strong>和<strong>无向无环图（UAG，又称森林）</strong>。<br><strong>注：</strong>①<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA\">无向、无环、连通图：树</a>#)；  ②<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA\">无向、无环图：森林</a>#%E6%A3%AE%E6%9E%97)。</p>\n<h4 id=\"等\"><a href=\"#等\" class=\"headerlink\" title=\"等\"></a>等</h4><p><strong>子图的定义</strong></p>\n<p>子图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo separator=\"true\">,</mo><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G&#x27; = (V&#x27;, E&#x27;) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 是图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G = (V, E) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span> 的一个子集，其中：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊆</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V&#x27; \\subseteq V </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8879em;vertical-align:-0.136em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> 的顶点集合的子集。</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊆</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E&#x27; \\subseteq E </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8879em;vertical-align:-0.136em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> 是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> 的边集合的子集，且 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">E&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> 中的每一条边都连接 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">V&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> 中的顶点。</li>\n</ul>\n<p><strong>真子图的定义</strong></p>\n<p>真子图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo separator=\"true\">,</mo><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G&#x27; = (V&#x27;, E&#x27;) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 是图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G = (V, E) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span> 的一个<strong>真子集</strong>，即：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊂</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V&#x27; \\subset V </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.791em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊂</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E&#x27; \\subset E </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.791em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>，并且至少有一个顶点或边不在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">G&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> 中。</li>\n</ul>\n<p><strong>注：</strong>真子图必须少于原图的顶点或边，不能与原图完全相同。</p>\n<p><strong>导出子图的定义</strong></p>\n<p>导出子图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo separator=\"true\">,</mo><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G&#x27; = (V&#x27;, E&#x27;) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 是由原图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G = (V, E) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span> 中的一个顶点子集 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊆</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V&#x27; \\subseteq V </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8879em;vertical-align:-0.136em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 生成的，且包含 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">V&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> 中顶点之间在原图中的所有边：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>E</mi><mo>∣</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo>∈</mo><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">E&#x27; = \\{(u, v) \\in E \\mid u, v \\in V&#x27;\\} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>\n</li>\n</ul>\n<p>导出子图是由顶点子集及其间所有连接边构成的子图。</p>\n<p><strong>生成子图（或支撑子图）的定义</strong></p>\n<p>对一张图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G = (V, E)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span> ，若存在另一张图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo separator=\"true\">,</mo><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G&#x27; = (V&#x27;, E&#x27;) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 满足 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V&#x27; = V </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊆</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E&#x27; \\subseteq E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8879em;vertical-align:-0.136em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> ，则称 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">G&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> 是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> 的 生成子图/支撑子图 (spanning subgraph)。</p>\n<p><strong>子图、真子图、导出子图和生成子图的区别</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>图类型</th>\n<th>定义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>子图</strong></td>\n<td>从原图中选取部分顶点和与之连接的部分边构成的图。</td>\n<td>可以是原图的任意部分，包括可能包含整个图。</td>\n</tr>\n<tr>\n<td><strong>真子图</strong></td>\n<td>是一个子图，但必须少于原图，即不等于原图。</td>\n<td>真子图不能包含原图的所有顶点和边。</td>\n</tr>\n<tr>\n<td><strong>导出子图</strong></td>\n<td>从原图中选取一个顶点集合，生成包含这些顶点和它们之间的所有边的子图。</td>\n<td>导出子图必须保留选定顶点之间的原始边，通常导出子图是从子集顶点产生的最小图。</td>\n</tr>\n<tr>\n<td><strong>生成子图</strong></td>\n<td>从原图中选取全部顶点和与之连接的部分边构成的图。</td>\n<td>生成子图G’中顶点个数V’必须和原图G中V的数量相同，而E’∈E即可。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>显然，原图 G 是自身的子图，支撑子图，导出子图；无边图 是 G 的支撑子图。</p>\n<p><strong>生成树：</strong>一个<strong>连通图（无向）</strong>的生成树是一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的n-1条边。</p>\n<ul>\n<li>如果在一棵生成树上添加一条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。</li>\n<li>一棵有n个顶点的生成树有且仅有n-1条边。<ol>\n<li>如果一个图有n个顶点和小于n-1条边，则是非连通图。</li>\n<li>如果它多于n-1条边，则一定有环。</li>\n<li>但是，有n-1条边的图不一定是生成树。</li>\n</ol>\n</li>\n</ul>\n<p>如果一个<strong>有向图</strong>恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵<strong>有向树</strong>。</p>\n<p><strong>生成森林：</strong>在非连通图中，连通分量的生成树构成了<strong>非连通图的生成森林</strong>。<br>一个<strong>有向图</strong>的<strong>生成森林</strong>由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的<strong>有向树</strong>的弧。</p>\n<p><strong>顶点的度、入度、出度</strong><br>在<strong>无向图</strong>中，顶点v的度是指依附于顶点v的边的条数，记为<strong>TD(v)</strong>。<br>无向图全部顶点的<strong>度之和</strong>等于<strong>边数的2倍</strong>，因为每条边和两个顶点相关联。<br>在<strong>有向图</strong>中，顶点v的度分为<strong>入度</strong>和<strong>出度</strong>，<strong>入度</strong>是以顶点v为终点的有向边的数目，记为<strong>ID(v)</strong>；而<strong>出度</strong>是以顶点v为起点的有向边的数目，记为<strong>OD(v)</strong>。顶点v的度<strong>TD(v)=ID(v)+OD(v)</strong>。<br>有向图的<strong>全部顶点的入度之和与出度之和</strong>相等，这是因为每条有向边都有一个起点和终点。</p>\n<p><strong>边的权和网</strong><br>在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的<strong>权值</strong>。<br>这种边上带有权值的图称为<strong>带权图</strong>，也称<strong>网</strong>。</p>\n<h3 id=\"图和二叉树、树和森林这种结构之间的异同点（明确理解）\"><a href=\"#图和二叉树、树和森林这种结构之间的异同点（明确理解）\" class=\"headerlink\" title=\"图和二叉树、树和森林这种结构之间的异同点（明确理解）\"></a>图和二叉树、树和森林这种结构之间的异同点（明确理解）</h3><p><a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA\">无向、无环、连通图：树</a>#)<br>森林是指互相不交并树的集合。<br><a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA\">无向、无环图：森林</a>#%E6%A3%AE%E6%9E%97)</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>结构</strong></th>\n<th><strong>连通性</strong></th>\n<th><strong>环的存在</strong></th>\n<th><strong>边的数量</strong></th>\n<th><strong>子节点数量</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>图</strong></td>\n<td>可以连通，也可以不连通</td>\n<td>可以有环</td>\n<td>没有固定要求</td>\n<td>没有限制</td>\n</tr>\n<tr>\n<td><strong>树</strong></td>\n<td>连通</td>\n<td>无环</td>\n<td>( n-1 )（( n ) 为顶点数）</td>\n<td>每个结点有且仅有一个父节点</td>\n</tr>\n<tr>\n<td><strong>二叉树</strong></td>\n<td>连通</td>\n<td>无环</td>\n<td>( n-1 )（( n ) 为顶点数）</td>\n<td>每个结点最多两个子节点</td>\n</tr>\n<tr>\n<td><strong>森林</strong></td>\n<td>不一定连通</td>\n<td>无环</td>\n<td>( n - k )（( k ) 为树的数量）</td>\n<td>每棵树都是一棵独立的无环连通树</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"图的存储（包括）\"><a href=\"#图的存储（包括）\" class=\"headerlink\" title=\"图的存储（包括）\"></a>图的存储（包括）</h3><h4 id=\"邻接矩阵法\"><a href=\"#邻接矩阵法\" class=\"headerlink\" title=\"邻接矩阵法\"></a>邻接矩阵法</h4><ul>\n<li>所谓<strong>邻接矩阵存储</strong>，是指用一个一维矩阵存储图中顶点的信息，用一个二维矩阵存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为<strong>邻接矩阵</strong>。</li>\n<li>顶点数为n的图的邻接矩阵A是n×n的。通常用0或∞来代表两个顶点之间不存在边。</li>\n<li><strong>无向图</strong>的邻接矩阵是<strong>对称矩阵</strong>，对规模特大的邻接矩阵可采用压缩存储。</li>\n<li><strong>空间复杂度</strong>为O(n)，其中n为图的顶点数|V|。</li>\n<li>对于<strong>无向图</strong>，邻接矩阵的第i行（或列）非零（或∞）元素的个数正好是顶点i的度TD(i)。</li>\n<li>对于<strong>有向图</strong>，i行-&gt;出度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mi>D</mi><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">OD(v_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，i列-&gt;入度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mi>D</mi><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ID(v_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n<li>设图G的邻接矩阵为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mtext>，</mtext><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">A \\text{，} A^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">，</span></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>的元素<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mi>n</mi></msup><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A^n[i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span>等于由顶点i到顶点j的长度为n的路径的数目。</li>\n</ul>\n<h4 id=\"邻接表法\"><a href=\"#邻接表法\" class=\"headerlink\" title=\"邻接表法\"></a>邻接表法</h4><ul>\n<li>所谓邻接表，是指对图G中的每个顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 建立一个单链表，第i个单链表中的结点表示依附于顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的边（对于有向图则是以顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 为尾的弧），这个单链表就称为顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的<strong>边表</strong>（对于有向图则称为<strong>出边表</strong>）。边表的头指针和顶点的数据信息采用顺序存储，称为<strong>顶点表</strong>，所以在邻接表中存在两种结点：顶点表和边表结点。</li>\n<li><strong>顶点表结点</strong>由两个域组成：顶点域（data）存储顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的相关信息，边表头指针域（firstarc）指向第一条边的边表结点。</li>\n<li><strong>边表结点</strong>至少由两个域组成：邻接点域（adjvex）存储与头结点顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 邻接的顶点编号，指针域（nextarc）指向下一条边的边表结点。</li>\n<li><strong>空间复杂度：</strong>无向图-&gt;O(|V|+2|E|)，有向图-&gt;O(|V|+|E|)。</li>\n<li>找有向图的入度必须遍历整个邻接表。</li>\n<li>图的邻接表表示法并<strong>不唯一</strong>，因为在每个顶点对应的边表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。</li>\n</ul>\n<h4 id=\"差异性\"><a href=\"#差异性\" class=\"headerlink\" title=\"差异性\"></a>差异性</h4><blockquote>\n<p>掌握图采用邻接矩阵和邻接表进行存储的差异性</p>\n</blockquote>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>邻接矩阵</th>\n<th>邻接表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>空间复杂度</strong></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(V^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td>无向图：O(V + 2E)，有向图：O(V + E)</td>\n</tr>\n<tr>\n<td><strong>找相邻边</strong></td>\n<td>需要遍历整行或列，O(V)</td>\n<td>找有向图的入度必须遍历整个邻接表</td>\n</tr>\n<tr>\n<td><strong>删除边或顶点</strong></td>\n<td>删除边很方便，删除顶点需要大量移动数据</td>\n<td>无向图中删除边或顶点都不方便</td>\n</tr>\n<tr>\n<td><strong>适用图类型</strong></td>\n<td>稠密图（图中的边较多）</td>\n<td>稀疏图（图中的边较少）</td>\n</tr>\n<tr>\n<td><strong>表示方式</strong></td>\n<td>唯一</td>\n<td>不唯一</td>\n</tr>\n<tr>\n<td><strong>实现难度</strong></td>\n<td>简单</td>\n<td>稍复杂</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"十字链表（大纲这里没写）\"><a href=\"#十字链表（大纲这里没写）\" class=\"headerlink\" title=\"十字链表（大纲这里没写）\"></a>十字链表（大纲这里没写）</h4><p>十字链表是<strong>有向图</strong>的一种链式存储结构。在十字链表中，有向图的每条弧用一个结点（弧结点）来表示，每个结点（顶点结点）来表示。<br>弧结点有5个域：</p>\n<ul>\n<li><code>tailvex</code>和<code>headvex</code>两个域分别指示狐尾和弧头这两个顶点的编号；</li>\n<li>头链域<code>hlink</code>指向弧头相同的下一个弧结点；</li>\n<li>尾链域<code>tlink</code>指向弧尾相同的下一个弧结点；</li>\n<li><code>info</code>域存放该弧的相关信息。</li>\n</ul>\n<p>顶点结点中有3个域：</p>\n<ul>\n<li><code>data</code>域存放该顶点的数据信息，如顶点名称；</li>\n<li><code>firstin</code>域指向以该顶点为弧头的第一个弧结点；</li>\n<li><code>firstout</code>域指向以该顶点为弧尾的第一个弧结点。</li>\n</ul>\n<p>弧结点</p>\n<table>\n  <tr>\n    <td style=\"border: 1px solid; text-align: center;\">tailvex</td>\n    <td style=\"border: 1px solid; text-align: center;\">headvex</td>\n    <td style=\"border: 1px solid; text-align: center;\">hlink</td>\n    <td style=\"border: 1px solid; text-align: center;\">tlink</td>\n    <td style=\"border: 1px solid; text-align: center;\">(info)</td>\n  </tr>\n</table>\n\n<p>顶点结点</p>\n<table>\n  <tr>\n    <td style=\"border: 1px solid; text-align: center;\">data</td>\n    <td style=\"border: 1px solid; text-align: center;\">firstin</td>\n    <td style=\"border: 1px solid; text-align: center;\">firstout</td>\n  </tr>\n</table>\n\n<p><img src=\"/articles/9eb01842/十字链表.jpg\" width=100%/></p>\n<p>注意，顶点结点之间是顺序存储的，弧结点省略了info域。<br>在十字链表中，既容易找到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>为尾的弧，也容易找到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>为头的弧，因而容易求得顶点的出度和入度。图的十字链表表示是不唯一的，但一个十字链表表示唯一确定的图。</p>\n<h4 id=\"邻接多重表（大纲这里没写）\"><a href=\"#邻接多重表（大纲这里没写）\" class=\"headerlink\" title=\"邻接多重表（大纲这里没写）\"></a>邻接多重表（大纲这里没写）</h4><p>邻接多重表是<strong>无向图</strong>的一种链式存储结构。在邻接表中，容易求得顶点和边得各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点得边表中遍历，效率极低。<br>与十字链表类似，在邻接多重表中，每条边用一个结点表示，每个顶点也用一个结点表示。<br>边结点</p>\n<table>\n  <tr>\n    <td style=\"border: 1px solid; text-align: center;\">ivex</td>\n    <td style=\"border: 1px solid; text-align: center;\">ilink</td>\n    <td style=\"border: 1px solid; text-align: center;\">jvex</td>\n    <td style=\"border: 1px solid; text-align: center;\">jlink</td>\n    <td style=\"border: 1px solid; text-align: center;\">(info)</td>\n  </tr>\n</table>\n\n<ul>\n<li><code>ivex</code>和<code>jvex</code>这两个域指示该边依附的两个顶点的编号；</li>\n<li><code>ilink</code>域指向下一条依附于顶点ivex的边；</li>\n<li><code>jlink</code>域指向下一条依附于顶点jvex的边；</li>\n<li><code>info</code>域存放该边的相关信息。</li>\n</ul>\n<p>顶点结点</p>\n<table>\n  <tr>\n    <td style=\"border: 1px solid; text-align: center;\">data</td>\n    <td style=\"border: 1px solid; text-align: center;\">firstedge</td>\n  </tr>\n</table>\n\n<ul>\n<li><code>data</code>域存放该顶点的相关信息；</li>\n<li><code>firstedge</code>域指向第一条依附于该顶点的边。</li>\n</ul>\n<p>在邻接多重表中，所有依附于同一顶点的边串联在同一链表中；因为每条边依附于两个顶点，所以每个边结点同时链接在两个链表中。<br>对无向图而言，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。</p>\n<p><img src=\"/articles/9eb01842/邻接多重表.jpg\" width=100%/></p>\n<p><img src=\"/articles/9eb01842/四存区别.jpg\" width=100%/></p>\n<h3 id=\"图的基本操作\"><a href=\"#图的基本操作\" class=\"headerlink\" title=\"图的基本操作\"></a>图的基本操作</h3><p>略</p>\n<h3 id=\"图的两种遍历\"><a href=\"#图的两种遍历\" class=\"headerlink\" title=\"图的两种遍历\"></a>图的两种遍历</h3><ul>\n<li>图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的<strong>所有顶点</strong>访问一次，且仅访问一次。</li>\n<li>注意树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的遍历。</li>\n</ul>\n<h4 id=\"广度优先遍历\"><a href=\"#广度优先遍历\" class=\"headerlink\" title=\"广度优先遍历\"></a>广度优先遍历</h4><ul>\n<li>Breadth-First-Search, BFS</li>\n<li>Dijkstra单源最短路径算法和Prim最小生成树算法也应用了类似的思想。</li>\n<li>逐层访问，不回溯。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//标准写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph, vector&lt;<span class=\"type\">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(start);</span><br><span class=\"line\">    visited[start] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> node = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历当前结点的邻接结点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> neighbor : graph[node]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[neighbor]) &#123;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(neighbor);</span><br><span class=\"line\">                visited[neighbor] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//邻接表法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(AlGraph G, <span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">  visited[i] = TRUE;</span><br><span class=\"line\">  <span class=\"built_in\">EnQueue</span>(Q, i);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!<span class=\"built_in\">IsEmpty</span>(Q)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">DeQueue</span>(Q, v); <span class=\"comment\">//队首顶点v出队</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (p = G.vertices[v].firstarc; p; p = p -&gt; nextarc) &#123;</span><br><span class=\"line\">      w = p -&gt; adjvex;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(visited[w] == FALSE) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">visit</span>(w);</span><br><span class=\"line\">        visited[w] = TRUE;</span><br><span class=\"line\">        <span class=\"built_in\">EnQueue</span>(Q, w);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//邻接矩阵法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(MGraph G, <span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">  visited[i] = TRUE;</span><br><span class=\"line\">  <span class=\"built_in\">EnQueue</span>(Q, i);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!<span class=\"built_in\">IsEmpty</span>(Q)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">DeQueue</span>(Q, v);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (w = <span class=\"number\">0</span>; w &lt; G.vexnum; w ++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(visited[w] == FALSE &amp;&amp; G.edge[v][w] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">visit</span>(w);</span><br><span class=\"line\">        visited[w] = TRUE;</span><br><span class=\"line\">        <span class=\"built_in\">EnQueue</span>(Q, w);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>图的广度优先遍历是二叉树的层次遍历算法的扩展。</li>\n<li>最坏时间复杂度为O(|V|)。</li>\n<li>邻接表时间复杂度为O(|V|+|E|)，因为每个顶点均需搜索（或入队）一次（O(|V|)），在搜索每个顶点的邻接点时，每条边至少访问一次（O(|E|)）。</li>\n<li>邻接矩阵时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 求非带权图的单源最短路径</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">shortestPath</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = graph.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">distance</span><span class=\"params\">(n, <span class=\"number\">-1</span>)</span></span>; <span class=\"comment\">// 距离数组，初始化为-1表示未访问</span></span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    </span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(start);</span><br><span class=\"line\">    distance[start] = <span class=\"number\">0</span>; <span class=\"comment\">// 起始结点到自身的距离为0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> node = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> neighbor : graph[node]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (distance[neighbor] == <span class=\"number\">-1</span>) &#123; <span class=\"comment\">// 如果未访问</span></span><br><span class=\"line\">                distance[neighbor] = distance[node] + <span class=\"number\">1</span>; <span class=\"comment\">// 更新最短距离</span></span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(neighbor);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> distance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>广度优先生成树</strong></p>\n<ul>\n<li>同一个图的邻接矩阵存储表示是唯一的，所以广度优先生成树也是唯一的。</li>\n<li>但因为邻接表存储表示不唯一，所以广度优先生成树也是不唯一的。</li>\n</ul>\n<h4 id=\"深度优先遍历\"><a href=\"#深度优先遍历\" class=\"headerlink\" title=\"深度优先遍历\"></a>深度优先遍历</h4><ul>\n<li>Depth-First-Search, DFS</li>\n<li>类似于树的先序遍历。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 递归实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS_recursive</span><span class=\"params\">(<span class=\"type\">int</span> node, <span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph, vector&lt;<span class=\"type\">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class=\"line\">    visited[node] = <span class=\"literal\">true</span>; <span class=\"comment\">// 标记当前结点为已访问</span></span><br><span class=\"line\">    cout &lt;&lt; node &lt;&lt; <span class=\"string\">&quot; &quot;</span>;  <span class=\"comment\">// 输出当前访问的结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> neighbor : graph[node]) &#123; <span class=\"comment\">// 遍历相邻结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[neighbor]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">DFS_recursive</span>(neighbor, graph, visited); <span class=\"comment\">// 递归访问未访问的结点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//非递归</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS_iterative</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(graph.size(), <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\">    s.<span class=\"built_in\">push</span>(start);</span><br><span class=\"line\">    visited[start] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> node = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        cout &lt;&lt; node &lt;&lt; <span class=\"string\">&quot; &quot;</span>; <span class=\"comment\">// 输出当前访问的结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> neighbor : graph[node]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[neighbor]) &#123;</span><br><span class=\"line\">                s.<span class=\"built_in\">push</span>(neighbor);</span><br><span class=\"line\">                visited[neighbor] = <span class=\"literal\">true</span>; <span class=\"comment\">// 标记为已访问，防止重复入栈</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//邻接表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(ALGraph G, <span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">  visited[i] == TRUE;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (p = G.vertices[i]; p; p = p -&gt; nextarc) &#123;</span><br><span class=\"line\">    j = p -&gt; adjvex;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(visited[j] == FALSE) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">DFS</span>(G, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//邻接矩阵</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(MGraph G, <span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">  visited[i] = TRUE;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; G.vexnum; j ++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(visited[j] == FALSE &amp;&amp; G.edge[i][j] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">DFS</span>(G, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>图的邻接矩阵表示是唯一的，但对邻接表来说，若边的输入次序不同，则生成的邻接表也不同。</li>\n<li><p>因此，对于同一张图，基于<strong>邻接矩阵</strong>的遍历得到的DFS序列和BFS序列是唯一的，基于<strong>邻接表</strong>的遍历得到的DFS序列和BFS序列是不唯一的。</p>\n</li>\n<li><p>空间复杂度为O(|V|)。</p>\n</li>\n<li>邻接表O(|V|+|E|)，邻接矩阵<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n<li>连通图-深度优先生成树，非连通图-深度优先生成森林。</li>\n<li>与BFS类似，基于邻接表存储的深度优先生成树是不唯一的。</li>\n</ul>\n<h4 id=\"图的遍历与图的连通性\"><a href=\"#图的遍历与图的连通性\" class=\"headerlink\" title=\"图的遍历与图的连通性\"></a>图的遍历与图的连通性</h4><ul>\n<li><strong>图的遍历算法可以用来判断图的连通性。</strong></li>\n<li>对于有向图来说，若从初始顶点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。</li>\n</ul>\n<h3 id=\"图的基本应用（包括）\"><a href=\"#图的基本应用（包括）\" class=\"headerlink\" title=\"图的基本应用（包括）\"></a>图的基本应用（包括）</h3><h4 id=\"最小支撑树（最小生成树）\"><a href=\"#最小支撑树（最小生成树）\" class=\"headerlink\" title=\"最小支撑树（最小生成树）\"></a>最小支撑树（最小生成树）</h4><ul>\n<li>一个连通图的<strong>生成树</strong>包含图的所有顶点，并且只含尽可能少的边。</li>\n<li>对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路。</li>\n<li>对于<strong>带权连通无向图</strong>G，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。权值之和最小的那棵生成树称为G的<strong>最小生成树</strong>。</li>\n<li>①若图G存在权值相同的边，则G的最小生成树<strong>可能</strong>不唯一；②当G中的各边权值互不相等时，G的最小生成树是唯一的；③若无向连通图G的边数比顶点数少一，即G本身是一棵树时，则G的最小生成树就是它本身。</li>\n<li>虽然最小生成树（树形）不唯一，但其对应的边的权值之和总是唯一的，而且是最小的。</li>\n<li>最小生成树的边数为顶点数-1。</li>\n<li><strong>注意：</strong>最小生成树中所有边的权值之和最小，但不能保证任意两个顶点之间的路径是最短路径。</li>\n</ul>\n<p>Prim和Kruskal都基于贪心算法。</p>\n<ul>\n<li><p><strong>Prim算法</strong></p>\n<blockquote>\n<p>（记忆：PV (Prim vertices)，经常写博客会注重page view）</p>\n</blockquote>\n</li>\n<li><p>假设<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G=(V,T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span></span></span></span>是连通图，其最小生成树<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>U</mi><mo separator=\"true\">,</mo><msub><mi>E</mi><mi>T</mi></msub><mo stretchy=\"false\">)</mo><mtext>，</mtext><msub><mi>E</mi><mi>T</mi></msub></mrow><annotation encoding=\"application/x-tex\">T=(U,E_T)，E_T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>是最小生成树中边的集合。</p>\n</li>\n<li>初始化：向空树<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>U</mi><mo separator=\"true\">,</mo><msub><mi>E</mi><mi>T</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T=(U,E_T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>中添加图<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G=(V,E)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span>的任意一个顶点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>u</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">u_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，使<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>=</mo><msub><mi>u</mi><mn>0</mn></msub><mtext>，</mtext><msub><mi>E</mi><mi>T</mi></msub><mo>=</mo><mtext>Ø</mtext></mrow><annotation encoding=\"application/x-tex\">U={u_0}，E_T=Ø</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">，</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7806em;vertical-align:-0.0486em;\"></span><span class=\"mord\">Ø</span></span></span></span>。</li>\n<li>循环（重复下列操作直至<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>=</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">U=V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>：从图G中选择满足<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∣</mi><mi>u</mi><mo>∈</mo><mi>U</mi><mo separator=\"true\">,</mo><mi>v</mi><mo>∈</mo><mi>V</mi><mo>−</mo><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">{(u,v)|u∈U, v∈V-U}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span></span>且具有最小权值的边(u,v)，加入树T，置<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>=</mo><mi>U</mi><mo>∪</mo><mi>v</mi><mtext>，</mtext><msub><mi>E</mi><mi>T</mi></msub><mo>=</mo><msub><mi>E</mi><mi>T</mi></msub><mo>∪</mo><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">U=U∪{v}，E_T=E_T∪{(u,v)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span><span class=\"mord cjk_fallback\">，</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span></span>。</li>\n<li><p>Prim算法的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，不依赖于|E|，因此它适用于求解<strong>边稠密</strong>的图的最小生成树。</p>\n</li>\n<li><p><strong>Kruskal算法</strong></p>\n</li>\n<li>假设<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G=(V,E)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span>是连通图，其最小生成树<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>U</mi><mo separator=\"true\">,</mo><msub><mi>E</mi><mi>T</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T=(U, E_T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>初始化：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>=</mo><mi>V</mi><mo separator=\"true\">,</mo><msub><mi>E</mi><mi>T</mi></msub><mo>=</mo><mtext>Ø</mtext></mrow><annotation encoding=\"application/x-tex\">U=V, E_T=Ø</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7806em;vertical-align:-0.0486em;\"></span><span class=\"mord\">Ø</span></span></span></span>。即每个顶点构成一棵独立的树，T此时是一个仅含|V|个顶点的森林。</li>\n<li>循环（重复直至T是一棵树）：按G的边的权值递增顺序依次从<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>−</mo><msub><mi>E</mi><mi>T</mi></msub></mrow><annotation encoding=\"application/x-tex\">E-E_T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>中选择一条边，若这条边加入T后不构成回路，则将其加入T后不构成回路，则将其加入<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>E</mi><mi>T</mi></msub></mrow><annotation encoding=\"application/x-tex\">E_T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，否则舍弃，直到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>E</mi><mi>T</mi></msub></mrow><annotation encoding=\"application/x-tex\">E_T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>中含有n-1条边。</li>\n<li>在Kruskal算法中，最坏情况需要对|E|条边各扫描一次。通常采用堆来存放边的集合，每次选择最小权值的边需要<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log_2|E|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span>的时间；每次使用并查集来快速判断两个顶点是否属于一个集合所需的时间为O(α(|V|))，α(|V|)的增长极其缓慢，可视为常数。</li>\n<li>算法的总时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|E|log_2|E|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span>，不依赖于|V|，因此Kruskal算法适合于<strong>边稀疏而顶点较多</strong>的图。</li>\n</ul>\n<h4 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h4><ul>\n<li><strong>Dijkstra算法</strong></li>\n<li>求单源最短路径问题</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">int</span> n, <span class=\"type\">const</span> vector&lt;vector&lt;Edge&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(n, INT_MAX)</span></span>; <span class=\"comment\">// 初始化所有节点的距离为无穷大</span></span><br><span class=\"line\">    dist[start] = <span class=\"number\">0</span>; <span class=\"comment\">// 起点到自己的距离为0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    priority_queue&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;, vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;, greater&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;&gt; pq;</span><br><span class=\"line\">    pq.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>, start&#125;); <span class=\"comment\">// 将起点加入优先队列</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!pq.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> [d, u] = pq.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        pq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (d &gt; dist[u]) <span class=\"keyword\">continue</span>; <span class=\"comment\">// 已有更短路径，跳过</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; edge : graph[u]) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> v = edge.to;</span><br><span class=\"line\">            <span class=\"type\">int</span> weight = edge.weight;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dist[u] + weight &lt; dist[v]) &#123;</span><br><span class=\"line\">                dist[v] = dist[u] + weight;</span><br><span class=\"line\">                pq.<span class=\"built_in\">push</span>(&#123;dist[v], v&#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dist;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用邻接矩阵表示时，时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。使用带权的邻接表表示时，虽然修改dist[]的时间可以减少，但由于在dist[]中选择最小分量的时间不变，所以时间复杂度仍为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>人们可能只希望找到从源点到某个特定顶点的最短路径，但这个问题和求解源点到其他所有顶点的最短路径一样复杂，时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>不适合负权。</li>\n</ul>\n<ul>\n<li><strong>BellmanFord算法</strong></li>\n</ul>\n<ol>\n<li>算法步骤<br>假设图中有 𝑉 个节点和 𝐸 条边，起点为 start，算法的主要步骤如下：<br>① <strong>初始化：</strong>将起点到自身的距离设为0，其他节点的初始距离设为无穷大（表示不可达）。<br>② <strong>松弛边：</strong>重复 𝑉−1 次，对所有边进行松弛操作。<ul>\n<li>对于每一条边 (u, v, weight)，如果 dist[u] + weight &lt; dist[v]，则更新 dist[v] = dist[u] + weight。</li>\n<li>之所以重复 𝑉−1 次，是因为最短路径最多包含 𝑉−1 条边，多余的边不会影响路径长度。<br>③ <strong>检测负环：</strong>在执行完𝑉−1 轮松弛操作后，再对所有边执行一次松弛操作。如果此时还能找到更短路径（即 dist[u] + weight &lt; dist[v] 依然成立），则说明图中存在负权回路（负环）。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">bellmanFord</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> start, <span class=\"type\">const</span> vector&lt;Edge&gt;&amp; edges, vector&lt;<span class=\"type\">int</span>&gt;&amp; dist)</span> </span>&#123;</span><br><span class=\"line\">    dist.<span class=\"built_in\">assign</span>(n, INT_MAX);</span><br><span class=\"line\">    dist[start] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进行 n-1 次松弛操作</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; edge : edges) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dist[edge.from] != INT_MAX &amp;&amp; dist[edge.from] + edge.weight &lt; dist[edge.to]) &#123;</span><br><span class=\"line\">                dist[edge.to] = dist[edge.from] + edge.weight;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 检测负环</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; edge : edges) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dist[edge.from] != INT_MAX &amp;&amp; dist[edge.from] + edge.weight &lt; dist[edge.to]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 存在负环</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 没有负环</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用于求单源最短路径，支持带负权边的图。Bellman-Ford的时间复杂度为O(V×E)，可以检测负权回路（负环）。<br>适合稀疏图：在稀疏图中（边数较少的图），Bellman-Ford的效率较高，但在稠密图中效率不如Floyd-Warshall。</p>\n<ul>\n<li><strong>Floyd算法</strong></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> INF = INT_MAX;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">floydWarshall</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; dist)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; n; ++k) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dist[i][k] != INF &amp;&amp; dist[k][j] != INF) &#123;</span><br><span class=\"line\">                    dist[i][j] = <span class=\"built_in\">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用于求解任意两点之间的最短路径。该算法的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，适用于较小规模的稠密图。</li>\n<li>Floyd算法允许出现带负权值的边，但是不允许有包含<strong>带负权值的边</strong>组成的<strong>回路</strong>。</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>Dijkstra：快速且适合无负权边的单源最短路径。<br>Floyd-Warshall：适合小规模图的任意两点最短路径，但无法处理负环。<br>Bellman-Ford：支持负权边且能检测负环，适合较低效率需求的单源最短路径。</p>\n<ol>\n<li><p><strong>Bellman-Ford算法</strong><br><strong>回路检测能力：</strong>Bellman-Ford可以检测<strong>负权回路（负环）</strong>。在执行完 𝑉−1 轮松弛操作后，如果还能进一步松弛，说明图中存在负权回路。<br><strong>适用场景：</strong>当我们需要检测负权回路，或者在存在负权边的图中寻找单源最短路径时，Bellman-Ford非常适用。</p>\n<blockquote>\n<p><strong>①Bellman-Ford算法能算出负权回路的最小路径吗？</strong><br><strong>不能算出负权回路的最小路径：</strong>Bellman-Ford算法确实只能检测到负权回路的存在，但无法求出包含负权回路的最小路径。<br><strong>为什么无法求出最小路径：</strong>因为负权回路的性质是可以让路径不断缩短——随着每次通过负权回路，路径权重会持续降低。因此，如果图中存在负权回路，任意包含该回路的路径长度可以趋近负无穷大。<br><strong>结论：</strong>一旦图中有负权回路，Bellman-Ford就无法得到正确的最短路径，只能返回一个错误标志，提示“图中存在负权回路”。<br><strong>②带负权回路的图是否能求最小路径？</strong><br><strong>带负权回路的图整体上不能求最小路径：</strong>如果图中有负权回路，且这个回路能够从起点达到（即负权回路在从起点到某个节点的路径中），则不存在“最短路径”，因为我们可以沿着负权回路无限循环，让路径长度趋向负无穷。<br><strong>局部求解：</strong>如果负权回路在图中的某个孤立部分，并不影响起点到其他节点的路径，则在受影响的节点之外，我们仍然可以使用Bellman-Ford求出正确的最短路径。但一般情况下，一旦存在负权回路就难以求得全局最短路径。</p>\n</blockquote>\n</li>\n<li><p><strong>Dijkstra算法</strong><br><strong>回路检测能力：</strong>Dijkstra不能检测回路，也无法正确处理负权边。<br><strong>适用场景：</strong>主要用于无负权边的图的单源最短路径问题。</p>\n<blockquote>\n<p><strong>①Dijkstra是不是连普通的回路都不能检测？</strong><br><strong>Dijkstra无法检测回路：</strong>Dijkstra算法的设计初衷是用于求解无负权边的单源最短路径，因此它不具备回路检测能力。<br><strong>为什么无法检测回路：</strong>Dijkstra假设路径是单调递增的，因此一旦确定某个节点的最短路径后，它不会再访问该节点，也不会追踪是否形成回路。这种设计避免了多次访问同一节点，但也因此放弃了回路检测的能力。<br><strong>结论：</strong>Dijkstra既不能检测负权回路，也不能检测普通回路。<br><strong>②为什么Dijkstra不能正确处理负权边？</strong><br><strong>Dijkstra的贪心策略依赖非负权边</strong>，一旦节点的最短路径确定，它不会再更改。如果存在负权边，后续路径可能提供更短的路径，贪心策略就被破坏。<br><strong>负权边破坏了路径长度递增的假设</strong>，Dijkstra没有更新已确定最短路径的机制，因此最终结果可能不正确。</p>\n</blockquote>\n</li>\n<li><p><strong>Floyd-Warshall算法</strong><br><strong>回路检测能力：</strong>Floyd-Warshall不直接检测回路，但可以在结果矩阵中检测到负权回路。<br><strong>方法：</strong>如果在计算过程中发现 dist[i][i] &lt; 0（即一个节点到自身的最短路径为负值），则说明存在负权回路。<br><strong>适用场景：</strong>适用于较小规模的图，可以同时解决任意两点的最短路径问题。</p>\n<blockquote>\n<p><strong>注：</strong>利用dist[i][i] &lt; 0条件不一定能判出存在“带有负权值的边组成的回路”<strong>（但负环的定义是跑一圈是负数）</strong>，因为比如某个负环走一圈仍是正的，如图所示。</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"/articles/9eb01842/Floyd判负环.png\" width=50% height=70% /></p>\n<ol>\n<li><strong>BFS算法</strong><br><strong>回路检测能力：</strong>在无向图和有向图中，BFS都可以检测到回路。<br><strong>无向图：</strong>如果在遍历过程中遇到一个已经访问过的邻居节点，且该邻居节点不是当前节点的父节点，则存在回路。<br><strong>有向图：</strong>如果在遍历过程中遇到一个已经在当前访问路径中的节点（即一个祖先节点），则存在回路。<br><strong>适用场景：</strong>主要用于无权图中的最短路径和环检测，尤其在广度优先搜索遍历时很适用。</li>\n</ol>\n<blockquote>\n<p>BFS算法可以算边权相同情况下的最短路径。</p>\n</blockquote>\n<p><strong>使用BFS检测无向图中的回路</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">bfsCycle</span><span class=\"params\">(<span class=\"type\">int</span> start, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph, vector&lt;<span class=\"type\">int</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class=\"line\">    queue&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; q;</span><br><span class=\"line\">    visited[start] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(&#123;start, <span class=\"number\">-1</span>&#125;); <span class=\"comment\">// 存储节点和父节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> node = q.<span class=\"built_in\">front</span>().first;</span><br><span class=\"line\">        <span class=\"type\">int</span> parent = q.<span class=\"built_in\">front</span>().second;</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> neighbor : graph[node]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[neighbor]) &#123;</span><br><span class=\"line\">                visited[neighbor] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(&#123;neighbor, node&#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (neighbor != parent) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 找到回路</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[i] &amp;&amp; <span class=\"built_in\">bfsCycle</span>(i, graph, visited)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">4</span>;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; graph = &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;,  <span class=\"comment\">// 节点 0 -&gt; 节点 1 和 节点 2</span></span><br><span class=\"line\">        &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>&#125;,  <span class=\"comment\">// 节点 1 -&gt; 节点 0 和 节点 2</span></span><br><span class=\"line\">        &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>&#125;,  <span class=\"comment\">// 节点 2 -&gt; 节点 0, 节点 1 和 节点 3</span></span><br><span class=\"line\">        &#123;<span class=\"number\">2</span>&#125;     <span class=\"comment\">// 节点 3 -&gt; 节点 2</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">hasCycle</span>(graph, n)) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;图中存在回路&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;图中不存在回路&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li><strong>DFS算法</strong><br><strong>回路检测能力：</strong>DFS同样可以检测回路，是一种常用的回路检测方法。<br><strong>无向图：</strong>如果在遍历过程中遇到一个已经访问过的邻居节点，且该邻居节点不是当前节点的父节点，则存在回路。<br><strong>有向图：</strong>DFS通过维护一个访问状态数组来检测环。在遍历过程中，如果遇到一个正在访问的节点（即当前路径中的祖先节点），则存在回路。<br><strong>适用场景：</strong>DFS广泛用于图遍历和回路检测，包括拓扑排序、检测强连通分量等。</li>\n</ol>\n<blockquote>\n<p>DFS算法不能求最短路径。</p>\n</blockquote>\n<p><strong>使用DFS检测有向图中的回路</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> node, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph, vector&lt;<span class=\"type\">int</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class=\"line\">    visited[node] = <span class=\"number\">1</span>; <span class=\"comment\">// 标记当前节点正在访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> neighbor : graph[node]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[neighbor] == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 未访问过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">dfs</span>(neighbor, graph, visited)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 找到环</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (visited[neighbor] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 遇到正在访问的节点，说明存在回路</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    visited[node] = <span class=\"number\">2</span>; <span class=\"comment\">// 标记当前节点已访问完毕</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// 0-未访问, 1-正在访问, 2-已访问完毕</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[i] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">dfs</span>(i, graph, visited)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">4</span>; <span class=\"comment\">// 节点数</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; graph = &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">1</span>&#125;,      <span class=\"comment\">// 节点 0 -&gt; 节点 1</span></span><br><span class=\"line\">        &#123;<span class=\"number\">2</span>&#125;,      <span class=\"comment\">// 节点 1 -&gt; 节点 2</span></span><br><span class=\"line\">        &#123;<span class=\"number\">0</span>, <span class=\"number\">3</span>&#125;,   <span class=\"comment\">// 节点 2 -&gt; 节点 0 和 节点 3</span></span><br><span class=\"line\">        &#123;&#125;        <span class=\"comment\">// 节点 3 没有相邻节点</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">hasCycle</span>(graph, n)) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;图中存在回路&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;图中不存在回路&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><img src=\"/articles/9eb01842/最短路径总结表格.jpg\" width=100% height=70% /></p>\n<h4 id=\"有向无环图描述表达式（考点无）\"><a href=\"#有向无环图描述表达式（考点无）\" class=\"headerlink\" title=\"有向无环图描述表达式（考点无）\"></a>有向无环图描述表达式（考点无）</h4><p>王道p246<br>在二叉树描述表达式的基础上，实现对相同子式的共享，从而节省存储空间。</p>\n<h4 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h4><ul>\n<li><strong>AOV网：</strong>若用有向无环图（DAG）表示一个工程，其顶点表示活动，用有向边<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><msub><mi>V</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>V</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;V_i,V_j&gt;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span>表示活动<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>必须先于活动<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>进行的这样一种关系，则将这种有向图称为<strong>顶点表示活动的网络</strong>，简称<strong>AOV网</strong>。</li>\n<li>任何活动<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>不能以它自己作为自己的前驱或后继。</li>\n<li><p><strong>拓扑排序：</strong>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：</p>\n<ol>\n<li>每个顶点出现且仅出现一次。</li>\n<li>若顶点A在序列中排在顶点B的前面，则在图中不存在从B到A的路径。<br>或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中B出现在A的后面。每个AOV网都有一个或多个拓扑排序序列。</li>\n</ol>\n</li>\n<li><p>对一个AOV网进行拓扑排序的算法有很多，下面介绍比较常见的一种方法的步骤：</p>\n<ol>\n<li>从AOV网中选择一个没有前驱（入度为0）的顶点并输出。</li>\n<li>从网中删除该顶点和所有以它为起点的有向边。</li>\n<li>重复1和2直到当前的AOV网为空或<strong>当前网中不存在无前驱的顶点</strong>为止，<strong>后一种情况说明有向图中必然存在环</strong>。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">topologicalSort</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">inDegree</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;  <span class=\"comment\">// 入度数组</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">adj</span>(n);  <span class=\"comment\">// 邻接表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建邻接表并计算每个结点的入度</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; edge : edges) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u = edge[<span class=\"number\">0</span>], v = edge[<span class=\"number\">1</span>];</span><br><span class=\"line\">        adj[u].<span class=\"built_in\">push_back</span>(v);</span><br><span class=\"line\">        inDegree[v]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    <span class=\"comment\">// 将入度为 0 的结点入队</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inDegree[i] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; topoOrder;  <span class=\"comment\">// 存储拓扑排序结果</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        topoOrder.<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历当前结点的邻接结点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> v : adj[u]) &#123;</span><br><span class=\"line\">            inDegree[v]--;  <span class=\"comment\">// 将相邻结点的入度减 1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (inDegree[v] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果拓扑排序结果中的结点数不等于总结点数，说明图中有环</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (topoOrder.<span class=\"built_in\">size</span>() != n) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;图中存在环，无法进行拓扑排序&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> topoOrder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>时间复杂度：邻接矩阵<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，邻接表<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|+|E|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span>。</p>\n</li>\n<li><p>DFS的方式：</p>\n<ol>\n<li>若u是v的祖先，则在调用DFS访问u之前，必然已对v进行了DFS访问，即v的DFS结束时间先于u的DFS结束时间。从而可以考虑在DFS函数中设置一个时间标记，在DFS调用结束时，对各顶点计时。因此，祖先的结束时间必然大于子孙的结束时间。</li>\n<li>若u是v的子孙，则v为u的祖先，按上述思路，v的结束时间大于u的结束时间。</li>\n<li>若u和v没有路径关系，则u和v在拓扑序列的关系任意。</li>\n<li>最后按照结束时间从大到小排列，就可以得到一个拓扑排序序列。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> node, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; adj, vector&lt;<span class=\"type\">bool</span>&gt;&amp; visited, vector&lt;<span class=\"type\">int</span>&gt;&amp; finishTime, <span class=\"type\">int</span>&amp; time)</span> </span>&#123;</span><br><span class=\"line\">    visited[node] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 递归访问所有未访问的邻接结点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> neighbor : adj[node]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[neighbor]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(neighbor, adj, visited, finishTime, time);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当前结点的所有邻接结点访问完成后，记录完成时间</span></span><br><span class=\"line\">    finishTime[node] = time++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">topologicalSort</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">adj</span>(n);      <span class=\"comment\">// 邻接表</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(n, <span class=\"literal\">false</span>)</span></span>;  <span class=\"comment\">// 访问标记</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">finishTime</span><span class=\"params\">(n)</span></span>;       <span class=\"comment\">// 记录每个结点的完成时间</span></span><br><span class=\"line\">    <span class=\"type\">int</span> time = <span class=\"number\">0</span>;                    <span class=\"comment\">// 时间计数器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建邻接表</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; edge : edges) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u = edge[<span class=\"number\">0</span>], v = edge[<span class=\"number\">1</span>];</span><br><span class=\"line\">        adj[u].<span class=\"built_in\">push_back</span>(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对所有未访问的结点进行 DFS，并记录完成时间</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[i]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(i, adj, visited, finishTime, time);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据完成时间对结点进行排序，完成时间大的在前</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">topoOrder</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        topoOrder[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(topoOrder.<span class=\"built_in\">begin</span>(), topoOrder.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"type\">int</span> a, <span class=\"type\">int</span> b) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> finishTime[a] &gt; finishTime[b];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> topoOrder;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">6</span>;  <span class=\"comment\">// 结点数</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; edges = &#123;&#123;<span class=\"number\">5</span>, <span class=\"number\">2</span>&#125;, &#123;<span class=\"number\">5</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">4</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">4</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;, &#123;<span class=\"number\">3</span>, <span class=\"number\">1</span>&#125;&#125;;  <span class=\"comment\">// 边</span></span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; result = <span class=\"built_in\">topologicalSort</span>(n, edges);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;拓扑排序结果: &quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> node : result) &#123;</span><br><span class=\"line\">        cout &lt;&lt; node &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>对一个AOV网，若采用下列步骤进行排序，则称之为<strong>逆拓扑排序</strong>：</p>\n<ol>\n<li>从AOV网中选择一个没有后继（出度为0）的顶点并输出/</li>\n<li>从网中删除该顶点和所有以它为终点的有向边。</li>\n<li>重复1和2直到当前的AOV网为空。</li>\n</ol>\n</li>\n<li><p>用拓扑排序算法处理AOV网时，应注意以下问题：</p>\n<ol>\n<li>入度为0的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续。</li>\n<li>若一个顶点有多个直接后继，则拓扑排序的结果通常不唯一；但若各个顶点已经排在一个线性有序的序列中，每个顶点有唯一的前驱后继关系，则拓扑排序的结果是唯一的。</li>\n<li>由于AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵；但对一般的图来说，<strong>若其邻接矩阵是三角矩阵，则存在拓扑序列；反之不一定成立</strong>。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p><strong>什么条件下会存在多条拓扑路径？</strong><br>大致可以归纳为：</p>\n<ol>\n<li>存在多个入度为零的结点。</li>\n<li>图中的结点之间没有完全的依赖关系。</li>\n</ol>\n</blockquote>\n<h4 id=\"关键路径\"><a href=\"#关键路径\" class=\"headerlink\" title=\"关键路径\"></a>关键路径</h4><ul>\n<li><strong>AOE网：</strong>在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为<strong>用边表示活动的网络</strong>，简称<strong>AOE网</strong>。</li>\n<li>AOE网和AOV网都是有向无环图，不同之处在于它们的边和顶点所代表的的含义是不同的，AOE网中的边有权值，而AOV网中的边无权值，仅表示顶点之间的前后关系。</li>\n<li>AOE网具有以下两个性质：<ol>\n<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</li>\n<li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。<br>在AOE网中仅有一个入度为0的顶点，称为<strong>开始顶点（源点）</strong>，它表示整个工程的开始；也仅有一个出度为0的顶点，称为<strong>结束顶点（汇点）</strong>，它表示整个工程的结束。</li>\n</ol>\n</li>\n<li>在AOE网中，有些活动时可以并行进行的。从源点到汇点的有向路径可能有多条，并且这些路径长度可能不同。完成不同路径上的活动所需的时间虽然不同，但是只有所有路径上的活动都已完成，整个工程才能算结束。因此，从源点到汇点的所有路径中，<strong>具有最大路径长度的路径</strong>称为<strong>关键路径</strong>，而把<strong>关键路径上的活动</strong>称为<strong>关键活动</strong>。</li>\n<li>完成整个工程的<strong>最短时间</strong>就是<strong>关键路径的长度</strong>，即<strong>关键路径上各活动花费开销的总和</strong>。这是因为关键活动影响了整个工程的时间，即若关键活动不能按时完成，则整个工程的完成时间就会延长。因此，只要找到了关键活动，就找到了关键路径，也就可以得出最短完成时间。</li>\n</ul>\n<p><strong>事件</strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的<strong>最早</strong>发生时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_e(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></p>\n<ul>\n<li>它是指从源点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>到顶点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的<strong>最长</strong>路径长度。</li>\n<li>事件<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的最早发生时间决定了所有从<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>开始的活动能够开工的最早时间。</li>\n<li>可用下面的递推公式来计算（用拓扑排序）：<ol>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mtext>源点</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">v_e(\\text{源点})=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">源点</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">{</mo><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mi>j</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>k</mi></msub><mtext>为</mtext><msub><mi>v</mi><mi>j</mi></msub><mtext>的任意后继，</mtext><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mi>j</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mtext>表示</mtext><mo>&lt;</mo><msub><mi>v</mi><mi>j</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>k</mi></msub><mo>&gt;</mo><mtext>上的权值</mtext></mrow><annotation encoding=\"application/x-tex\">v_e(k)=Max\\{v_e(j)+Weight(v_j,v_k)\\},v_k\\text{为}v_j\\text{的任意后继，}Weight(v_j,v_k)\\text{表示}&lt;v_j,v_k&gt;\\text{上的权值}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">为</span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">的任意后继，</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">表示</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8252em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">上的权值</span></span></span></span></span>\n</li>\n</ol>\n</li>\n</ul>\n<p><strong>事件</strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的<strong>最迟</strong>发生时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_l(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></p>\n<ul>\n<li>它是指在<strong>不推迟整个工程完成</strong>的前提下，即保证它的后继事件<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7167em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>在其最迟发生事件<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_l(j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span>能够发生时，该事件最迟必须发生的时间。</li>\n<li>可用下面的递推公式来计算（用逆拓扑排序）：<ol>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mtext>汇点</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mtext>汇点</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_l(\\text{汇点})=v_e(\\text{汇点})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">汇点</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">汇点</span></span><span class=\"mclose\">)</span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">{</mo><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>−</mo><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mi>k</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>k</mi></msub><mtext>为</mtext><msub><mi>v</mi><mi>j</mi></msub><mtext>的任意前驱</mtext></mrow><annotation encoding=\"application/x-tex\">v_l(k)=Min\\{v_l(j)-Weight(v_k,v_j)\\},v_k\\text{为}v_j\\text{的任意前驱}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\">in</span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">为</span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">的任意前驱</span></span></span></span></span>\n</li>\n</ol>\n</li>\n</ul>\n<p><strong>活动</strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的<strong>最早</strong>开始时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">e(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span></p>\n<ul>\n<li>它是指该活动弧的起点所表示的事件的最早发生时间。若边<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>k</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;v_k,v_j&gt;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8252em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span>表示活动<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，则有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">e(i)=v_e(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<p><strong>活动</strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的<strong>最迟</strong>开始时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">l(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span></p>\n<ul>\n<li>它是指该活动弧的终点所表示时间的最迟发生时间与该活动所需时间之差。若边<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>k</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;v_k,v_j&gt;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8252em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span>表示活动<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，则有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>−</mo><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mi>k</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">l(i)=v_l(j)-Weight(v_k,v_j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<p>一个<strong>活动</strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的<strong>最迟</strong>开始时间l(i)和其<strong>最早</strong>开始时间e(i)的差额d(i)=l(i)-e(i)</p>\n<ul>\n<li>它是指该活动完成的时间余量，即在不增加完成整个工程所需总时间的情况下，活动<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>可以拖延的时间。若一个活动的时间余量为0，则说明该活动必须要如期完成，否则会拖延整个工程的进度。</li>\n<li>所以称l(i)=e(i)的活动<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>是关键活动。</li>\n</ul>\n<p><strong>求关键路径的算法</strong>步骤如下：</p>\n<ol>\n<li><p>从源点出发，令<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mtext>源点</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">v_e(\\text{源点})=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">源点</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>，按拓扑有序求其余顶点的最早发生时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_e()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<blockquote>\n<p>最早发生时间即为前面的任务要全部完成了才能做这个任务<br>如果是选择题，在这一步就可以得出关键路径。（具有最大路径长度的路径）</p>\n</blockquote>\n</li>\n<li><p>从汇点出发，令<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mtext>汇点</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mtext>汇点</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_l(汇点)=v_e(汇点)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord cjk_fallback\">汇点</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord cjk_fallback\">汇点</span><span class=\"mclose\">)</span></span></span></span>，按逆拓扑有序求其余顶点的最迟发生时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_l()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<blockquote>\n<p>最迟发生时间即为该事件再不发生，后续任务就得推迟进行了。</p>\n</blockquote>\n</li>\n<li><p>根据各顶点的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_e()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>值求所有弧的最早开始时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">e()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<blockquote>\n<p>弧的起点的最早开始时间<br>记住，<strong>早</strong>找前面，因为要前面全部完成任务。</p>\n</blockquote>\n</li>\n<li><p>根据各顶点的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_l()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>值求所有弧的最迟开始时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">l()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<blockquote>\n<p>弧的终点的最迟开始时间-弧的权值<br>记住，<strong>迟</strong>找后面，因为要后面不被这边拖进度。</p>\n</blockquote>\n</li>\n<li><p>求AOE网中所有活动的差额d()，找出所有d()=0的活动构成关键路径。</p>\n</li>\n</ol>\n<blockquote>\n<p>对于<strong>关键路径</strong>，需要<strong>注意</strong>以下几点：</p>\n<ol>\n<li>关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可以通过加快关键活动来缩短整个工程的工期。但也<strong>不能任意缩短关键活动</strong>，因为一旦缩短到一定的程度，该关键活动就可能变成非关键活动。</li>\n<li>网中的关键路径并不一定唯一，且对于有几条路径的网，<strong>只提高一条</strong>关键路径上的关键活动速度<strong>并不能缩短</strong>整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。</li>\n</ol>\n</blockquote>\n<h4 id=\"不同存储结构时各种图算法的时间复杂度\"><a href=\"#不同存储结构时各种图算法的时间复杂度\" class=\"headerlink\" title=\"不同存储结构时各种图算法的时间复杂度\"></a>不同存储结构时各种图算法的时间复杂度</h4><p><img src=\"/articles/9eb01842/不同存储结构时间复杂度总结.jpg\" width=100% height=70% /></p>\n<h2 id=\"七、查找\"><a href=\"#七、查找\" class=\"headerlink\" title=\"七、查找\"></a>七、查找</h2><blockquote>\n<p>查找的定义和与查找有关的算法：顺序查找法、折半查找法、散列（Hash）技术。</p>\n</blockquote>\n<h3 id=\"理解查找的定义\"><a href=\"#理解查找的定义\" class=\"headerlink\" title=\"理解查找的定义\"></a>理解查找的定义</h3><ol>\n<li>查找。在数据集合中寻找满足某种条件的数据元素的过程称为<strong>查找</strong>。</li>\n<li>在数据集合中找了满足条件的数据元素为<strong>查找成功</strong>，否则为<strong>查找失败</strong>。</li>\n<li>用于查找的数据集合为<strong>查找表</strong>，它是由同一类型的数据元素（或记录）组成的。对查找表的<strong>常见操作</strong>有：① 查询符合条件的数据元素；② 插入、删除数据元素。</li>\n<li>静态查找表。若一个查找表的操作只涉及查找操作，则无须动态地修改查找表，此类查找表称为<strong>静态查找表</strong>。与此对应，需要动态地插入或删除的查找表称为<strong>动态查找表</strong>。适合静态查找表的<strong>查找方法</strong>有顺序查找、折半查找、散列查找等；适合动态查找表的<strong>查找方法</strong>有二叉排序树的查找、散列查找等。</li>\n<li>关键字。数据元素中的唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在有一个学生元素构成的数据集合中，学生元素中“学号”这一数据项的值唯一地标识一名学生。</li>\n<li>平均查找长度。在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>P</mi><mi>i</mi></msub><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">ASL=\\sum\\limits_{i=1}^{n}P_i C_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. 式中，n是查找表的长度（因为每一个元素都要查找，所有都得考虑进去），Pi是查找第i个数据元素的概率，<strong>一般认为每个数据元素的查找概率相等</strong>，即Pi=1/n；Ci是找到第i个数据元素所需进行的<strong>比较次数</strong>。平均查找长度是<strong>衡量算法效率</strong>的<strong>最主要</strong>指标。</li>\n<li><strong>有序线性表</strong>的<strong>顺序查找</strong>中的线性表可以是<strong>链式存储结构</strong>，而<strong>折半查找</strong>中的线性表只能是顺序存储结构。</li>\n</ol>\n<h3 id=\"衡量查找算法的一些指标：三个查找长度\"><a href=\"#衡量查找算法的一些指标：三个查找长度\" class=\"headerlink\" title=\"衡量查找算法的一些指标：三个查找长度\"></a>衡量查找算法的一些指标：三个查找长度</h3><h4 id=\"顺序查找法\"><a href=\"#顺序查找法\" class=\"headerlink\" title=\"顺序查找法\"></a>顺序查找法</h4><ul>\n<li><strong>一般无序线性表</strong><blockquote>\n<p>从后往前找，a[0]=x作为哨兵，若查找不成功，说明是从n比较到0都没找到，即比较了n+1次。</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>平均查找长度（成功不成功都计入，每个概率为1/2n）<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mn>3</mn><mn>4</mn></mfrac><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ASL=\\frac{1}{2n}\\sum\\limits_{i=1}^{n}(n-1+1)+\\frac{1}{2}(n+1)=\\frac{3}{4}(n+1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>成功查找的（平均）查找长度  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>P</mi><mi>i</mi></msub><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">ASL=\\sum\\limits_{i=1}^{n}P_i C_i= \\frac{1}{n} \\sum\\limits_{i=1}^{n} (n-i+1)=\\frac{n+1}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></li>\n<li>不成功查找的（平均）查找长度  ASL=n+1</li>\n</ol>\n<ul>\n<li><strong>有序线性表</strong></li>\n</ul>\n<ol>\n<li>平均查找长度</li>\n<li>成功查找的（平均）查找长度<br>有序的结果和一般线性表的顺序查找一样，<strong>但是！！！要注意！！！这里的查找顺序若是从前往后，就不是和上面一样的结果！！！</strong></li>\n<li>不成功查找的（平均）查找长度<blockquote>\n<p>表L是按关键字从小到大排列的，查找的顺序是从前往后。假设有n个结点（这些是查找成功的结点），虚构n+1个查找失败结点。Pi为1/(n+1)，1,2,…,n,n为查找失败时的比较次数。</p>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>n</mi><mo>+</mo><mi>n</mi></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi>n</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">ASL=\\frac{1+2+\\cdots+n+n}{n+1}=\\frac{n}{2}+\\frac{n}{n+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2484em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span><span class=\"mbin mtight\">+</span><span class=\"minner mtight\">⋯</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0404em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6954em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0987em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6954em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li><strong>分块查找（索引顺序查找）</strong></li>\n</ul>\n<p>它吸取了<strong>顺序查找</strong>和<strong>折半查找</strong>各自的优点，既有动态结构，又适用于快速查找。</p>\n<ol>\n<li>在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；</li>\n<li>在块内顺序查找。</li>\n</ol>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><msub><mi>L</mi><mi>I</mi></msub><mo stretchy=\"false\">(</mo><mtext>索引查找</mtext><mo stretchy=\"false\">)</mo><mo>+</mo><msub><mi>L</mi><mi>S</mi></msub><mo stretchy=\"false\">(</mo><mtext>块内查找</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mrow><mi>b</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo>+</mo><mfrac><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><msup><mi>s</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>s</mi><mo>+</mo><mi>n</mi></mrow><mrow><mn>2</mn><mi>s</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">ASL=L_I(\\text{索引查找})+L_S(\\text{块内查找})=\\frac{b+1}{2}+\\frac{s+1}{2}=\\frac{s^2+2s+n}{2s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">索引查找</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">块内查找</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2251em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3629em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0179em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">s</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">s</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>（在块内和索引均采用顺序查找）\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>若</mtext><mi>s</mi><mo>=</mo><msqrt><mi>n</mi></msqrt><mtext>，则平均查找长度取最小值</mtext><msqrt><mi>n</mi></msqrt><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\text{若}s=\\sqrt{n}\\text{，则平均查找长度取最小值}\\sqrt{n}+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">若</span></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.2397em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8003em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-2.7603em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2397em;\"><span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">，则平均查找长度取最小值</span></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8003em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-2.7603em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2397em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>\n<h4 id=\"折半查找法（二分查找）\"><a href=\"#折半查找法（二分查找）\" class=\"headerlink\" title=\"折半查找法（二分查找）\"></a>折半查找法（二分查找）</h4><ol>\n<li>平均查找长度</li>\n<li><p>成功查找的（平均）查找长度</p>\n<blockquote>\n<p>等概率，Pi为1/n。树上的每个结点都要考虑进去，每个结点的比较次数为它的层数。第一层次数为1（层高），有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup><mtext>（</mtext><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup><mtext>）</mtext></mrow><annotation encoding=\"application/x-tex\">2^0（2^{j-1}）</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8247em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">（</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">）</span></span></span></span>个结点要计算；第二层次数为2（层高），有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mtext>（</mtext><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup><mtext>）</mtext></mrow><annotation encoding=\"application/x-tex\">2^1（2^{j-1}）</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8247em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">（</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">）</span></span></span></span>个结点要计算……直到最后一层，这里不一定是满二叉树，但就按照满二叉树近似计算了。</p>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo stretchy=\"false\">(</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>×</mo><mn>2</mn><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>h</mi><mo>×</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>−</mo><mn>1</mn><mo>≈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">ASL=\\frac{1}{n}(1×1+2×2+\\cdots+h×2^{h-1})=\\frac{n+1}{n}log_2(n+1)-1≈log_2(n+1)-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0991em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">h</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>\n<p>这里记一下最终结果！（因为不知道咋算出来的）<br>另外，h为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil log_2(n+1) \\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)⌉</span></span></span></span>.<br>所以折半查找的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log_2n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，平均情况下比顺序查找的效率高。</p>\n</blockquote>\n</li>\n<li><p>不成功查找的（平均）查找长度</p>\n<blockquote>\n<p>虚构出方形结点，挂到圆形结点的下方。如果查找失败，即为方形结点，但是次数是上面那个圆形结点的层数。比如二叉树第3层下面总共挂了4个方形结点，第4层挂了8个方形节点：<br>ASL=(3×4+4×8)/12=11/3</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"散列（Hash）查找法\"><a href=\"#散列（Hash）查找法\" class=\"headerlink\" title=\"散列（Hash）查找法\"></a>散列（Hash）查找法</h4><ol>\n<li>平均查找长度</li>\n<li>成功查找的（平均）查找长度</li>\n<li>不成功查找的（平均）查找长度<br>（见王道，直接看解析p341-03，p343-07）</li>\n</ol>\n<ul>\n<li><strong>执行步骤：</strong><br>初始化：Addr=Hash(key);</li>\n</ul>\n<ol>\n<li>检测查找表中地址为Addr的位置上是否有记录，若无记录，返回<strong>查找失败</strong>；若有记录（可能同义词放在这了），比较它与key的值，若相等，则返回<strong>查找成功</strong>标志，否则执行步骤2.</li>\n<li>用给定的处理冲突方法计算“下一个散列地址”，并把Addr置为此地址，转入步骤1.</li>\n</ol>\n<p><img src=\"/articles/9eb01842/散列查找分析.jpg\" width=70% /></p>\n<ul>\n<li>对同一组关键字，设定相同的散列函数，则不同的处理冲突的方法得到的散列表不同，它们的平均查找长度也不同，本例与采用拉链法的平均查找长度不同。</li>\n<li>从散列表的查找过程可见：<ol>\n<li>虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍然需要以平均查找长度作为衡量散列表的查找效率的度量。</li>\n<li>散列表的<strong>查找效率</strong>取决于三个因素：<strong>散列函数</strong>、<strong>处理冲突的方法</strong>和<strong>装填因子</strong>（见下）。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"掌握顺序查找法和折半查找法，并理解二者之间的异同点\"><a href=\"#掌握顺序查找法和折半查找法，并理解二者之间的异同点\" class=\"headerlink\" title=\"掌握顺序查找法和折半查找法，并理解二者之间的异同点\"></a>掌握顺序查找法和折半查找法，并理解二者之间的异同点</h3><ul>\n<li>顺序查找适用于任何情况，但效率较低，特别是对于大量数据时。</li>\n<li>折半查找效率较高，但前提是数据必须有序。</li>\n</ul>\n<h3 id=\"掌握散列技术（包括）\"><a href=\"#掌握散列技术（包括）\" class=\"headerlink\" title=\"掌握散列技术（包括）\"></a>掌握散列技术（包括）</h3><h4 id=\"散列函数（哈希函数）\"><a href=\"#散列函数（哈希函数）\" class=\"headerlink\" title=\"散列函数（哈希函数）\"></a>散列函数（哈希函数）</h4><ul>\n<li>一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr（这里的地址可以是数组下标、索引或内存地址等）。</li>\n<li><p>散列函数可能会把两个或两个以上的关键字映射到同一地址，称这种情况为<strong>冲突</strong>，这些发成冲突的不同关键字称为<strong>同义词</strong>。</p>\n<ol>\n<li>一方面，设计得好的散列函数应尽量减少这样的冲突；</li>\n<li>另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。</li>\n</ol>\n</li>\n<li><p><strong>在构造散列函数时</strong>，必须<strong>注意</strong>以下几点：</p>\n</li>\n</ul>\n<ol>\n<li>散列函数的定义域必须包含全部关键字，而值域的范围则依赖于散列表的大小。</li>\n<li>散列函数计算出的地址应尽可能均匀地分布在整个地址空间，尽可能地减少冲突。</li>\n<li>散列函数应尽量简单，能在较短的时间内计算出一个关键字对应的散列地址。</li>\n</ol>\n<ul>\n<li><strong>常见的散列函数</strong><ol>\n<li><strong>直接定址法</strong><ul>\n<li>直接取关键字的某个<strong>线性函数值</strong>（线性函数：f(x)=ax+b）为散列地址，散列函数为H(key)=key或H(key)=a×key+b.（a和b是常数）</li>\n<li>这种方法计算很简单，且不会产生冲突。它适合关键字的分布基本连续的情况；若关键字分布不连续，空位较多，则会造成存储空间的浪费。</li>\n</ul>\n</li>\n<li><strong>除留余数法</strong><ul>\n<li>这是一种最简单、最常用的方法，假定散列列表表长为m，取一个不大于m但最接近或等于m的质数p。散列函数为H(key)=key%p.</li>\n<li>除留余数法的关键是选好p，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任意一个地址，从而尽可能减少冲突的可能性。</li>\n</ul>\n</li>\n<li><strong>数字分析法</strong><ul>\n<li>设关键字r是进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时应<strong>选取数码分布较为均匀的若干位作为散列地址</strong>。</li>\n<li>这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。<blockquote>\n<p><strong>为什么选择分布较为均匀的位？</strong></p>\n<ol>\n<li><strong>均匀分布减少冲突：</strong>数码均匀分布意味着每个可能的散列地址都有相似的数字频率，这样每个地址的负载相对均匀，避免了某些地址被过多数字占用，减少了哈希冲突。</li>\n<li><strong>提高散列效率：</strong>通过选取均匀分布的位，可以使得散列算法对输入数据的敏感度更高，避免了一些特定位置的数字偏差影响整个散列过程。这使得数据能够更广泛地分布到散列表中，提高查询和插入效率。</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><strong>平方取中法</strong><ul>\n<li>取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。</li>\n<li>这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，<strong>适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数</strong>。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"散列表（哈希表）\"><a href=\"#散列表（哈希表）\" class=\"headerlink\" title=\"散列表（哈希表）\"></a>散列表（哈希表）</h4><ul>\n<li>根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。</li>\n<li>理想情况下，对散列表进行查找的时间复杂度为O(1)，即与表中元素的个数无关。</li>\n</ul>\n<h4 id=\"散列冲突的发生及其解决方法\"><a href=\"#散列冲突的发生及其解决方法\" class=\"headerlink\" title=\"散列冲突的发生及其解决方法\"></a>散列冲突的发生及其解决方法</h4><ol>\n<li><strong>开放定址法</strong></li>\n</ol>\n<ul>\n<li>所谓开放定址法，是指表中可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo>=</mo><mo stretchy=\"false\">(</mo><mi>H</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo>+</mo><msub><mi>d</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H_i=(H(key)+d_i)%m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n<li>式中，H(key)为散列函数；i=1,2,…,k(k≤m-1)；m表示散列表表长；di为增量序列。</li>\n<li><p>取定某一增量序列后，对应的处理方法就是确定的。通常有以下4种取法：<br>①<strong>线性探测法</strong>，又称<strong>线性探测再散列法</strong>。</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">d_i=1, 2, …, m-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。它的特点是：冲突发生时，顺序查看表中下一个单元（探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。</li>\n<li>线性探测法可能使第i个散列地址的同义词存入第i+1个散列地址，这样本应存入第i+1个散列地址的元素就争夺第i+2个散列地址的元素的地址……从而造成大量元素在相邻的散列地址上<strong>聚集（或堆积）</strong>起来，大大降低了查找效率。</li>\n</ul>\n<p>②<strong>平方探测法</strong>，又称<strong>二次探测法</strong>。</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator=\"true\">,</mo><mo>−</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator=\"true\">,</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator=\"true\">,</mo><mo>−</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msup><mi>k</mi><mn>2</mn></msup><mo separator=\"true\">,</mo><mo>−</mo><msup><mi>k</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">d_i=1^2, -1^2, 2^2, -2^2, \\cdots, k^2, -k^2 </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>，其中k≤m/2，散列表长度m必须是一个可以表示成4k+3的素数。</li>\n<li>平方探测法是一种处理冲突的较好方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。</li>\n</ul>\n<p>③<strong>双散列法</strong>。</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mi>i</mi><mo>×</mo><mi>H</mi><mi>a</mi><mi>s</mi><msub><mi>h</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">d_i=i×Hash_2(key)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">s</span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">)</span></span></span></span>。需要使用两个散列函数，当通过第一个散列函数H(key)得到的地址发生冲突时，则利用第二个散列函数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>a</mi><mi>s</mi><msub><mi>h</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Hash_2(key)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">s</span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">)</span></span></span></span>计算该关键字的地址增量。具体散列函数：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo>=</mo><mo stretchy=\"false\">(</mo><mi>H</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>i</mi><mo>×</mo><mi>H</mi><mi>a</mi><mi>s</mi><msub><mi>h</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H_i=(H(key)+i×Hash_2(key))%m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">s</span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">))</span></span></span></span>。</li>\n<li>初始探测位置<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>=</mo><mi>H</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H_0=H(key)%m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">)</span></span></span></span>。i时冲突的次数，初始为0。</li>\n</ul>\n<p>④<strong>伪随机序列法</strong>。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mtext>伪随机数序列</mtext></mrow><annotation encoding=\"application/x-tex\">d_i=\\text{伪随机数序列}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">伪随机数序列</span></span></span></span></span>。</p>\n</li>\n</ul>\n<blockquote>\n<p>采用开放定址法时，不能随便物理删除表中已有元素，否则会截断其他同义词元素的查找路径。因此，要删除一个元素时，可以做一个删除标记，进行逻辑删除。<br>但这样做的副作用是：执行多次删除后，表面上看起来散列表很满，实际上有许多位置未利用。</p>\n</blockquote>\n<ol>\n<li><strong>拉链法（链接法，chaining）</strong></li>\n</ol>\n<ul>\n<li>为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。</li>\n<li>假设散列地址为i的同义词链表的头指针存放在散列表的第i个单元中，因而查找、插入和删除操作主要在同义词链中进行。<strong>拉链法适用于经常进行插入和删除的情况。</strong><br><img src=\"/articles/9eb01842/拉链法.jpg\" width=70% /></li>\n</ul>\n<h4 id=\"负载因子（装填因子）\"><a href=\"#负载因子（装填因子）\" class=\"headerlink\" title=\"负载因子（装填因子）\"></a>负载因子（装填因子）</h4><ul>\n<li>散列表的装填因子一般记为α，定义为一个表的装满程度，即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><mfrac><mtext>表中记录数n</mtext><mtext>散列表长度m</mtext></mfrac></mrow><annotation encoding=\"application/x-tex\">α=\\frac{\\text{表中记录数n}}{\\text{散列表长度m}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2173em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8723em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord cjk_fallback mtight\">散列表长度</span><span class=\"mord mtight\">m</span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord cjk_fallback mtight\">表中记录数</span><span class=\"mord mtight\">n</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></li>\n<li>散列表的<strong>平均查找长度</strong>依赖于散列表的<strong>装填因子α</strong>，而不直接依赖于n或m。</li>\n<li>直观地看，<strong>α越大</strong>，表示装填的记录越“满”，<strong>发生冲突的可能性越大</strong>；反之，发生冲突的可能性越小。</li>\n</ul>\n<h3 id=\"理解不同查找技术的优缺点\"><a href=\"#理解不同查找技术的优缺点\" class=\"headerlink\" title=\"理解不同查找技术的优缺点\"></a>理解不同查找技术的优缺点</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>查找技术</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>顺序查找</strong></td>\n<td>简单实现，适用于无序数据，空间需求少</td>\n<td>时间复杂度高，效率低</td>\n<td>数据量小，数据无序时</td>\n</tr>\n<tr>\n<td><strong>二分查找</strong></td>\n<td>查找效率高（O(log n)），适用于有序数据</td>\n<td>数据需要事先排序，复杂度较高</td>\n<td>数据已排序，查找效率要求较高</td>\n</tr>\n<tr>\n<td><strong>哈希查找</strong></td>\n<td>查找速度快（O(1)），适用于大规模数据</td>\n<td>哈希冲突，额外空间需求，不支持有序查找</td>\n<td>需要高效查找的场景，如缓存、字典等</td>\n</tr>\n<tr>\n<td><strong>平衡二叉树查找</strong></td>\n<td>查找、插入、删除效率高（O(log n)）</td>\n<td>实现复杂，空间开销较大</td>\n<td>动态数据集，需要有序数据</td>\n</tr>\n<tr>\n<td><strong>跳表查找</strong></td>\n<td>查找效率高，插入删除简单，支持有序查找</td>\n<td>空间开销大，较为复杂的实现</td>\n<td>动态数据集，支持范围查询和排序的场景</td>\n</tr>\n<tr>\n<td><strong>B树/B+树查找</strong></td>\n<td>高效磁盘查找，支持范围查询</td>\n<td>实现复杂，空间开销大</td>\n<td>数据库、文件系统等大数据量存储和查询场景</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"八、排序\"><a href=\"#八、排序\" class=\"headerlink\" title=\"八、排序\"></a>八、排序</h2><h3 id=\"排序的定义（包括）\"><a href=\"#排序的定义（包括）\" class=\"headerlink\" title=\"排序的定义（包括）\"></a>排序的定义（包括）</h3><p><img src=\"/articles/9eb01842/排序知识框架.jpg\" width=50% height=70% /></p>\n<ul>\n<li><strong>排序：</strong>就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。</li>\n<li><strong>输入：</strong>n个记录<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_1, R_2, \\cdots, R_n </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，对应的关键字为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>k</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>k</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">k_1, k_2, \\cdots, k_n </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</li>\n<li><strong>输出：</strong>输入序列的一个重排<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>R</mi><mn>1</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><mo separator=\"true\">,</mo><msubsup><mi>R</mi><mn>2</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msubsup><mi>R</mi><mi>n</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup></mrow><annotation encoding=\"application/x-tex\">R_1&#x27;, R_2&#x27;, \\cdots, R_n&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4519em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4519em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.453em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span>，使得<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>k</mi><mn>1</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><mo>≤</mo><msubsup><mi>k</mi><mn>2</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><mo>≤</mo><mo>⋯</mo><mo>≤</mo><msubsup><mi>k</mi><mi>n</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup></mrow><annotation encoding=\"application/x-tex\">k_1&#x27; \\leq k_2&#x27; \\leq \\cdots \\leq k_n&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4519em;margin-left:-0.0315em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4519em;margin-left:-0.0315em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9989em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.453em;margin-left:-0.0315em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span> （其中“≤”可以换成其他的比较大小的符号）。</li>\n</ul>\n<h4 id=\"内排序\"><a href=\"#内排序\" class=\"headerlink\" title=\"内排序\"></a>内排序</h4><ul>\n<li>是指在排序期间元素全部存放在内存中的排序。</li>\n<li>一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。基数排序不基于比较操作。</li>\n</ul>\n<h4 id=\"外排序\"><a href=\"#外排序\" class=\"headerlink\" title=\"外排序\"></a>外排序</h4><ul>\n<li>是指在排序期间元素无法全部同时存放内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的顺序。</li>\n</ul>\n<h4 id=\"内排序和外排序的区别\"><a href=\"#内排序和外排序的区别\" class=\"headerlink\" title=\"内排序和外排序的区别\"></a>内排序和外排序的区别</h4><ol>\n<li>在排序过程中，数据元素是否完全存放在内存中；</li>\n<li></li>\n</ol>\n<h4 id=\"排序的稳定性\"><a href=\"#排序的稳定性\" class=\"headerlink\" title=\"排序的稳定性\"></a>排序的稳定性</h4><ul>\n<li>若待排序表中有两个元素<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mtext>和</mtext><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_i\\text{和}R_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">和</span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>，其对应的关键字相同，即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mi>e</mi><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mi>e</mi><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">key_i=key_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">e</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">e</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>，且在排序前<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mtext>在</mtext><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_i\\text{在}R_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">在</span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>的前面，若使用某一排序算法排序后，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>仍然在<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>的前面，则称这个排序算法是<strong>稳定的</strong>，否则称这个排序算法是<strong>不稳定的</strong>。</li>\n</ul>\n<h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><ul>\n<li>假设前L[1…i-1]有序，后L[i+1…n]无序。（初始L[1]可以视为一个已排好序的子序列）</li>\n</ul>\n<ol>\n<li>查找出L(i)在L[1…i-1]中的插入位置k。</li>\n<li>将L[k…i-1]中的所有元素依次后移一个位置。</li>\n<li>将L(i)复制到L(k)。</li>\n</ol>\n<ul>\n<li>空间复杂度：O(1)，时间复杂度：最好O(n)，最坏<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，平均总比较次数和总移动次数均约为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><msup><mi>n</mi><mn>2</mn></msup><mn>4</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n^2}{4}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.3629em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0179em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>，因此平均<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>稳定性：稳定。</li>\n<li>适用性：顺序存储和链式存储的线性表，采用链式存储时无须移动元素。</li>\n</ul>\n<h3 id=\"折半插入排序（考点没写）\"><a href=\"#折半插入排序（考点没写）\" class=\"headerlink\" title=\"折半插入排序（考点没写）\"></a>折半插入排序（考点没写）</h3><ul>\n<li>在直接插入排序的基础上，将寻找插入位置k的方式改成折半查找，移动部分不变。</li>\n<li>时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>。对于数据量不是很大的顺序表，折半排序往往表现出很好的性能。</li>\n<li>稳定。</li>\n<li>仅使用于顺序存储的线性表。</li>\n</ul>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li>空间：O(1)</li>\n<li>时间：最好情况（第一遍flag判定有序，移动0，比较一轮）O(n)；最坏情况（逆序，n-1轮）比较次数=n(n-1)/2，移动次数=3n(n-1)/2，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>；平均<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>稳定。</li>\n<li>适用于顺序存储和链式存储的线性表。</li>\n</ul>\n<h3 id=\"简单选择排序\"><a href=\"#简单选择排序\" class=\"headerlink\" title=\"简单选择排序\"></a>简单选择排序</h3><ul>\n<li>空间：O(1)</li>\n<li>时间：移动次数不会超过3(n-1)，最好情况0，比较次数始终是n(n-1)/2，时间复杂度始终是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>不稳定。</li>\n<li>适用于顺序存储和链式存储的线性表，以及关键字较少的情况。</li>\n</ul>\n<h3 id=\"Shell排序\"><a href=\"#Shell排序\" class=\"headerlink\" title=\"Shell排序\"></a>Shell排序</h3><ul>\n<li>是对直接插入排序的改进，又称<strong>缩小增量排序</strong>。</li>\n<li>过程：<ol>\n<li>先取一个小于n的增量d1，把表中的全部记录分成d1组，<strong>所有距离为d1的倍数的记录放在同一组</strong>，在各组内进行直接插入排序；</li>\n<li>取第二个增量d2 &lt; d1，重复1；</li>\n<li>直到所取到的dt=1，再进行直接插入排序。由于此时已经具有较好的局部有序性，因此可以很快得到最终结果。（直接插入排序适用于基本有序和数据量不大的排序表）</li>\n</ol>\n</li>\n<li>到目前为止，尚未求得一个最好的增量序列。</li>\n</ul>\n<p><img src=\"/articles/9eb01842/希尔排序.jpg\" width=80% height=70% /></p>\n<ul>\n<li>空间O(1)</li>\n<li>时间：因为希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难。当n在某个特定范围时，希尔排序的时间复杂度约为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>1</mn></msup><mi mathvariant=\"normal\">.</mi><mn>3</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^1.3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mord\">.3</span><span class=\"mclose\">)</span></span></span></span>。在最坏情况下希尔排序的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>不稳定。（相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序）</li>\n<li>适用于顺序存储的线性表。</li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><p>① <strong>初始化</strong></p>\n<ol>\n<li>对以第⌊n/2⌋个结点（完全二叉树最后一个结点的双亲）为根的子树筛选，使该子树成为堆。</li>\n<li>向前依次对各结点（⌊n/2⌋-1~1）为根的子树进行筛选，看该结点值是否大于其左右结点的值，若不大于，则将左右子结点的较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。</li>\n<li>反复利用上述调整堆的方法建堆，直到根结点。</li>\n</ol>\n<p><img src=\"/articles/9eb01842/堆排序.jpg\" width=80% height=70% /></p>\n<p>② <strong>输出堆顶元素后调整堆</strong></p>\n<ol>\n<li>输出堆顶元素后，将堆的最后一个元素与堆顶元素交换，此时堆的性质备破坏，需要向下进行筛选。</li>\n</ol>\n<p><img src=\"/articles/9eb01842/堆排序_2.jpg\" width=80% height=70% /></p>\n<p>③<strong>再输出堆顶元素，如此重复，直到堆中只剩一个元素为止。</strong></p>\n<ul>\n<li>堆排序适合关键字较多的情况。例如，在1亿个数中选出<strong>前100个最大值</strong>。首先适用一个大小为100的数组，读入前100个数，建立小顶堆，而后依次读入余下的数，若小于堆顶则舍弃，否则用该数取代堆顶并重新调整堆，待数据读取完毕，堆中100个数为所求。</li>\n<li>空间O(1)</li>\n<li>时间：建堆O(n)，每次调整O(h)，最好、最坏、平均都是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlog_2n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>不稳定。</li>\n<li>仅适用于顺序存储的线性表。</li>\n</ul>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><h3 id=\"时空复杂度和稳定性\"><a href=\"#时空复杂度和稳定性\" class=\"headerlink\" title=\"时空复杂度和稳定性\"></a>时空复杂度和稳定性</h3><blockquote>\n<p>对直接插入排序、冒泡排序、简单选择排序、Shell排序、快速排序、堆排序、归并排序、基数排序这些算法，掌握其在时间复杂度、空间复杂度以及是否稳定等方面的特点</p>\n</blockquote>\n<h3 id=\"K路归并排序\"><a href=\"#K路归并排序\" class=\"headerlink\" title=\"K路归并排序\"></a>K路归并排序</h3><h4 id=\"k路归并排序的外排序算法\"><a href=\"#k路归并排序的外排序算法\" class=\"headerlink\" title=\"k路归并排序的外排序算法\"></a>k路归并排序的外排序算法</h4><h3 id=\"选择合适排序算法\"><a href=\"#选择合适排序算法\" class=\"headerlink\" title=\"选择合适排序算法\"></a>选择合适排序算法</h3><blockquote>\n<p>具有在不同的应用需求下，能够依据各种排序算法的特点选择合适排序算法的能力</p>\n</blockquote>\n<h2 id=\"九、矩阵和串\"><a href=\"#九、矩阵和串\" class=\"headerlink\" title=\"九、矩阵和串\"></a>九、矩阵和串</h2><h3 id=\"矩阵和串的定义\"><a href=\"#矩阵和串的定义\" class=\"headerlink\" title=\"矩阵和串的定义\"></a>矩阵和串的定义</h3><blockquote>\n<p>数组定义-王道p104</p>\n</blockquote>\n<p><strong>矩阵：</strong>矩阵是一个由 m 行 n 列元素组成的二维数组，通常表示为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{m×n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8917em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">×</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span>，其中 m 是矩阵的行数，n 是矩阵的列数。</p>\n<h3 id=\"特殊矩阵的压缩存储\"><a href=\"#特殊矩阵的压缩存储\" class=\"headerlink\" title=\"特殊矩阵的压缩存储\"></a>特殊矩阵的压缩存储</h3><h3 id=\"稀疏矩阵的三元组表示法以及相应的操作\"><a href=\"#稀疏矩阵的三元组表示法以及相应的操作\" class=\"headerlink\" title=\"稀疏矩阵的三元组表示法以及相应的操作\"></a>稀疏矩阵的三元组表示法以及相应的操作</h3><h3 id=\"多维数组和一维数组的映射\"><a href=\"#多维数组和一维数组的映射\" class=\"headerlink\" title=\"多维数组和一维数组的映射\"></a>多维数组和一维数组的映射</h3><h3 id=\"串的模式匹配\"><a href=\"#串的模式匹配\" class=\"headerlink\" title=\"串的模式匹配\"></a>串的模式匹配</h3><h4 id=\"Brute-Force\"><a href=\"#Brute-Force\" class=\"headerlink\" title=\"Brute-Force\"></a>Brute-Force</h4><h4 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h4>","more":"<h2 id=\"一、数据结构基本概念\"><a href=\"#一、数据结构基本概念\" class=\"headerlink\" title=\"一、数据结构基本概念\"></a>一、数据结构基本概念</h2><blockquote>\n<p>建议另外过一遍 <a href=\"./fc6ebebe.html\">严蔚敏课笔记</a><br>注意：代码缩进本该为4个空格，这里为了美观和方便，缩进是2个空格。</p>\n</blockquote>\n<h4 id=\"数据\"><a href=\"#数据\" class=\"headerlink\" title=\"数据\"></a>数据</h4><ul>\n<li>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。</li>\n</ul>\n<h4 id=\"数据元素\"><a href=\"#数据元素\" class=\"headerlink\" title=\"数据元素\"></a>数据元素</h4><ul>\n<li>数据元素是数据的<strong>基本单位</strong>，通常作为一个整体进行考虑和处理。</li>\n</ul>\n<h4 id=\"数据项\"><a href=\"#数据项\" class=\"headerlink\" title=\"数据项\"></a>数据项</h4><ul>\n<li>一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的<strong>最小单位</strong>。</li>\n<li>例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。</li>\n</ul>\n<h4 id=\"数据对象\"><a href=\"#数据对象\" class=\"headerlink\" title=\"数据对象\"></a>数据对象</h4><ul>\n<li>数据对象是具有相同性质的数据元素的集合，是数据的一个子集。</li>\n<li>例如，整数数据对象是集合 N={0,±1,±2,…}。</li>\n</ul>\n<h4 id=\"数据、数据元素、数据项之间的关系\"><a href=\"#数据、数据元素、数据项之间的关系\" class=\"headerlink\" title=\"数据、数据元素、数据项之间的关系\"></a>数据、数据元素、数据项之间的关系</h4><ul>\n<li>数据-&gt;数据对象-&gt;数据元素-&gt;数据项</li>\n<li>两张表-&gt;数据；其中一张表-&gt;数据对象；表中每一行（记录）-&gt;数据元素；每条记录的每个属性-&gt;数据项</li>\n</ul>\n<h4 id=\"数据结构的定义\"><a href=\"#数据结构的定义\" class=\"headerlink\" title=\"数据结构的定义\"></a>数据结构的定义</h4><ul>\n<li>数据结构是相互之间存在一种或多种特定<strong>关系</strong>的<strong>数据元素</strong>的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构（Structure）。</li>\n</ul>\n<h4 id=\"数据结构的三要素\"><a href=\"#数据结构的三要素\" class=\"headerlink\" title=\"数据结构的三要素\"></a>数据结构的三要素</h4><ul>\n<li>数据结构包括三方面的内容：<strong>逻辑结构</strong>、<strong>存储结构</strong>和<strong>数据的运算</strong>。</li>\n<li>数据的<strong>逻辑结构</strong>和<strong>存储结构</strong>是密不可分的两个方面，一个<strong>算法的设计</strong>取决于所选定的<strong>逻辑结构</strong>，而<strong>算法的实现</strong>依赖于所采用的<strong>存储结构</strong>。</li>\n</ul>\n<h4 id=\"数据的逻辑结构\"><a href=\"#数据的逻辑结构\" class=\"headerlink\" title=\"数据的逻辑结构\"></a>数据的逻辑结构</h4><ul>\n<li>逻辑结构是指数据元素之间的<strong>逻辑关系</strong>，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。</li>\n<li>数据的逻辑结构分为<strong>线性结构</strong>和<strong>非线性结构</strong>，<strong>线性表</strong>是典型的线性结构，<strong>集合、树和图</strong>是典型的非线性结构。<br>1) <strong>集合</strong>。结构中的元素之间除“同属一个集合”外，别无其它关系。<br>2) <strong>线性结构</strong>。结构中的数据元素之间只存在一对一的关系。<br>3) <strong>树形结构</strong>。结构中的数据元素之间存在一对多的关系。<br>4) <strong>图状结构</strong>或<strong>网状结构</strong>。结构中的数据元素之间存在多对多的关系。</li>\n</ul>\n<h4 id=\"数据的物理结构\"><a href=\"#数据的物理结构\" class=\"headerlink\" title=\"数据的物理结构\"></a>数据的物理结构</h4><ul>\n<li><code>存储结构</code>是指数据结构在计算机中的表示（又称<strong>映像</strong>），也称<code>物理结构</code>。它包括<strong>数据元素</strong>的表示和<strong>关系</strong>的表示。数据的存储结构是计算机语言实现的逻辑结构，它依赖于计算机语言。数据的存储结构主要有<strong>顺序存储、链式存储、索引存储和散列存储</strong>。<br>1) <strong>顺序存储</strong>。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。<br>其<strong>优点</strong>是可以实现<u>随机存取</u>，每个元素占用最少的存储空间；<strong>缺点</strong>是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。<br>2) <strong>链式存储</strong>。不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。<br>其<strong>优点</strong>是<u>不会出现碎片现象</u>，能充分利用所有存储单元；<strong>缺点</strong>是<u>每个元素因存储指针而占用额外的存储空间</u>，且只能实现顺序存取。<br>3) <strong>索引存储</strong>。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为<strong>索引项</strong>，索引项的一般形式是（关键字，地址）。<br>其<strong>优点</strong>是<u>检索速度快</u>；<strong>缺点</strong>是<u>附加的索引表额外占用存储空间</u>。另外，增加和删除数据时也要修改索引表，因而<u>会花费较多的时间</u>。<br>4) <strong>散列存储</strong>。根据元素的关键字直接计算出该元素的存储地址，又称<strong>哈希（Hash）存储</strong>。<br>其<strong>优点</strong>时<u>检索、增加和删除结点的操作都很快</u>；<strong>缺点</strong>是若散列函数不好，则可能出现<u>元素存储单元的冲突</u>，而解决冲突<u>会增加时间和空间开销</u>。</li>\n</ul>\n<h4 id=\"数据的运算的定义\"><a href=\"#数据的运算的定义\" class=\"headerlink\" title=\"数据的运算的定义\"></a>数据的运算的定义</h4><ul>\n<li>（王道）施加在数据上的运算包括运算的<strong>定义</strong>和<strong>实现</strong>。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</li>\n<li>（博客）数据的运算是指对数据实施的操作，数据的运算最终需要在对应的存储结构上用算法实现，所以数据运算分为运算的定义和运算的实现两个层面。<br>运算的定义是对运算功能的描述，是抽象的，是基于逻辑的。<br>运算的实现是程序员完成运算的实现算法，是具体的，是基于存储结构的。</li>\n</ul>\n<h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><ul>\n<li>数据类型是一个值的集合和定义在集合上的一组操作的总称。<br>1) <strong>原子类型</strong>。其值不可再分的数据类型。<br>2) <strong>结构类型</strong>。其值可以再分解为若干成分（分量）的数据类型。<br>3) <code>抽象数据类型</code>。一个数学模型及定义在该数学模型上的一组操作。它通常是对数据的某种抽象，定义了数据的取值范围及其结构形式，以及对数据操作的集合。</li>\n<li><code>抽象数据类型</code>的三个组成部分：数据对象、数据关系和基本操作。</li>\n<li>（蓝皮书，定义）<code>抽象数据类型</code>是一种构造数据类型，它具有三大特征，<strong>信息隐蔽、数据封装、使用与实现相分离</strong>。</li>\n</ul>\n<h4 id=\"数据类型、抽象数据类型和数据结构之间的关系\"><a href=\"#数据类型、抽象数据类型和数据结构之间的关系\" class=\"headerlink\" title=\"数据类型、抽象数据类型和数据结构之间的关系\"></a>数据类型、抽象数据类型和数据结构之间的关系</h4><ul>\n<li><strong>数据类型</strong>是一个值的集合和定义在此集合上的一组操作的总称。（值+操作）</li>\n<li><strong>抽象数据类型（ADT）</strong>是一个数学模型及定义在该数学模型上的一组操作。（数学模型+操作）它通常是对数据的某种抽象，定义了数据的取值范围及其结构形式，以及对数据操作的集合。（数据对象+数据关系+基本操作）</li>\n<li><strong>数据结构</strong>是相互之间存在一种或多种特定<strong>关系</strong>的<strong>数据元素</strong>的集合。（数据元素+数据关系）</li>\n</ul>\n<h2 id=\"二、算法和算法分析\"><a href=\"#二、算法和算法分析\" class=\"headerlink\" title=\"二、算法和算法分析\"></a>二、算法和算法分析</h2><h3 id=\"算法的定义\"><a href=\"#算法的定义\" class=\"headerlink\" title=\"算法的定义\"></a>算法的定义</h3><ul>\n<li>算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每一条指令表示一个或多个操作。</li>\n<li>算法和程序的区别：<ol>\n<li>算法是描述一个问题求解的步骤序列，而程序是算法在特定计算机上的实现。</li>\n<li>算法不依赖于计算机，而程序依赖于特定的计算机和特定的编程语言。</li>\n<li>算法必须满足五个特性，即有穷性、确定性、可行性、有输入、有输出，而程序可能不满足有穷性。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"算法的特性（五个）\"><a href=\"#算法的特性（五个）\" class=\"headerlink\" title=\"算法的特性（五个）\"></a>算法的特性（五个）</h3><ol>\n<li><strong>有穷性</strong>。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</li>\n<li><strong>确定性</strong>。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</li>\n<li><strong>可行性</strong>。算法中描述的操作都可以通过 已经实现的基本运算 执行有限次来实现。</li>\n<li><strong>输入</strong>。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li>\n<li><strong>输出</strong>。一个算法有一个或多个输出，这些输出是与输入有着某些特定关系的量。</li>\n</ol>\n<h3 id=\"算法设计的要求\"><a href=\"#算法设计的要求\" class=\"headerlink\" title=\"算法设计的要求\"></a>算法设计的要求</h3><ol>\n<li><strong>正确性</strong>。算法应能够正确地解决求解问题。<ul>\n<li>首先，算法应当满足以特定的“规格说明”方式给出的需求。</li>\n<li>其次，对算法是否“正确”的理解可以有以下四个层次：<br>a. 程序中不含语法错误；<br>b. 程序对于几组输入数据能够得出满足规格说明要求的结果；<br>c. 程序对于精心选择的典型、苛刻而带有刁难性的几组输入数据能够得出满足规格说明要求的结果；<br>d. 程序对于一切合法的输入数据都能产生满足规格说明要求的结果。<br>（通常以第c层意义的正确性作为衡量一个程序是否合格的标准。）</li>\n</ul>\n</li>\n<li><strong>可读性</strong>。算法应具有良好的可读性，以帮助人们理解。<ul>\n<li>算法主要是为了人的阅读与交流，其次才是机器执行。可读性好有助于人对算法的理解；</li>\n<li>另一方面，晦涩难懂的程序易于隐藏较多错误，难以调试和修改。</li>\n</ul>\n</li>\n<li><strong>健壮性</strong>。算法能对输入的非法数据做出反应或处理，而不会产生莫名其妙的输出。<ul>\n<li>当输入数据非法时，算法也能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</li>\n<li>并且，处理出错的方法应是返回一个表示错误或错误性质的值，而不是打印错误信息或异常，并中止程序的执行，以便在更高的抽象层次上进行处理。</li>\n</ul>\n</li>\n<li><strong>效率与低存储量需求</strong>。效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。<ul>\n<li>（因为：求100个人的平均分与求1000个人的平均分所花的执行时间或运行空间显然有一定的差别。）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"算法的时间、空间复杂度的定义及计算\"><a href=\"#算法的时间、空间复杂度的定义及计算\" class=\"headerlink\" title=\"算法的时间、空间复杂度的定义及计算\"></a>算法的时间、空间复杂度的定义及计算</h3><ul>\n<li>（归纳下应该这么说）算法的<strong>时间复杂度</strong>是一个关于问题规模n的函数，表示算法中基本运算的执行次数的数量级，定性地描述该算法的运行时间。</li>\n<li>（归纳下应该这么说）算法的<strong>空间复杂度</strong>是问题规模n的函数，定性地描述该算法或程序运行所需要的存储空间大小。</li>\n<li>（<a href=\"https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">wiki</a>）算法的<strong>时间复杂度</strong>（time complexity）是一个函数，它定性描述该算法的运行时间。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，也就是考察输入值大小趋近无穷时的情况。例如，如果一个算法对于任何大小为 n （必须比 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">n_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 大）的输入，它至多需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn><msup><mi>n</mi><mn>3</mn></msup><mo>+</mo><mn>3</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">5n^3 + 3n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\">5</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mord mathnormal\">n</span></span></span></span> 的时间运行完毕，那么它的渐近时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>（<a href=\"https://zh.wikipedia.org/wiki/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">wiki</a>）在计算机科学中，一个算法或程序的<strong>空间复杂度</strong>定性地描述该算法或程序运行所需要的存储空间大小。空间复杂度是相应计算问题的输入值的长度的函数，它表示一个算法完全执行所需要的存储空间大小。</li>\n<li>就像时间复杂度的计算不考虑算法所使用的空间大小一样，空间复杂度也不考虑算法运行需要的时间长短。</li>\n</ul>\n<h3 id=\"衡量算法在资源上的两个方面\"><a href=\"#衡量算法在资源上的两个方面\" class=\"headerlink\" title=\"衡量算法在资源上的两个方面\"></a>衡量算法在资源上的两个方面</h3><ul>\n<li>算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。因此衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，即<strong>时间复杂度和空间复杂度</strong>。时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的<strong>额外内存空间</strong>。根据算法编写出的程序，运行时间更短，运行期间占用的内存更少，该算法的运行效率就更高，算法也就更好。</li>\n<li>度量一个程序的执行时间通常有两种方法：</li>\n</ul>\n<ol>\n<li><p>事后统计的方法 （让算法变成一个程序，在机器上执行并计时）<br>缺点：<br>(1) 必须执行程序<br>(2) 其他因素掩盖算法本质</p>\n</li>\n<li><p>事前分析估算的方法（通常使用的）<br>和算法执行时间相关的因素：<br>(1) 算法选用的策略<br>(2) 问题的规模<br>(3) 编写程序的语言<br>(4) 编译程序产生的机器代码的质量<br>(5) 机器执行指令的速度<br>（后三条和计算机的软件和硬件有关，和设计算法无关，所以设计算法时只考虑前两条）</p>\n</li>\n</ol>\n<ul>\n<li>算法的存储量包括：<br>(1) 输入数据所占空间<br>(2) 程序本身所占空间<br>(3) 辅助变量所占空间<ul>\n<li>若<u><strong>输入数据</strong>所占空间只取决于问题本身，<strong>和算法无关</strong></u>，则只需要分析除输入和程序之外的<strong>辅助变量所占额外空间</strong>。</li>\n<li>若<u><strong>所需额外空间</strong>相对于<strong>输入数据量</strong>来说是<strong>常数</strong></u>，则称此算法为<strong>原地工作</strong>。</li>\n<li>若<u><strong>所需存储量</strong>依赖于<strong>特定的输入</strong></u>，则通常按<strong>最坏情况</strong>考虑。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"算法的渐进性分析方法，会用该方法对算法进行评估\"><a href=\"#算法的渐进性分析方法，会用该方法对算法进行评估\" class=\"headerlink\" title=\"算法的渐进性分析方法，会用该方法对算法进行评估\"></a>算法的渐进性分析方法，会用该方法对算法进行评估</h3><h4 id=\"渐进分析\"><a href=\"#渐进分析\" class=\"headerlink\" title=\"渐进分析\"></a>渐进分析</h4><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%B8%90%E8%BF%91%E5%88%86%E6%9E%90\">渐进分析（asymptotic analysis、asymptotics）</a>，在数学分析中是一种描述函数在极限附近的行为的方法。有多个科学领域应用此方法。例子如下：<ul>\n<li>在计算机科学中，<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90\">算法分析</a>考虑给定算法在输入非常大的数据集时候的性能。</li>\n<li>当实体系统的规模变得非常大的时候，分析它的行为。</li>\n</ul>\n</li>\n<li>最简单的例子如下：考虑一个函数f(n)，我们需要了解当n变得非常大的时候f(n)的性质。<br>令<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">f(n)=n^2+3n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mord mathnormal\">n</span></span></span></span>，在n特别大的时候，第二项3n比起第一项<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>要小很多。<br>于是对于这个函数，有如下断言：“f(n)在n→∞的情况下与<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>渐近等价”，记作<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>∼</mo><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">f(n)∼n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>。<h4 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4></li>\n<li>在计算机科学中，<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90\">算法分析（Analysis of algorithm）</a>是分析执行一个给定算法需要消耗的计算资源数量（例如计算时间，存储器使用等）的过程。算法的效率或复杂度在理论上表示为一个函数。其定义域是输入数据的长度（通常考虑任意大的输入，没有上界），值域通常是执行步骤数量（时间复杂度）或者存储器位置数量（空间复杂度）。算法分析是计算复杂度理论的重要组成部分。</li>\n<li>理论分析常常利用<a href=\"https://zh.wikipedia.org/wiki/%E6%B8%90%E8%BF%91%E5%88%86%E6%9E%90\">渐近分析</a>估计一个算法的复杂度，并使用<a href=\"https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7\">大O符号</a>、<a href=\"https://zh.wikipedia.org/wiki/%E5%A4%A7%CE%A9%E7%AC%A6%E5%8F%B7\">大Ω符号</a>和<a href=\"https://zh.wikipedia.org/wiki/%E5%A4%A7%CE%98%E7%AC%A6%E5%8F%B7\">大Θ符号</a>作为标记。举例，二分查找所需的执行步骤数量与查找列表的长度之对数成正比，记为O(log n)，简称为“对数时间”。通常使用渐近分析的原因是，同一算法的不同具体实现的效率可能有差别。但是，对于任何给定的算法，所有符合其设计者意图的实现，它们之间的性能差异应当仅仅是一个系数。</li>\n<li>精确分析算法的效率有时也是可行的，但这样的分析通常需要一些与具体实现相关的假设，称为计算模型。计算模型可以用抽象机器来定义，比如图灵机。或者可以假设某些基本操作在单位时间内可完成。</li>\n<li>假设二分查找的目标列表总共有 n 个元素。如果我们假设单次查找可以在一个时间单位内完成，那么至多只需要 logn + 1 单位的时间就可以得到结果。这样的分析在有些场合非常重要。</li>\n<li>算法分析在实际工作中是非常重要的，因为使用低效率的算法会显著降低系统性能。在对运行时间要求极高的场合，耗时太长的算法得到的结果可能是过期或者无用的。低效率算法也会大量消耗计算资源。<h4 id=\"渐进最优\"><a href=\"#渐进最优\" class=\"headerlink\" title=\"渐进最优\"></a>渐进最优</h4></li>\n<li>在计算机科学中，<a href=\"https://zh.wikipedia.org/wiki/%E6%B8%90%E8%BF%9B%E6%9C%80%E4%BC%98\">渐进最优</a>一词用以评价算法的效率。如果已经证实一个问题需要使用Ω(f(n))的资源来解决，而某个算法用O(f(n))的资源来解决这个问题，则该算法就是渐进最优的。</li>\n<li>渐进最优的例子包括数据结构动态数组，能够在常数时间内索引，但性能在多数机器上不如普通数组的索引。另外，在所有基于比较的排序算法中，归并排序和堆排序是渐进最优的。</li>\n</ul>\n<h3 id=\"三个标记法\"><a href=\"#三个标记法\" class=\"headerlink\" title=\"三个标记法\"></a>三个标记法</h3><ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi></mrow><annotation encoding=\"application/x-tex\">O</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span></span></span></span>标记法<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7\">大O符号</a>（上界）表示函数在增长到一定程度时总小于一个特定函数的常数倍。</li>\n</ul>\n</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Ω</mi></mrow><annotation encoding=\"application/x-tex\">\\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Ω</span></span></span></span>标记法<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%A4%A7%CE%A9%E7%AC%A6%E5%8F%B7\">大Ω符号</a>表示函数在增长到一定程度时总大于一个特定函数的常数倍。</li>\n</ul>\n</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Θ</mi></mrow><annotation encoding=\"application/x-tex\">\\Theta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Θ</span></span></span></span>标记法<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%A4%A7%CE%98%E7%AC%A6%E5%8F%B7\">大Θ符号</a>表示函数在某个区间上的渐近关系。如果两个函数在某个区间上的上界和下界都分别为另一个函数，那么这两个函数在该区间上是渐近相等的，可以用大Θ符号表示为：f(n) = Θ(g(n))</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"时空权衡原则\"><a href=\"#时空权衡原则\" class=\"headerlink\" title=\"时空权衡原则\"></a>时空权衡原则</h3><ul>\n<li>计算机科学中的 <a href=\"https://zh.wikipedia.org/wiki/%E6%97%B6%E7%A9%BA%E6%9D%83%E8%A1%A1\">时空权衡</a>（英语：space–time trade off，又叫<strong>空间换时间</strong>）是指一个算法或程序用增加空间使用量来换取时间减少的情况。这里，空间指的是执行一个给定任务所消耗的数据存储（内存、硬盘等），而时间指的是执行一个给定任务所消耗的时间（计算时间或反应时间）。</li>\n<li>一个给定的时空权衡的效用受到相关的固定和可变成本（如CPU速度、存储空间）的影响，并受到<u>收益递减的</u>影响。</li>\n</ul>\n<h2 id=\"三、线性表\"><a href=\"#三、线性表\" class=\"headerlink\" title=\"三、线性表\"></a>三、线性表</h2><h3 id=\"线性表的定义\"><a href=\"#线性表的定义\" class=\"headerlink\" title=\"线性表的定义\"></a>线性表的定义</h3><ul>\n<li>线性表是具有相同数据类型的n个数据元素的有限序列，n为表长，当n=0时，该线性表是空表。</li>\n</ul>\n<h3 id=\"线性表的逻辑结构\"><a href=\"#线性表的逻辑结构\" class=\"headerlink\" title=\"线性表的逻辑结构\"></a>线性表的逻辑结构</h3><ul>\n<li>线性表是一种逻辑结构，表示元素之间一对一的相邻关系；顺序表和链表是存储结构。</li>\n<li>线性表的<strong>逻辑特性</strong>：若用L命名线性表，则其一般表示为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L=(a_1,a_2,\\cdots,a_i,a_{i+1},\\cdots,a_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。式中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">a_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>是唯一的“第一个”数据元素，又称<strong>表头元素</strong>；<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>是唯一的“最后一个”数据元素，又称<strong>表尾元素</strong>。除第一个元素外，每个元素<strong>有且仅有</strong>一个直接前驱。除最后一个元素外，每个元素<strong>有且仅有</strong>一个直接后继（“直接前驱”和“前驱”、“直接后继”和“后继”通常被视为同义词）。这种线性有序的逻辑结构正是线性表名字的又来。</li>\n<li>线性表的<strong>特点</strong>：<ol>\n<li>表中元素的个数有限。</li>\n<li>表中元素具有逻辑上的顺序性，表中元素有其先后次序。</li>\n<li>表中元素都是数据元素，每个元素都是单个元素。</li>\n<li>表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。</li>\n<li>表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"线性表的基本操作\"><a href=\"#线性表的基本操作\" class=\"headerlink\" title=\"线性表的基本操作\"></a>线性表的基本操作</h3><ol>\n<li>InitList(&amp;L): 初始化表。构造一个空的线性表。</li>\n<li>Length(L): 求表长。返回线性表L的长度，即L中数据元素的个数。</li>\n<li>LocateElem(L,e): 按值查找操作。在表L中查找具有给定关键字值的元素。</li>\n<li>GetElem(L,i): 按位查找操作。获取表L中第i个位置的元素的值。</li>\n<li>ListInsert(&amp;L,i,e): 插入操作。在表L中的第i个位置上插入指定的元素e。</li>\n<li>ListDelete(&amp;L,i,&amp;e): 删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</li>\n<li>PrintList(L): 输出操作。按前后顺序输出线性表L的所有元素值。</li>\n<li>Empty(L): 判空操作。若L为空表，则返回true，否则返回false。</li>\n<li>DestroyList(&amp;L): 销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</li>\n</ol>\n<h3 id=\"顺序表的定义\"><a href=\"#顺序表的定义\" class=\"headerlink\" title=\"顺序表的定义\"></a>顺序表的定义</h3><ul>\n<li>线性表的顺序存储又称<strong>顺序表</strong>。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。</li>\n<li>（称i为元素<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>在顺序表中的<strong>位序</strong>。）</li>\n</ul>\n<h3 id=\"顺序表的特点\"><a href=\"#顺序表的特点\" class=\"headerlink\" title=\"顺序表的特点\"></a>顺序表的特点</h3><ul>\n<li>表中元素的<strong>逻辑顺序</strong>与其存储的<strong>物理顺序</strong><u>相同</u>，因此可以随机存取表中的任一元素，它的存储位置可用一个简单、直观的公式表示。</li>\n</ul>\n<h3 id=\"用顺序存储结构对线性表基本操作的实现\"><a href=\"#用顺序存储结构对线性表基本操作的实现\" class=\"headerlink\" title=\"用顺序存储结构对线性表基本操作的实现\"></a>用顺序存储结构对线性表基本操作的实现</h3><div class=\"tip warning faa-parent animated-hover\"><p class=\"faa-horizontal\"> 注意不可以用int替代数据元素的数据类型，因为数据类型未给定，得用ElemType代替。</p></div>\n<ul>\n<li><p>线性表的动态分配顺序存储结构</p>\n<blockquote>\n<p>数组指针elem指示线性表的基地址，listsize指示顺序表当前分配的存储空间大小，一旦因插入元素而导致空间不足时，可进行再分配，即为顺序表增加一个大小为存储LISTINCREMENT个数据元素的空间。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LIST_INIT_SIZE 100 <span class=\"comment\">//线性表存储空间的初始分配量</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LISTINCREMENT 10 <span class=\"comment\">//线性表存储空间的分配增量</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  ElemType *elem; <span class=\"comment\">//存储空间基址</span></span><br><span class=\"line\">  <span class=\"type\">int</span> length; <span class=\"comment\">//当前长度</span></span><br><span class=\"line\">  <span class=\"type\">int</span> listsize; <span class=\"comment\">//当前分配的存储容量（以sizeof(Elemtype)为单位）</span></span><br><span class=\"line\">&#125;Sqlist;</span><br></pre></td></tr></table></figure></li>\n<li>顺序表的初始化<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">InitList_Sq</span><span class=\"params\">(SqList &amp;L)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//构造一个空的线性表L</span></span><br><span class=\"line\">  L.elem = (ElemType *)<span class=\"built_in\">malloc</span>(LIST_INIT_SIZE * <span class=\"keyword\">sizeof</span>(ElemType));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (! L.elem) <span class=\"built_in\">exit</span>(OVERFLOW); <span class=\"comment\">//存储分配失败</span></span><br><span class=\"line\">  L.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">  L.listsize = LIST_INIT_SIZE; <span class=\"comment\">//初始存储容量</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>插入操作</p>\n<blockquote>\n<p>在第i（1≤i≤n）个元素之前插入一个元素，需将<strong>第n至第i（共n-i+1个）</strong>个元素向后移动一个位置。<br>C语言中数组的下标从“0”开始，因此表中第i个数据元素是L.elem[i-1]。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">ListInsert_Sq</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//在顺序线性表L中第i个位置之前插入新的元素e</span></span><br><span class=\"line\">  <span class=\"comment\">//i的合法值为 1≤i≤ListLength_Sq(L)+1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">1</span> || i &gt; L.length+<span class=\"number\">1</span>) <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//i值不合法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (L.length &gt;= L.listsize) &#123; <span class=\"comment\">//当前存储空间已满，增加分配</span></span><br><span class=\"line\">    newbase = (ElemType *)<span class=\"built_in\">realloc</span>(L.elem, (L.listsize+LISTINCREMENT) * <span class=\"keyword\">sizeof</span>(ElemType));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!newbase) <span class=\"built_in\">exit</span>(OVERFLOW); <span class=\"comment\">//存储分配失败</span></span><br><span class=\"line\">    L.elem = newbase;</span><br><span class=\"line\">    L.listsize += LISTINCREMENT; <span class=\"comment\">//增加存储容量</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  q = &amp;(L.elem[i<span class=\"number\">-1</span>]); <span class=\"comment\">//q为插入位置</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (p = &amp;(L.elem[L.length<span class=\"number\">-1</span>]); p &gt;= q; --p)</span><br><span class=\"line\">    *(p+<span class=\"number\">1</span>) = *p; <span class=\"comment\">//插入位置及之后的元素右移</span></span><br><span class=\"line\">  *q = e; <span class=\"comment\">//插入e</span></span><br><span class=\"line\">  ++ L.length; <span class=\"comment\">//表长增1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>删除操作</p>\n<blockquote>\n<p>删除第i（1≤i≤n）个元素时，需将<strong>从第i+1至n（共n-i）</strong>个元素依次向前移动一个位置。<br>C语言中数组的下标从“0”开始，因此表中第i个数据元素是L.elem[i-1]。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">ListDelete_Sq</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//在顺序线性表L中删除第i个元素，并用e返回其值</span></span><br><span class=\"line\">  <span class=\"comment\">//i的合法值为 1≤i≤ListLength_Sq(L)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">1</span> || i &gt; L.length) <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//i值不合法</span></span><br><span class=\"line\">  p = &amp;(L.elem[i<span class=\"number\">-1</span>]); <span class=\"comment\">//p为被删除元素的位置</span></span><br><span class=\"line\">  e = *p; <span class=\"comment\">//被删除元素的值赋给e</span></span><br><span class=\"line\">  q = L.elem + L.length - <span class=\"number\">1</span>; <span class=\"comment\">//表尾元素的位置（elem表示线性表的基址）</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (++p; p &lt;= q; ++p)</span><br><span class=\"line\">    *(p<span class=\"number\">-1</span>) = *p; <span class=\"comment\">//被删除元素之后的元素左移</span></span><br><span class=\"line\">  --L.length; <span class=\"comment\">//表长减1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>移动元素次数的期望值</p>\n<blockquote>\n<p>当在顺序存储结构的线性表中某个位置上插入或删除一个数据元素时，其时间主要耗费在移动元素上（换句话说，移动元素的操作为预估算法时间复杂度的基本操作），而移动元素的个数取决于插入或删除元素的位置。</p>\n</blockquote>\n<ul>\n<li>假设等概率，<ul>\n<li>插入（在i前插入）：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>E</mi><mrow><mi>i</mi><mi>s</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msubsup><msub><mi>p</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">E_{is} = \\sum\\limits_{i=1}^{n+1}p_i(n-i+1) = \\frac{1}{n+1}\\sum\\limits_{i=1}^{n+1}(n-i+1) = \\frac{n}{2} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">s</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.4788em;vertical-align:-0.9777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5011em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.4788em;vertical-align:-0.9777em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5011em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0404em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6954em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></li>\n<li>删除（第i个）：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>E</mi><mrow><mi>d</mi><mi>l</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>q</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">E_{dl} = \\sum\\limits_{i=1}^{n}q_i(n-i) = \\frac{1}{n}\\sum\\limits_{i=1}^{n}(n-i) = \\frac{n-1}{2} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></li>\n</ul>\n</li>\n<li>若表长为n，则算法 ListInsert_Sq 和 ListDelete_Sq 的时间复杂度为 O(n) 。</li>\n<li>“求表长”（ListLength_Sq）和“取第i个数据元素”（GetElem_Sq）的时间复杂度为 O(1) 。</li>\n<li>LocateElem_Sq 的时间复杂度为 O(L.length) ， union_Sq（A=A∪B） 的时间复杂度为 O ( La.length × Lb.length ) ， MergeList_Sq（C=A∪B） 的时间复杂度为 O ( La.ListLength + Lb.ListLength ) 。</li>\n</ul>\n</li>\n<li><p>按值查找（顺序查找）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">LocateElem_Sq</span><span class=\"params\">(SqList L, ElemType e, Status (*compare)(ElemType, ElemType))</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//在顺序线性表L中查找第1个值与e满足compare()的元素的位序</span></span><br><span class=\"line\">  <span class=\"comment\">//若找到，则返回其在L中的位序，否则返回0</span></span><br><span class=\"line\">  i = <span class=\"number\">1</span>; <span class=\"comment\">//i的初值为第1个元素的位序</span></span><br><span class=\"line\">  p = L.elem; <span class=\"comment\">//p的初值为第1个元素的存储位置</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(i &lt;= L.length &amp;&amp; !(*compare)(*p ++, e))</span><br><span class=\"line\">    ++i;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i &lt;= L.length)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>线性表的合并（A=A∪B）</p>\n<blockquote>\n<p>将存在于线性表LB中，而<strong>不存在于线性表LA中</strong>的数据元素插入到线性表LA中去。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">union</span><span class=\"params\">(List &amp;La, List &amp;Lb)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//将所有在线性表Lb中但不在La中的数据元素插入到La中</span></span><br><span class=\"line\">  La.len = ListLength(La); Lb.len = ListLength(Lb); <span class=\"comment\">//求线性表的长度</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= Lb.len; i++) &#123;</span><br><span class=\"line\">    GetElem(Lb, i, e); <span class=\"comment\">//取Lb中第i个数据元素赋给e</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!LocateElem(La, e, equal)) ListInsert(La, ++ La_len, e); <span class=\"comment\">//La中不存在和e相同的数据元素，则插入之</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>顺序表的合并（C=A∪B）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MergeList_Sq</span><span class=\"params\">(SqList La, SqList Lb, SqList &amp;Lc)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//已知顺序线性表La和Lb的元素按值非递减排列</span></span><br><span class=\"line\">  <span class=\"comment\">//归并La和Lb得到新的顺序线性表Lc，Lc的元素也按值非递减排列</span></span><br><span class=\"line\">  pa = La.elem; pb = Lb.elem;</span><br><span class=\"line\">  Lc.listsize = Lc.length = La.length + Lb.length;</span><br><span class=\"line\">  pc = Lc.elem = (ElemType *)<span class=\"built_in\">malloc</span>(Lc.listsize*<span class=\"keyword\">sizeof</span>(ElemType));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!Lc.elem) <span class=\"built_in\">exit</span>(OVERFLOW); <span class=\"comment\">//存储分配失败</span></span><br><span class=\"line\">  pa_last = La.elem + La.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  pb_last = Lb.elem + Lb.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) &#123; <span class=\"comment\">//归并</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*pa &lt;= *pb) *pc ++ = *pa ++;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> *pc ++ = *pb ++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (pa &lt;= pa_last) *pc ++ = *pa ++; <span class=\"comment\">//插入La的剩余元素</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (pb &lt;= pb_last) *pc ++ = *pb ++; <span class=\"comment\">//插入Lb的剩余元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"链式表的定义\"><a href=\"#链式表的定义\" class=\"headerlink\" title=\"链式表的定义\"></a>链式表的定义</h3><ul>\n<li>链式表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</li>\n</ul>\n<h3 id=\"链式表的特点\"><a href=\"#链式表的特点\" class=\"headerlink\" title=\"链式表的特点\"></a>链式表的特点</h3><ul>\n<li>用一组任意（可连续，也可不连续）的存储单元存储数据元素，对于每个数据元素都需要一个<u>存储其本身信息</u>的<strong>数据域</strong>和<u>存储直接后继存储位置</u>的<strong>指针域</strong>。</li>\n</ul>\n<h3 id=\"用链式存储结构对线性表基本操作的实现（见下）\"><a href=\"#用链式存储结构对线性表基本操作的实现（见下）\" class=\"headerlink\" title=\"用链式存储结构对线性表基本操作的实现（见下）\"></a>用链式存储结构对线性表基本操作的实现（见下）</h3><h3 id=\"链式存储结构的实现技术（比如）\"><a href=\"#链式存储结构的实现技术（比如）\" class=\"headerlink\" title=\"链式存储结构的实现技术（比如）\"></a>链式存储结构的实现技术（比如）</h3><h4 id=\"单向链表\"><a href=\"#单向链表\" class=\"headerlink\" title=\"单向链表\"></a>单向链表</h4><ul>\n<li>线性表的链式存储又称单链表。它是通过一组任意的存储单元来存储线性表中的数据元素。</li>\n<li>为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息之外，还需要存放一个指向其后继的指针。</li>\n<li>结点类型描述：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span></span><br><span class=\"line\">  ElemType data;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure></li>\n<li>利用单链表可以解决顺序表需要大量连续存储单元的缺点，但附加的指针域，也存在浪费存储空间的缺点。</li>\n<li>由于单链表的元素离散地分布在存储空间中，因此是非随机存取的存储结构，即不能直接找到表中某个特定结点。查找特定结点时，需要从表头开始遍历，依次查找。</li>\n<li>通常用<strong>头指针L（或head等）</strong>来标识一个单链表，<u>指出链表的起始地址</u>，<u>头指针为NULL时表示一个空表</u>。</li>\n<li>此外，为了操作上的方便，在单链表第一个数据结点之前附加一个结点，称为<strong>头结点</strong>。</li>\n<li>头结点的数据域可以不设任何信息，但也可以记录表长等信息。单链表带头结点时，头指针L指向头结点；单链表不带头结点时，头指针指向第一个数据结点。</li>\n<li>表尾结点的指针域为NULL（用“^”表示）。</li>\n<li><strong>头结点和头指针的关系</strong>：不管带不带头结点，头指针都始终指向链表的第一个结点，<u>而头结点是带头结点的链表中的第一个结点</u>，结点内通常不存储信息。</li>\n<li>引入<u>头结点</u>后，可以带来<strong>两个优点</strong>：<ol>\n<li>由于第一个数据结点的位置被存放在头结点的指针域中，因此<strong>在链表的第一个位置上的操作和在表的其他位置上的操作一致</strong>，无须进行特殊处理。</li>\n<li>无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），因此<strong>空表和非空表的处理也就得到了统一</strong>。</li>\n</ol>\n</li>\n<li>初始化（王道）：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//带头结点</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitList</span><span class=\"params\">(LinkList &amp;L)</span> &#123;</span><br><span class=\"line\">  L=(LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">  L-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不带头结点</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitList</span><span class=\"params\">(LinkList &amp;L)</span> &#123;</span><br><span class=\"line\">  L=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>求表长（王道）：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Length</span><span class=\"params\">(LinkList L)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> len=<span class=\"number\">0</span>;</span><br><span class=\"line\">  LNode *p=L;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(p-&gt;next!=<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    p=p-&gt;next;</span><br><span class=\"line\">    len++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>按序号查找结点（王道+书）：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//王道</span></span><br><span class=\"line\">LNode *<span class=\"title function_\">GetElem</span><span class=\"params\">(LinkList L, <span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">  LNode *p = L;</span><br><span class=\"line\">  <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(p != NUll &amp;&amp; j &lt; i) &#123;</span><br><span class=\"line\">    p = p -&gt; next;</span><br><span class=\"line\">    j ++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//书</span></span><br><span class=\"line\">Status <span class=\"title function_\">GetElem_L</span><span class=\"params\">(LinkList L, <span class=\"type\">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class=\"line\">  p = L -&gt; next; j = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class=\"line\">    p = p -&gt; next; ++ j;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!p) <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//表长小于i，没有第i个元素</span></span><br><span class=\"line\">  e = p -&gt; data;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>按值查找表结点（王道）：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LNode *<span class=\"title function_\">LocateElem</span><span class=\"params\">(LinkList L, ElemType e)</span> &#123;</span><br><span class=\"line\">  LNode *p = L -&gt; next;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p != <span class=\"literal\">NULL</span> &amp;&amp; p -&gt; data != e) &#123;</span><br><span class=\"line\">    p = p -&gt; next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>插入结点（王道，书上与王道一致不写了）：</p>\n<blockquote>\n<p>注意，当链表不带头结点时，需要判断插入位置i是否为1，若是，则要做特殊处理，将头指针L指向新的首结点。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//王道，将值为x的新结点插入到第i个位置</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span> &#123;</span><br><span class=\"line\">  LNode *p = L;</span><br><span class=\"line\">  <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p != <span class=\"literal\">NULL</span> &amp;&amp; j &lt; i - <span class=\"number\">1</span> ) &#123;</span><br><span class=\"line\">    p = p -&gt; next;</span><br><span class=\"line\">    j ++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (p == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">//i值不合法</span></span><br><span class=\"line\">  LNode *s=(LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">  s -&gt; data = e;</span><br><span class=\"line\">  s -&gt; next = p -&gt; next;</span><br><span class=\"line\">  p -&gt; next = s;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>可以将前插操作写成后插操作+data互换</p>\n<blockquote>\n<p>在单链表插入算法中，通常都采用后插操作。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//需要将*s插入到*p前，用*s插入到*p后+互换data</span></span><br><span class=\"line\">s -&gt; next = p -&gt; next;</span><br><span class=\"line\">p -&gt; next = s;</span><br><span class=\"line\">temp = p -&gt; data;</span><br><span class=\"line\">p -&gt; data = s -&gt; data;</span><br><span class=\"line\">s -&gt; data = temp;</span><br></pre></td></tr></table></figure></li>\n<li><p>删除结点（王道，书上与王道一致不写了）：</p>\n<blockquote>\n<p>注意，当链表不带头结点时，需要判断插入位置i是否为1，若是，则要做特殊处理，将头指针L指向新的首结点。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListDelete</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class=\"line\">  LNode *p = L;</span><br><span class=\"line\">  <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p != <span class=\"literal\">NULL</span> &amp;&amp; j &lt; i - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    p = p -&gt; next;</span><br><span class=\"line\">    j ++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (p == <span class=\"literal\">NULL</span> || p -&gt; next == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">//i值不合法</span></span><br><span class=\"line\">  LNode *q = p -&gt; next;</span><br><span class=\"line\">  e = q -&gt; data;</span><br><span class=\"line\">  p -&gt; next = q -&gt; next;</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(q);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>可以将删除p写成删除p的后继+交换data</p>\n<blockquote>\n<p>删除结点的通常做法是找到p前驱，然后执行删除操作。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q = p -&gt; next;</span><br><span class=\"line\">p -&gt; data = p -&gt; next -&gt; data;</span><br><span class=\"line\">p -&gt; next = q -&gt; next;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(q);</span><br></pre></td></tr></table></figure></li>\n<li>采用头插法建立单链表（插入头结点之后），可以用来实现链表的逆置。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinkList <span class=\"title function_\">List_HeadInsert</span><span class=\"params\">(LinkList &amp;L)</span> &#123;</span><br><span class=\"line\">  LNode *s; <span class=\"type\">int</span> x; <span class=\"comment\">//定义新结点</span></span><br><span class=\"line\">  L = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode)); <span class=\"comment\">//创建头结点</span></span><br><span class=\"line\">  L -&gt; next = <span class=\"literal\">NULL</span>; <span class=\"comment\">//初始为空链表</span></span><br><span class=\"line\">  <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x); <span class=\"comment\">//输入结点的值</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(x!=<span class=\"number\">9999</span>) &#123; <span class=\"comment\">//输入9999表示结束</span></span><br><span class=\"line\">    s = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode)); <span class=\"comment\">//创建新结点</span></span><br><span class=\"line\">    s -&gt; data = x;</span><br><span class=\"line\">    s -&gt; next = L -&gt; next;</span><br><span class=\"line\">    L -&gt; next = s; <span class=\"comment\">//L为头指针</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>采用尾插法建立单链表。为此必须增加一个尾指针r，使其始终指向当前链表的尾结点。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinkList <span class=\"title function_\">List_TailInsert</span><span class=\"params\">(LinkList &amp;L)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> x;</span><br><span class=\"line\">  L = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode)); <span class=\"comment\">//创建头结点</span></span><br><span class=\"line\">  LNode *s, *r = L; <span class=\"comment\">//r为表尾指针</span></span><br><span class=\"line\">  <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(x != <span class=\"number\">9999</span>) &#123; <span class=\"comment\">//输入9999表示结束</span></span><br><span class=\"line\">    s = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">    s -&gt; data = x;</span><br><span class=\"line\">    r -&gt; next = s;</span><br><span class=\"line\">    r = s; <span class=\"comment\">//r指向新的表尾结点</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  r -&gt; next = <span class=\"literal\">NULL</span>; <span class=\"comment\">//尾结点指针置空</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>归并两个链表（书）<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MergeList_L</span><span class=\"params\">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//已知单链线性表La和Lb的元素按值非递减排列</span></span><br><span class=\"line\">  <span class=\"comment\">//归并La和Lb得到新的单链线性表Lc，Lc的元素也按值非递减排列</span></span><br><span class=\"line\">  pa = La -&gt; next; pb = Lb -&gt; next;</span><br><span class=\"line\">  Lc = pc = La; <span class=\"comment\">//用La的头结点作为Lc的头结点</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(pa &amp;&amp; pb) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pa -&gt; data &lt;= pb -&gt; data) &#123;</span><br><span class=\"line\">      pc -&gt; next = pa; pc = pa; pa = pa -&gt; next; <span class=\"comment\">//将pa所指结点链接到pc所指结点之后</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      pc -&gt; next = pb; pc = pb; pb = pb -&gt; next; <span class=\"comment\">//将pb所指结点链接到pc所指结点之后</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  pc -&gt; next = pa ? pa : pb; <span class=\"comment\">//插入剩余段（pa存在连pa，否则连pb）</span></span><br><span class=\"line\">  <span class=\"built_in\">free</span>(Lb); <span class=\"comment\">//释放Lb的头结点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"静态链表\"><a href=\"#静态链表\" class=\"headerlink\" title=\"静态链表\"></a>静态链表</h4><ul>\n<li>静态链表是用数组来描述线性表的链式存储结构（其他链表为指针型描述），结点也有数据域data和指针域next。</li>\n<li>与其他链表中的指针不同的是，这里的指针是<u>结点在数组中的相对地址（书：相对位置）（数组下标）</u>，又称<strong>游标</strong>。</li>\n<li>和顺序表一样，<strong>静态链表也要预先分配一块连续的内存空间</strong>。</li>\n<li>静态链表的插入、删除操作与动态链表的相同，只需要修改指针，而不需要移动元素，故仍具有链式存储结构的主要优点。</li>\n<li>这种描述方法便于在不支持指针的高级程序设计语言（如Basic）中使用链表结构。</li>\n<li>数组的一个分量表示一个结点，数组的第零分量可看成头结点，其指针域只是链表的第一个结点。</li>\n<li>线性表的静态单链表存储结构：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXSIZE 1000 <span class=\"comment\">//链表的最大长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  ElemType data;</span><br><span class=\"line\">  <span class=\"type\">int</span> cur;</span><br><span class=\"line\">&#125;component, SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure></li>\n<li>定位函数（书）<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">LocateElem_SL</span><span class=\"params\">(SLinkList S, ElemType e)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//在静态单链线性表L中查找第1个值为e的元素</span></span><br><span class=\"line\">  <span class=\"comment\">//若找到，则返回它在L中的位序，否则返回0</span></span><br><span class=\"line\">  i = S[<span class=\"number\">0</span>].cur; <span class=\"comment\">//i表中第一个结点</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(i &amp;&amp; S[i].data != e) i = S[i].cur; <span class=\"comment\">//在表中顺链查找</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>求(A-B)∪(B-A)（书P33，挺复杂的，有时间可看）</li>\n</ul>\n<h4 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h4><ul>\n<li>单链表只能从前往后依次遍历；要访问某个结点的前驱（插入、删除操作时），只能从头开始遍历，访问前驱的时间复杂度为O(n)。</li>\n<li>为了克服单链表的这个缺点，引入了<strong>双链表</strong>，双链表结点中有两个指针prior和next，分别指向其直接前驱和直接后继。</li>\n<li>表头结点的prior域和尾结点的next域都是NULL。</li>\n<li>线性表的双向链表存储结构（书）：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DuLNode</span> &#123;</span></span><br><span class=\"line\">  ElemType data;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DuLNode</span> *<span class=\"title\">prior</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DuLNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"单循环链表\"><a href=\"#单循环链表\" class=\"headerlink\" title=\"单循环链表\"></a>单循环链表</h4><ul>\n<li>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环。</li>\n<li>在循环单链表中，<strong>表尾结点*r的next域指向L</strong>，故表中没有指针域为NULL的结点，因此，循环单链表的<strong>判空条件</strong>不是头结点的指针是否为空，而是<strong>它（头结点的指针）是否等于头指针L</strong>。</li>\n<li>循环单链表的插入、删除算法与单链表的几乎一样，所<strong>不同</strong>的是若操作是在<strong>表尾</strong>进行，则执行的操作不同，以让单链表继续保持循环的性质。</li>\n<li>当然，正是因为循环单链表是一个“环”，所有在任何位置上的插入和删除操作都是等价的，而无须判断是否是表尾。</li>\n<li>在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表<u>可以从表中的任意一个结点开始</u>遍历整个链表。</li>\n<li><strong>有时</strong>对循环单链表不设头指针，<strong>而仅设尾指针</strong>，<u>以使得操作效率更高</u>。其原因是，若设的是头指针，对在表尾插入元素需要O(n)的时间复杂度，而若设的是尾指针r，<strong>r-&gt;next即为头指针</strong>，对在表头或插入元素都只需要O(1)的时间复杂度。</li>\n</ul>\n<h4 id=\"双向循环链表\"><a href=\"#双向循环链表\" class=\"headerlink\" title=\"双向循环链表\"></a>双向循环链表</h4><ul>\n<li>与循环单链表不同的是，在循环双链表中，头结点的prior指针还要指向表尾结点。</li>\n<li><strong>表尾结点*p的next域也指向L</strong>；当循环双链表为<strong>空表</strong>时，其<strong>头结点的prior域和next域都等于L</strong>。</li>\n</ul>\n<h4 id=\"带头结点的链表\"><a href=\"#带头结点的链表\" class=\"headerlink\" title=\"带头结点的链表\"></a>带头结点的链表</h4><p>（对于单链表：）</p>\n<ul>\n<li>头结点的数据域可以不设任何信息，但也可以记录表长等信息。单链表带头结点时，头指针L指向头结点；单链表不带头结点时，头指针指向第一个数据结点。</li>\n<li><strong>头结点和头指针的关系</strong>：不管带不带头结点，头指针都始终指向链表的第一个结点，<u>而头结点是带头结点的链表中的第一个结点</u>，结点内通常不存储信息。</li>\n<li>引入<u>头结点</u>后，可以带来<strong>两个优点</strong>：<ol>\n<li>由于第一个数据结点的位置被存放在头结点的指针域中，因此<strong>在链表的第一个位置上的操作和在表的其他位置上的操作一致</strong>，无须进行特殊处理。</li>\n<li>无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），因此<strong>空表和非空表的处理也就得到了统一</strong>。</li>\n</ol>\n</li>\n<li>初始化（王道）：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//带头结点</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitList</span><span class=\"params\">(LinkList &amp;L)</span> &#123;</span><br><span class=\"line\">  L=(LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">  L-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不带头结点</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitList</span><span class=\"params\">(LinkList &amp;L)</span> &#123;</span><br><span class=\"line\">  L=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>对于插入操作，当链表不带头结点时，需要判断插入位置i是否为1，若是，则要做特殊处理，将头指针L指向新的首结点。</li>\n<li>对于删除操作，当链表不带头结点时，需要判断插入位置i是否为1，若是，则要做特殊处理，将头指针L指向新的首结点。</li>\n</ul>\n<p>（单循环链表，关于头结点的部分）</p>\n<ul>\n<li>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环。</li>\n<li>在循环单链表中，<strong>表尾结点*r的next域指向L</strong>，故表中没有指针域为NULL的结点，因此，循环单链表的<strong>判空条件</strong>不是头结点的指针是否为空，而是<strong>它（头结点的指针）是否等于头指针L</strong>。<br>（双向循环链表，关于头结点的部分）<h4 id=\"双向循环链表-1\"><a href=\"#双向循环链表-1\" class=\"headerlink\" title=\"双向循环链表\"></a>双向循环链表</h4></li>\n<li>与循环单链表不同的是，在循环双链表中，头结点的prior指针还要指向表尾结点。</li>\n<li><strong>表尾结点*p的next域也指向L</strong>；当循环双链表为<strong>空表</strong>时，其<strong>头结点的prior域和next域都等于L</strong>。</li>\n</ul>\n<h3 id=\"线性表的应用\"><a href=\"#线性表的应用\" class=\"headerlink\" title=\"线性表的应用\"></a>线性表的应用</h3><h4 id=\"一元多项式的表示和相加\"><a href=\"#一元多项式的表示和相加\" class=\"headerlink\" title=\"一元多项式的表示和相加\"></a>一元多项式的表示和相加</h4><blockquote>\n<p>这个应该是线性表的应用吧，书P39</p>\n</blockquote>\n<ul>\n<li>代码很复杂，大致思路：</li>\n</ul>\n<ol>\n<li>先将一个一元n次多项式按照升幂写成<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>p</mi><mn>1</mn></msub><msup><mi>x</mi><msub><mi>e</mi><mn>1</mn></msub></msup><mo>+</mo><msub><mi>p</mi><mn>2</mn></msub><msup><mi>x</mi><msub><mi>x</mi><mn>2</mn></msub></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>p</mi><mi>m</mi></msub><msup><mi>x</mi><msub><mi>e</mi><mi>m</mi></msub></msup></mrow><annotation encoding=\"application/x-tex\">P_n(x) = p_1 x^{e_1} + p_2 x^{x_2} + \\cdots + p_m x^{e_m} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8588em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8588em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8588em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1645em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，<br>其中<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>是指数为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">e_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的项的非零系数，且满足<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>e</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>e</mi><mn>2</mn></msub><mo>&lt;</mo><mo>⋯</mo><mo>&lt;</mo><msub><mi>e</mi><mi>m</mi></msub><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">0 \\leq e_1 &lt; e_2 &lt; \\cdots &lt; e_m = n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></li>\n<li>用线性链表表示一元多项式，每个结点表示多项式中的一项，每个结点存储系数和指数。</li>\n<li>实现两个多项式（用两个线性链表表示）的相加：类似于归并，因为指数升序排列，对于指数相同的把系数相加即可。</li>\n<li>实现多项式相乘：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>A</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>A</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mo stretchy=\"false\">[</mo><msub><mi>b</mi><mn>1</mn></msub><msup><mi>x</mi><msub><mi>e</mi><mn>1</mn></msub></msup><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><msup><mi>x</mi><msub><mi>e</mi><mn>2</mn></msub></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>b</mi><mi>n</mi></msub><msup><mi>x</mi><msub><mi>e</mi><mi>n</mi></msub></msup><mo stretchy=\"false\">]</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>b</mi><mi>i</mi></msub><mi>A</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>x</mi><msub><mi>e</mi><mi>i</mi></msub></msup></mrow><annotation encoding=\"application/x-tex\">M(x)=A(x)×B(x)\n    =A(x)×[b_1x^{e_1}+b_2x^{e_2}+\\cdots +b_nx^{e_n}]\n    =\\sum\\limits_{i=1}^n b_i A(x)x^{e_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1645em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3281em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>\n</ol>\n<h3 id=\"具有在实际中选取不同存储结构的判断能力\"><a href=\"#具有在实际中选取不同存储结构的判断能力\" class=\"headerlink\" title=\"具有在实际中选取不同存储结构的判断能力\"></a>具有在实际中选取不同存储结构的判断能力</h3><h4 id=\"顺序表和链表的比较\"><a href=\"#顺序表和链表的比较\" class=\"headerlink\" title=\"顺序表和链表的比较\"></a>顺序表和链表的比较</h4><p>（出自蓝皮书）</p>\n<ul>\n<li>顺序表<ul>\n<li>优点：</li>\n</ul>\n<ol>\n<li>时间上，它可以顺序存储，还可以随机存取，访问速度快；</li>\n<li>空间上，它的存储利用率高，不需要指针。</li>\n</ol>\n<ul>\n<li>缺点：</li>\n</ul>\n<ol>\n<li>时间上，顺序表在插入删除时，如果需要保持原来的顺序，必须平均移动一半的元素，更新速度慢；</li>\n<li>空间上，如果采用静态分配的存储结构，一旦存储数组的空间已满，不能扩充，再插入元素将导致溢出。</li>\n</ol>\n</li>\n<li>链表<ul>\n<li>优点：</li>\n</ul>\n<ol>\n<li>时间上，插入删除不需要大量移动元素，只需修改指针，更新速度快；</li>\n<li>空间上，链表基本没有满和溢出的问题，只要内存可以分配节点，就可以扩充。</li>\n</ol>\n<ul>\n<li>缺点：</li>\n</ul>\n<ol>\n<li>时间上，链表只能顺序访问，所以查找一个元素平均要搜索半个表，访问速度慢；</li>\n<li>空间上，每个元素需要附加一个指针，存储利用率较低。</li>\n<li>此外，由于链表的单线联系的特性，如果操作不慎，导致断链，将会丢失后面的所有元素。</li>\n</ol>\n</li>\n</ul>\n<p>（出自王道）</p>\n<ol>\n<li>存取（读/写）方式<ul>\n<li>顺序表可以顺序存取，也可以随机存；</li>\n<li>链表只能从表头开始依次顺序存取。</li>\n</ul>\n</li>\n<li>逻辑结构与物理结构<ul>\n<li>采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻；</li>\n<li>采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。</li>\n</ul>\n</li>\n<li>查找、插入和删除操作<ul>\n<li>对于按值查找，<ul>\n<li>顺序表无序时，两者的时间复杂度均为O(n)；</li>\n<li>顺序表有序时，可采用折半查找，此时的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log_2n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n</li>\n<li>对于按序号查找，<ul>\n<li>顺序表支持随机访问，时间复杂度为O(1)；</li>\n<li>链表的平均时间复杂度为O(n)。</li>\n</ul>\n</li>\n<li>插入、删除操作<ul>\n<li>顺序表平均需要移动半个表长的元素；</li>\n<li>链表只需修改相关结点的指针域即可。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>空间分配<ul>\n<li>顺序存储<ul>\n<li>在静态存储分配情形下，<ul>\n<li>一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，因此需要预先分配足够大的存储空间。</li>\n<li>预先分配过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成溢出。</li>\n</ul>\n</li>\n<li>在动态存储分配情形下，<ul>\n<li>虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低；</li>\n<li>而且若内存中没有更大块的连续存储空间，则会导致分配失败。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>链式存储<ul>\n<li>结点空间只在需要时申请分配，</li>\n<li>只要有内存就可以分配，</li>\n<li>操作灵活、高效。</li>\n<li>此外，由于链表的每个结点都带有指针域，因此存储密度不够大。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"在实际中怎样选取存储结构\"><a href=\"#在实际中怎样选取存储结构\" class=\"headerlink\" title=\"在实际中怎样选取存储结构\"></a>在实际中怎样选取存储结构</h4><p>（出自王道）</p>\n<ol>\n<li>基于存储的考虑<ul>\n<li>难以估计线性表的长度或存储规模时，不宜采用顺序表；</li>\n<li>但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。</li>\n</ul>\n</li>\n<li>基于运算的考虑<ul>\n<li>若经常做的运算是按序号访问数据元素，<strong>顺序表优于链表</strong>。<ul>\n<li>在顺序表中按序号访问<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的时间复杂度为O(1)；</li>\n<li>链表中按序号访问的时间复杂度为O(n)。</li>\n</ul>\n</li>\n<li>关于插入、删除操作。<ul>\n<li>在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的；</li>\n<li>在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然<strong>链表优于顺序表</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>基于环境的考虑<ul>\n<li>顺序表容易实现，任何高级语言中都有数组类型；</li>\n<li>链表的操作是基于指针的，相对来讲，前者实现较为简单，这也是用户考虑的一个因素。</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>总之，两种存储结构各有长短，选择哪一种由实际问题的主要因素决定。</li>\n<li>通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表（即动态性较强）宜选择链式存储。</li>\n</ul>\n<h3 id=\"广义表\"><a href=\"#广义表\" class=\"headerlink\" title=\"广义表\"></a>广义表</h3><blockquote>\n<p>不记得在哪的知识点了，先写在这儿了。<br>内容来自<a href=\"https://www.cnblogs.com/kuailest/p/16743376.html\">博客</a>。</p>\n</blockquote>\n<h4 id=\"广义表的定义\"><a href=\"#广义表的定义\" class=\"headerlink\" title=\"广义表的定义\"></a>广义表的定义</h4><ul>\n<li><strong>线性表</strong> 线性表指的是n≥0个元素a1, a2, a3…的有序数列，并且线性表的元素具有原子性，即结构上是不可分割的一个整体。</li>\n<li><strong>广义表(Generalized list)</strong> 而广义表则是线性表的一种扩展延伸。相对于线性表，广义表最大的特点在于其元素既可以是一个确定的类型，同时也可以是另一个有不定数量的元素组成的表（广义表）。<br>不难看出从广义表的定义是递归的。广义表是线性表的递归数据结构。</li>\n</ul>\n<h4 id=\"广义表的基本概念\"><a href=\"#广义表的基本概念\" class=\"headerlink\" title=\"广义表的基本概念\"></a>广义表的基本概念</h4><ul>\n<li><strong>广义表的表示</strong><br>我们通常可以用 GL = (a1, a2, a3… an)来表示一个广义表，其中n为表的长度，n≥0，当n==0时，我们称广义表为空表，GL为广义表的名字。<br>为了能更好的区分广义表中的元素我们有以下定义：<br><strong>原子</strong> 如果ai是单个元素，我们称之为GL的原子<br><strong>子表</strong> 如果ai是一个广义表，我们陈之为GL的子表<br>我们通常把广义表中的原子用小写字母表示，而子表用大写字母表示。例如<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A=() //空表</span><br><span class=\"line\">B=(e) //只含有一个原子的广义表</span><br><span class=\"line\">C=(a,(b,c,d)) //含有一个原子和一个子表的广义表</span><br><span class=\"line\">D=(A,B,C)=((),(e),(a,(b,c,d))) //含有三个子表的广义表，且第一个表为空表</span><br><span class=\"line\">E=(a,E) //广义表 E 中有两个元素，原子 a 和它本身。这是一个递归广义表，等同于：E = (a,(a,(a,…)))。</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>广义表的深度和长度</strong><br><strong>广义表的长度</strong>： 广义表中元素的个数（包括原子和子表）<br><strong>广义表的深度</strong>： 广义表中括号的最大层数叫广义表的深度</p>\n</li>\n<li><p><strong>广义表的表头和表尾</strong><br><strong>表头</strong>： 当广义表不为空表时，第一个元素（可能为子表和原子）称为表头<br><strong>表尾</strong>： 除去表头，剩余元素组成的新广义表称为表尾<br>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LS=(1,(1,2,3),5), 其中表头Head(LS)为原子1，表尾为Tail(LS)=((1,2,3),5)</span><br><span class=\"line\">LS=(1), 其中表头Head(LS)为原子1，表尾为空表</span><br></pre></td></tr></table></figure>\n<h4 id=\"广义表的存储结构\"><a href=\"#广义表的存储结构\" class=\"headerlink\" title=\"广义表的存储结构\"></a>广义表的存储结构</h4><p>广义表是一种递归的数据结构，它的元素有两种类型，因此很难为广义表分配固定的存储空间，所以其存储结构适合用链式存储结构。<br>为了能使原子和子表在结构上保持一致，又容易区分我们通常采用如下结构：<br><strong>广义表的第一种存储结构</strong><br><img src=\"/articles/9eb01842/GL_1.png\" width=80% height=70% /></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span>ATOM,LIST &#125; ElemTag; <span class=\"comment\">//ATOM==0:表示原子,LIST==1:表示子表</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GLNode</span> &#123;</span></span><br><span class=\"line\">  ElemTag tag; <span class=\"comment\">//公共部分，用以区分原子部分和表结点</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span> <span class=\"comment\">//原子部分和表结点的联合部分</span></span><br><span class=\"line\">    AtomType atom; <span class=\"comment\">//atom是原子结点的值域,  AtomType由用户定义</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GLNode</span> *<span class=\"title\">hp</span>, *<span class=\"title\">tp</span>;</span>&#125; ptr;</span><br><span class=\"line\">    <span class=\"comment\">// ptr是表结点的指针域,ptr.hp和ptr.tp分别指向表头和表尾</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125; *Glist; <span class=\"comment\">//广义表类型</span></span><br></pre></td></tr></table></figure>\n<p>e.g. 表示（a,(b,c,d)）<br><img src=\"/articles/9eb01842/GL_11.png\" width=100% height=70% /></p>\n</li>\n</ul>\n<p><strong>广义表的第二种存储结构</strong><br><img src=\"/articles/9eb01842/GL_2.png\" width=80% height=70% /><br>第二种表示形式实际上就只是在原子中添加了tp指针指向下一个原子或子表<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Typedef <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span> ATOM,LIST&#125; ElemTag;</span><br><span class=\"line\"><span class=\"comment\">//ATOM==0:表示原子,LIST==1:表示子表</span></span><br><span class=\"line\">Typedef <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GLNode</span> &#123;</span></span><br><span class=\"line\">  ElemTag tag; <span class=\"comment\">//公共部分，用以区分原子部分和表结点</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span> <span class=\"comment\">//原子部分和表结点的联合部分</span></span><br><span class=\"line\">    AtomType atom; <span class=\"comment\">//原子结点的值域</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GLNode</span> *<span class=\"title\">hp</span>;</span> <span class=\"comment\">//表结点的表头指针</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GLNode</span> *<span class=\"title\">tp</span>;</span></span><br><span class=\"line\">  <span class=\"comment\">//相当于线性链表的next，指向下一个元素结点</span></span><br><span class=\"line\">&#125; *Glist; <span class=\"comment\">//广义表类型Glist 是一种扩展的线性链表</span></span><br></pre></td></tr></table></figure><br>e.g. 表示（a,(b,c,d)）<br><img src=\"/articles/9eb01842/GL_22.png\" width=100% height=70% /></p>\n<h4 id=\"广义表的计算（以第二种存储结构为例）\"><a href=\"#广义表的计算（以第二种存储结构为例）\" class=\"headerlink\" title=\"广义表的计算（以第二种存储结构为例）\"></a>广义表的计算（以第二种存储结构为例）</h4><p>（<a href=\"https://zh.wikipedia.org/wiki/%E5%B9%BF%E4%B9%89%E8%A1%A8\">wiki</a>）D=(( ),(e),(a,(b,c,d)))是多层次的广义表，长度为3，深度为3。<br><strong>广义表长度的计算</strong>（类似于链表的长度，直接统计tp）<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">GLLength</span><span class=\"params\">(GLNode *g)</span> &#123; <span class=\"comment\">//g为一个广义表头节点的指针</span></span><br><span class=\"line\">  <span class=\"type\">int</span> n=<span class=\"number\">0</span>;</span><br><span class=\"line\">  g=g-&gt;hp; <span class=\"comment\">//g指向广义表的第一个元素</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (g!=<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    n++;</span><br><span class=\"line\">    g=g-&gt;tp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>广义表的深度</strong>（括号的最大层数）<br>对于带头节点的广义表g,广义表深度的递归定义是它等于所有子表中表的最大深度加1。若g为原子,其深度为0。<br><img src=\"/articles/9eb01842/GL_3.png\" width=70% height=70% /><br>求广义表深度的递归模型f()如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">GLDepth</span><span class=\"params\">(GLNode *g)</span> &#123; <span class=\"comment\">//求带头节点的广义表g的深度</span></span><br><span class=\"line\">  <span class=\"type\">int</span> max=<span class=\"number\">0</span>,dep;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g-&gt;tag==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">//为原子时返回0</span></span><br><span class=\"line\">  g=g-&gt;hp; <span class=\"comment\">//g指向第一个元素</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">//为空表时返回1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (g!=<span class=\"literal\">NULL</span>) &#123; <span class=\"comment\">//遍历表中的每一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g-&gt;tag==<span class=\"number\">1</span>) &#123;　<span class=\"comment\">//元素为子表的情况</span></span><br><span class=\"line\">      dep=GLDepth(g); <span class=\"comment\">//递归调用求出子表的深度</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (dep&gt;max) max=dep;</span><br><span class=\"line\">      <span class=\"comment\">//max为同一层所求过的子表中深度的最大值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    g=g-&gt;tp; <span class=\"comment\">//使g指向下一个元素</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>(max+<span class=\"number\">1</span>); <span class=\"comment\">//返回表的深度</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、栈和队列\"><a href=\"#四、栈和队列\" class=\"headerlink\" title=\"四、栈和队列\"></a>四、栈和队列</h2><blockquote>\n<p>博客：<br><a href=\"https://cloud.tencent.com/developer/article/2456014\">栈的深度解析：顺序栈与链栈的实现</a><br><a href=\"https://cloud.tencent.com/developer/article/2456015\">队列的深度解析：链式队列的实现</a></p>\n</blockquote>\n<h3 id=\"栈的定义\"><a href=\"#栈的定义\" class=\"headerlink\" title=\"栈的定义\"></a>栈的定义</h3><ul>\n<li><strong>栈</strong>是一种后进先出（LIFO）的线性表，只允许在表尾进行插入和删除操作。</li>\n<li><strong>栈顶</strong>——<u>表尾端</u>（线性表允许进行插入和删除操作的那一端）。</li>\n<li><strong>栈底</strong>——<u>表头端</u>（线性表不允许进行插入和删除操作的那一端）。</li>\n<li><strong>空栈</strong>——不含任何元素的空表。</li>\n</ul>\n<h3 id=\"栈的逻辑结构\"><a href=\"#栈的逻辑结构\" class=\"headerlink\" title=\"栈的逻辑结构\"></a>栈的逻辑结构</h3><ul>\n<li>栈是操作受限的线性表，可被称为限定性的数据结构，其操作特性是后进先出（Last In First Out，LIFO）。</li>\n<li>栈是只允许在一端进行插入和删除操作的线性表，允许进行插入和删除操作的那一端称为栈顶，不允许进行插入和删除操作的另一端称为栈底。</li>\n</ul>\n<h3 id=\"栈的特点（考点没写）\"><a href=\"#栈的特点（考点没写）\" class=\"headerlink\" title=\"栈的特点（考点没写）\"></a>栈的特点（考点没写）</h3><ul>\n<li><strong>操作限制：</strong>只能在栈顶进行元素的添加（入栈）和移除（出栈）。</li>\n<li><strong>栈顶元素：</strong>当前可以访问和操作的元素。</li>\n<li><strong>空栈：</strong>栈为空时，无法进行出栈操作。</li>\n</ul>\n<h3 id=\"栈的操作特性（考点没写）\"><a href=\"#栈的操作特性（考点没写）\" class=\"headerlink\" title=\"栈的操作特性（考点没写）\"></a>栈的操作特性（考点没写）</h3><ul>\n<li>后进先出（Last In First Out，LIFO）</li>\n</ul>\n<h3 id=\"栈的基本操作\"><a href=\"#栈的基本操作\" class=\"headerlink\" title=\"栈的基本操作\"></a>栈的基本操作</h3><ul>\n<li><strong>入栈（Push）：</strong>将新元素添加到栈顶。</li>\n<li><strong>出栈（Pop）：</strong>移除并返回栈顶元素。</li>\n<li><strong>查看栈顶元素（GetTop）：</strong>返回栈顶元素，但不删除它。</li>\n<li><strong>判断是否为空（IsEmpty）：</strong>检查栈是否没有元素。</li>\n<li><strong>统计栈的大小（Size）：</strong>获取栈中有效元素个数。</li>\n</ul>\n<h3 id=\"栈的数学性质（考点没写）\"><a href=\"#栈的数学性质（考点没写）\" class=\"headerlink\" title=\"栈的数学性质（考点没写）\"></a>栈的数学性质（考点没写）</h3><ul>\n<li>当n个不同元素进栈时，出栈元素不同排列的个数为<br><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><msubsup><mi mathvariant=\"normal\">C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{n+1}\\mathrm{C}_{2n}^{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2484em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.4519em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span></span></span></span>。这个公式称为卡特兰数（Catalan）公式。</li>\n<li>证明：</li>\n</ul>\n<ol>\n<li>画个n*n条路（边）的方格，从一个顶点走到另一个斜对角的端点总共要走2n条边，从中选择n条边为竖着走或横着走（类比为进栈或出栈），剩下n条为横着走或竖着走，得到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">\\mathrm{C}_{2n}^{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9314em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.4519em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span></span></span></span>种方式。</li>\n<li>过了斜对角线的路径是有问题的，就是在某个前缀操作里边出栈次数多于入栈了（拿鬼出栈啊），求出这些非法路径的数目。</li>\n<li>设不能越过的对角线为y=x，从(0,0)→(n,n)。画出y=x+1，作为对称轴。若越过y=x，与y=x+1就会有交点，把第一次碰到y=x+1以后的部分关于y=x+1对称，路径变为(0,0)→(n-1,n+1)。显然每一条非法路径都可以这么变为(0,0)→(n-1,n+1)，而任何合法方案由于不接触直线y=x+1，无论从哪个点对称都不是一条连续的路径。</li>\n<li>非法路径条数为(0,0)→(n-1,n+1)的方案数，为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">\\mathrm{C}_{2n}^{n-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1205em;vertical-align:-0.2663em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8542em;\"><span style=\"top:-2.4337em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.1031em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2663em;\"><span></span></span></span></span></span></span></span></span></span>。</li>\n<li>合法路径数=<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup><mo>−</mo><msubsup><mi mathvariant=\"normal\">C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow><mrow><mi>n</mi><mo stretchy=\"false\">!</mo><mi>n</mi><mo stretchy=\"false\">!</mo></mrow></mfrac><mo>−</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mrow><mi>n</mi><mo stretchy=\"false\">!</mo><mi>n</mi><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mfrac><mo>−</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo><mi>n</mi></mrow><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi>n</mi><mo stretchy=\"false\">!</mo><mi>n</mi><mo stretchy=\"false\">!</mo></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo stretchy=\"false\">[</mo><mfrac><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>−</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo><mi>n</mi></mrow><mrow><mi>n</mi><mo stretchy=\"false\">!</mo><mi>n</mi><mo stretchy=\"false\">!</mo></mrow></mfrac><mo stretchy=\"false\">]</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><msubsup><mi mathvariant=\"normal\">C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">\\mathrm{C}_ {2n}^{n}-\\mathrm{C}_{2n}^{n-1} =\\frac{(2n)!}{n!n!}-\\frac{(2n)!}{(n+1)!(n-1)!} =\\frac{(2n)!(n+1)}{n!n!(n+1)}-\\frac{(2n)!n}{(n+1)n!n!} =\\frac{1}{n+1}[\\frac{(2n)!(n+1)-(2n)!n}{n!n!}] =\\frac{1}{n+1} \\mathrm{C}_{2n}^{n} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9314em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.4519em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1205em;vertical-align:-0.2663em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8542em;\"><span style=\"top:-2.4337em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.1031em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2663em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)!</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.53em;vertical-align:-0.52em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)!</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)!</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)!</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.53em;vertical-align:-0.52em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)!</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.53em;vertical-align:-0.52em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)!</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.4133em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)!</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mbin mtight\">−</span><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)!</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2484em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord\"><span class=\"mord mathrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.4519em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span></span></span></span></li>\n</ol>\n<h3 id=\"顺序栈的定义\"><a href=\"#顺序栈的定义\" class=\"headerlink\" title=\"顺序栈的定义\"></a>顺序栈的定义</h3><ul>\n<li><strong>顺序栈</strong>：采用顺序存储的栈，利用一组地址连续的存储单元依次存放<u>自栈底到栈顶</u>的数据元素，同时附设一个指针top指示栈顶元素在顺序栈中的位置。</li>\n</ul>\n<h3 id=\"链式栈的定义\"><a href=\"#链式栈的定义\" class=\"headerlink\" title=\"链式栈的定义\"></a>链式栈的定义</h3><ul>\n<li><strong>链栈</strong>：采用链式存储的栈。优点是便于多个栈共享存储空间和提高其效率，且不易发生栈溢出。</li>\n<li>通常用单链表实现，并规定所有操作都是在单链表的表头进行的。</li>\n</ul>\n<h3 id=\"顺序栈和链式栈的特点\"><a href=\"#顺序栈和链式栈的特点\" class=\"headerlink\" title=\"顺序栈和链式栈的特点\"></a>顺序栈和链式栈的特点</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>特点</strong></th>\n<th><strong>顺序栈 (Sequential Stack)</strong></th>\n<th><strong>链式栈 (Linked Stack)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存储结构</strong></td>\n<td>基于数组实现</td>\n<td>基于链表实现</td>\n</tr>\n<tr>\n<td><strong>内存布局</strong></td>\n<td>内存连续</td>\n<td>内存不连续，元素间通过指针连接</td>\n</tr>\n<tr>\n<td><strong>内存管理</strong></td>\n<td>静态分配（可动态扩容）</td>\n<td>动态分配</td>\n</tr>\n<tr>\n<td><strong>空间效率</strong></td>\n<td>容量固定（可动态扩容，若超出初始容量则可能浪费空间）</td>\n<td>动态扩展，使用的空间与元素个数相匹配</td>\n</tr>\n<tr>\n<td><strong>访问速度</strong></td>\n<td>O(1) 时间复杂度</td>\n<td>O(1) 时间复杂度</td>\n</tr>\n<tr>\n<td><strong>空间复杂度</strong></td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td><strong>栈溢出</strong></td>\n<td>容易发生，尤其在固定容量情况下</td>\n<td>不易发生，除非系统内存耗尽</td>\n</tr>\n<tr>\n<td><strong>实现简单性</strong></td>\n<td>实现较为简单，适用于容量已知的情况</td>\n<td>实现复杂，需处理节点的动态分配与释放</td>\n</tr>\n<tr>\n<td><strong>元素访问</strong></td>\n<td>只能访问栈顶元素</td>\n<td>只能访问栈顶元素</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>适合对栈容量有明确限制的场景</td>\n<td>适合不确定栈容量，且需频繁变化元素的场景</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"顺序栈的基本操作\"><a href=\"#顺序栈的基本操作\" class=\"headerlink\" title=\"顺序栈的基本操作\"></a>顺序栈的基本操作</h3><ul>\n<li><p>定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STACK_INIT_SIZE 100 <span class=\"comment\">//存储空间初始分配量</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STACKINCREMENT 10 <span class=\"comment\">//存储空间分配增量</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  SELemType *base;</span><br><span class=\"line\">  SElemType *top;</span><br><span class=\"line\">  <span class=\"type\">int</span> stacksize; <span class=\"comment\">//栈的当前可使用的最大容量</span></span><br><span class=\"line\">&#125;SqStack;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">InitStack</span><span class=\"params\">(SqStack &amp;S)</span> &#123;</span><br><span class=\"line\">  S.base = (SElemType *)<span class=\"built_in\">malloc</span>(STACK_INIT_SIZE*<span class=\"keyword\">sizeof</span>(SElemType));</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!S.base) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">  S.top = S.base;</span><br><span class=\"line\">  S.stacksize = STACK_INIT_SIZE;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看栈顶元素</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">GetTop</span><span class=\"params\">(SqStack S, ElemType &amp;e)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(S.top == S.base) <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//栈空</span></span><br><span class=\"line\">  e = *(S.top<span class=\"number\">-1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>入栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 插入元素e为新的栈顶元素</span></span><br><span class=\"line\">Status <span class=\"title function_\">Push</span><span class=\"params\">(SqStack &amp;S, SElemType e)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(S.top - S.base &gt;= S.stacksize) &#123; <span class=\"comment\">//栈满，追加存储空间</span></span><br><span class=\"line\">    S.base = (SElemType *)<span class=\"built_in\">realloc</span>((S.stacksize+STACKINCREMENT)*<span class=\"keyword\">sizeof</span>(ElemType));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!S.base) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">    S.top = S.base + S.stacksize;</span><br><span class=\"line\">    S.stacksize +=STACKINCREMENT;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  *S.top ++ = e;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>出栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">Pop</span><span class=\"params\">(SqStack &amp;S, ElemType &amp;e)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(S.top == S.base) <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//栈空</span></span><br><span class=\"line\">  e = *--S.top;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>注</strong>：验证过<code>*S.top++ = e</code>和<code>e = *--S.top</code>，代码如下，输入结果为1。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *top;</span><br><span class=\"line\">    <span class=\"type\">int</span> *base;</span><br><span class=\"line\">    <span class=\"type\">int</span> stacksize;</span><br><span class=\"line\">&#125; SqStack;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    SqStack S;</span><br><span class=\"line\">    S.base = (<span class=\"type\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>*<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    S.top = S.base;</span><br><span class=\"line\">    *S.top ++ = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cout&lt;&lt;*--S.top&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>情况分析：<code>S.top = -1</code> 和 <code>S.top = 0</code>。注意：声明struct的时候，用的是<code>ElemType data[Maxsize]</code>，所以不要出现<code>top==Maxsize</code>时<code>S.data[top]</code>，先把top降掉。</p>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>属性</strong></th>\n<th><strong>当 <code>S.top = -1</code> 时</strong></th>\n<th><strong>当 <code>S.top = 0</code> 时</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>初始时</strong></td>\n<td><code>S.top = -1</code></td>\n<td><code>S.top = 0</code></td>\n</tr>\n<tr>\n<td><strong>栈的第一个元素</strong></td>\n<td><code>S.data[0]</code></td>\n<td><code>S.data[0]</code></td>\n</tr>\n<tr>\n<td><strong>栈顶指针指向</strong></td>\n<td>指向栈顶元素</td>\n<td>指向栈顶元素的后一个元素</td>\n</tr>\n<tr>\n<td><strong>栈满条件</strong></td>\n<td><code>top == MAX_SIZE - 1</code></td>\n<td><code>top == MAX_SIZE</code></td>\n</tr>\n<tr>\n<td><strong>栈空条件</strong></td>\n<td><code>top == -1</code></td>\n<td><code>top == 0</code></td>\n</tr>\n<tr>\n<td><strong>进栈操作</strong></td>\n<td><code>判栈满，S.data[++top] = x;</code></td>\n<td><code>判栈满，S.data[top++] = x;</code></td>\n</tr>\n<tr>\n<td><strong>出栈操作</strong></td>\n<td><code>判栈空，x = S.data[top--];</code></td>\n<td><code>判栈空，x = S.data[--top];</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"链栈的基本操作\"><a href=\"#链栈的基本操作\" class=\"headerlink\" title=\"链栈的基本操作\"></a>链栈的基本操作</h3><ul>\n<li><p>声明（王道）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Linknode</span> &#123;</span></span><br><span class=\"line\">  ElemType data;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Linknode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;ListStack;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>链栈通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。</p>\n</li>\n<li>这里规定链栈没有头结点，Lhead指向栈顶元素。</li>\n</ul>\n<h3 id=\"共享栈（考点没写）\"><a href=\"#共享栈（考点没写）\" class=\"headerlink\" title=\"共享栈（考点没写）\"></a>共享栈（考点没写）</h3><ul>\n<li>利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。</li>\n<li>共享栈时为了更有效地利用存储空间，两个栈的空间相互调节，只有再整个存储空间被占满时才发生上溢。</li>\n<li>其存取数据的时间复杂度均为O(1)，所以对存取效率没什么影响。</li>\n</ul>\n<table>\n  <tr>\n    <th>共享栈</th>\n    <th>0号栈</th>\n    <th>1号栈</th>\n  </tr>\n  <tr>\n    <td>初始时</td>\n    <td>top0 = -1</td>\n    <td>top1 = Maxsize</td>\n  </tr>\n  <tr>\n    <td>栈的第一个元素</td>\n    <td>S.data[0]</td>\n    <td>S.data[Maxsize]</td>\n  </tr>\n  <tr>\n    <td>栈顶指针指向</td>\n    <td>指向栈顶元素</td>\n    <td>指向栈顶元素</td>\n  </tr>\n  <tr>\n    <td>栈满条件</td>\n    <td colspan=\"2\">top1 - top0 == 1</td>\n  </tr>\n  <tr>\n    <td>栈空条件</td>\n    <td>top0 == -1，0号栈空</td>\n    <td>top1 == Maxsize，1号栈空</td>\n  </tr>\n  <tr>\n    <td>进栈操作</td>\n    <td>判栈满，S.data[++top0] = x;</td>\n    <td>判栈满，S.data[--top1] = x;</td>\n  </tr>\n  <tr>\n    <td>出栈操作</td>\n    <td>判栈空，x = S.data[top0--];</td>\n    <td>判栈空，x = S.data[top1++];</td>\n  </tr>\n</table>\n\n<h3 id=\"队列的定义\"><a href=\"#队列的定义\" class=\"headerlink\" title=\"队列的定义\"></a>队列的定义</h3><ul>\n<li><strong>队列（Queue）简称队，</strong>是一种先进先出（First In  First Out, FIFO）的线性表，它只允许在表的一端进行插入，而在另一端删除元素。</li>\n<li>这和我们日常生活中的排队是一致的，最早进入队列的元素最早离开。</li>\n<li><strong>队尾（Front）</strong>——允许插入的一端。</li>\n<li><strong>队头（Rear）</strong>——允许删除的一端。</li>\n<li><strong>空队列</strong>——不含任何元素的空表。</li>\n</ul>\n<h3 id=\"队列的逻辑结构\"><a href=\"#队列的逻辑结构\" class=\"headerlink\" title=\"队列的逻辑结构\"></a>队列的逻辑结构</h3><ul>\n<li>队列是一种操作受限的线性表，只允许在表的一端进行插入，而在另一端删除元素，服从先进先出原则。允许插入的一端叫做队尾，允许删除的一端称为队头，队列为空时无法进行出队操作。</li>\n</ul>\n<h3 id=\"队列的操作特性（考点没写）\"><a href=\"#队列的操作特性（考点没写）\" class=\"headerlink\" title=\"队列的操作特性（考点没写）\"></a>队列的操作特性（考点没写）</h3><ul>\n<li>先进先出（FIFO）</li>\n</ul>\n<h3 id=\"队列的特点\"><a href=\"#队列的特点\" class=\"headerlink\" title=\"队列的特点\"></a>队列的特点</h3><ul>\n<li><strong>先进先出（FIFO）</strong>：最先进入的元素最先被移除。</li>\n<li><strong>操作限制</strong>：只能在队列的尾部入队，头部出队。</li>\n<li><strong>队首元素</strong>：队首是当前可以访问和移除的元素。</li>\n<li><strong>空队列</strong>：队列为空时无法进行出队操作。</li>\n<li><strong>动态大小</strong>：可以根据需要扩展或收缩。</li>\n</ul>\n<h3 id=\"队列的基本操作\"><a href=\"#队列的基本操作\" class=\"headerlink\" title=\"队列的基本操作\"></a>队列的基本操作</h3><ul>\n<li><strong>入队（Push）</strong>：将一个元素添加到队列的尾部。</li>\n<li><strong>出队（Pop）</strong>：从队列的头部移除并返回一个元素。</li>\n<li><strong>取队首元素（Front）</strong>：返回队首的元素，但不删除它。</li>\n<li><strong>取队尾元素（Back）</strong>：返回队尾的元素，但不删除它。</li>\n<li><strong>队列判空（isEmpty）</strong>：判断队列中是否有元素。</li>\n<li><strong>获取队列长度（Size）</strong>：获取队列中有效元素个数。</li>\n</ul>\n<h3 id=\"顺序队列的定义\"><a href=\"#顺序队列的定义\" class=\"headerlink\" title=\"顺序队列的定义\"></a>顺序队列的定义</h3><ul>\n<li><strong>顺序队列：</strong>采用顺序存储的队列，利用一块连续的存储单元存放队列中的元素，并附设两个指针front和rear分别指示队头和队尾元素在顺序队列中的位置。</li>\n</ul>\n<h3 id=\"链式队列的定义\"><a href=\"#链式队列的定义\" class=\"headerlink\" title=\"链式队列的定义\"></a>链式队列的定义</h3><ul>\n<li><strong>链队列</strong>是队列的链式表示，它实际上是一个同时有队头指针和队尾指针的单链表。<strong>头指针</strong>指向队头结点，尾指针指向<strong>队尾结点</strong>。</li>\n</ul>\n<h3 id=\"顺序队列和链式队列的特点\"><a href=\"#顺序队列和链式队列的特点\" class=\"headerlink\" title=\"顺序队列和链式队列的特点\"></a>顺序队列和链式队列的特点</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>特点</th>\n<th>顺序队列</th>\n<th>链式队列</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存储结构</strong></td>\n<td>使用数组实现，连续存储元素</td>\n<td>使用链表实现，非连续存储元素</td>\n</tr>\n<tr>\n<td><strong>固定大小</strong></td>\n<td>队列的大小在创建时固定</td>\n<td>可以根据需要动态扩展</td>\n</tr>\n<tr>\n<td><strong>入队和出队效率</strong></td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><strong>空间浪费</strong></td>\n<td>可能存在未使用的数组空间</td>\n<td>无空间浪费</td>\n</tr>\n<tr>\n<td><strong>队满判断</strong></td>\n<td>需要判定是否队满</td>\n<td>不需要判定队满</td>\n</tr>\n<tr>\n<td><strong>额外开销</strong></td>\n<td>无额外开销</td>\n<td>每个元素需存储指针，空间开销较大</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"顺序队列的基本操作\"><a href=\"#顺序队列的基本操作\" class=\"headerlink\" title=\"顺序队列的基本操作\"></a>顺序队列的基本操作</h3><p>（例如，还有其他变换，比如=1）这四个变换是用来锻炼思维和熟练度的，理清楚就可以举一反三了。</p>\n<table border=\"1\" style=\"border-collapse: collapse; text-align: center; width: 100%; height: 100px;\">\n  <tr>\n    <td style=\"position: relative; width: 24%; height: 80px;\">\n      <div style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to top right, transparent 49%, black 50%, transparent 51%);\"></div>\n      <div style=\"position: absolute; bottom: 0; left: 0; width: 50%; height: 50%; display: flex; justify-content: center; align-items: center; font-size: 14px;\">\n        队头指针front\n      </div>\n      <div style=\"position: absolute; top: 0; right: 0; width: 50%; height: 50%; display: flex; justify-content: center; align-items: center; font-size: 14px;\">\n        队尾指针rear\n      </div>\n    </td>\n    <td style=\"font-size: 14px; width: 38%;\">① 指向队尾元素</td>\n    <td style=\"font-size: 14px; width: 38%;\">② 指向队尾元素的后一个位置</td>\n  </tr>\n  <tr>\n    <td style=\"font-size: 14px;\">① 指向队头元素</td>\n    <td>\n      <table border=\"1\" style=\"border: 2px solid; width: 100%; text-align: left;\">\n        <tr>\n          <td>初始时</td>\n          <td>Q.front=0; Q.rear=-1;</td>\n        </tr>\n        <tr>\n          <td>判空</td>\n          <td>Q.front==Q.rear+1</td>\n        </tr>\n        <tr>\n          <td>判满（若有限制长度为len）</td>\n          <td>Q.rear-Q.front==len-1</td>\n        </tr>\n        <tr>\n          <td>判再入队一个值，是否会“上溢出”</td>\n          <td>Q.rear+1>=Maxsize</td>\n        </tr>\n        <tr>\n          <td>进队</td>\n          <td>判“上溢出”和“满（若有）”，Q.rear++，赋值</td>\n        </tr>\n        <tr>\n          <td>出队</td>\n          <td>判空，取值，Q.front++</td>\n        </tr>\n      </table>\n    </td>\n    <td>\n      <table border=\"1\" style=\"border: 2px solid; width: 100%; text-align: left;\">\n        <tr>\n          <td>初始时</td>\n          <td>Q.front=Q.rear=0</td>\n        </tr>\n        <tr>\n          <td>判空</td>\n          <td>Q.front==Q.rear</td>\n        </tr>\n        <tr>\n          <td>判满（若有限制长度为len）</td>\n          <td>Q.rear-Q.front==len</td>\n        </tr>\n        <tr>\n          <td>判再入队一个值，是否会“上溢出”</td>\n          <td>Q.rear>=Maxsize</td>\n        </tr>\n        <tr>\n          <td>进队</td>\n          <td>判“上溢出”和“满（若有）”，赋值，Q.rear++</td>\n        </tr>\n        <tr>\n          <td>出队</td>\n          <td>判空，取值，Q.front++</td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"font-size: 14px;\">② 指向队头元素的前一个位置</td>\n    <td>\n      <table border=\"1\" style=\"border: 2px solid; width: 100%; text-align: left;\">\n        <tr>\n          <td>初始时</td>\n          <td>Q.front=-1; Q.rear=-1;</td>\n        </tr>\n        <tr>\n          <td>判空</td>\n          <td>Q.front==Q.rear</td>\n        </tr>\n        <tr>\n          <td>判满（若有限制长度为len）</td>\n          <td>Q.rear-Q.front==len</td>\n        </tr>\n        <tr>\n          <td>判再入队一个值，是否会“上溢出”</td>\n          <td>Q.rear+1>=Maxsize</td>\n        </tr>\n        <tr>\n          <td>进队</td>\n          <td>判“上溢出”和“满（若有）”，Q.rear++，赋值</td>\n        </tr>\n        <tr>\n          <td>出队</td>\n          <td>判空，Q.front++，取值</td>\n        </tr>\n      </table>\n    </td>\n    <td>\n      <table border=\"1\" style=\"border: 2px solid; width: 100%; text-align: left;\">\n        <tr>\n          <td>初始时</td>\n          <td>Q.front=-1; Q.rear=0;</td>\n        </tr>\n        <tr>\n          <td>判空</td>\n          <td>Q.front+1==Q.rear</td>\n        </tr>\n        <tr>\n          <td>判满（若有限制长度为len）</td>\n          <td>Q.rear-Q.front-1==len</td>\n        </tr>\n        <tr>\n          <td>判再入队一个值，是否会“上溢出”</td>\n          <td>Q.rear>=Maxsize</td>\n        </tr>\n        <tr>\n          <td>进队</td>\n          <td>判“上溢出”和“满（若有）”，赋值，Q.rear++</td>\n        </tr>\n        <tr>\n          <td>出队</td>\n          <td>判空，Q.front++，取值</td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n\n\n\n<h3 id=\"链队列的基本操作\"><a href=\"#链队列的基本操作\" class=\"headerlink\" title=\"链队列的基本操作\"></a>链队列的基本操作</h3><ul>\n<li>头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点。</li>\n<li><strong>不带头结点时</strong>，当<code>Q.front==NULL &amp;&amp; Q.rear==NULL</code>时，链式队列为空。</li>\n<li>入队时，建立一个新结点，将新结点插入到链表的尾部，并让Q.rear指向这个新插入的结点（若原队列为空队，则令Q.front也指向该结点 <strong>（带头结点时不用操作Q.front，因为它指向头结点）</strong>）。</li>\n<li>出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中摘除，并让Q.front指向下一个结点（若该结点为最后一个结点，则置Q.front和Q.rear都为NULL <strong>（带头结点时只需修改Q.front-&gt;next为下一个结点，Q.front不用动，Q.rear置为指向头结点）</strong>）。</li>\n<li>不难看出，不带头结点的链式队列在操作上往往比较麻烦，因此通常将链式队列设计成一个<strong>带头结点</strong>的单链表，<strong>这样插入和删除操作就统一了</strong>。</li>\n<li>用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。</li>\n<li>另外，假如程序中要使用多个队列，与多个栈的情形一样，最好使用链式队列，这样就不会出现存储分配不合理和“溢出”的问题。</li>\n<li><p>带头结点和不带头结点的操作是不一样的，要注意。</p>\n</li>\n<li><p>单链队列——队列的链式存储结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> &#123;</span></span><br><span class=\"line\">  QElemType data;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;QNode, *QueuePtr;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  QueuePtr front; <span class=\"comment\">//队头指针</span></span><br><span class=\"line\">  QueuePtr rear;</span><br><span class=\"line\">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">InitQueue</span> <span class=\"params\">(LinkQueue &amp;Q)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//构造一个空队列</span></span><br><span class=\"line\">  Q.front = Q.rear = (QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!Q.front) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">  Q.front -&gt; next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>销毁队列Q</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stauts <span class=\"title function_\">DestroyQueue</span> <span class=\"params\">(LinkQueue &amp;Q)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(Q.front) &#123;</span><br><span class=\"line\">    Q.rear = Q.front -&gt; next;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(Q.front);</span><br><span class=\"line\">    Q.front = Q.rear;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>入队——插入元素e为Q的新的队尾元素</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">EnQueue</span> <span class=\"params\">(LinkQueue &amp;Q, ElemType e)</span> &#123;</span><br><span class=\"line\">  p = (QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!p) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">  p -&gt; data = e;</span><br><span class=\"line\">  p -&gt; next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  Q.rear -&gt; next = p;</span><br><span class=\"line\">  Q.rear = p; <span class=\"comment\">//别忘记这句！！！</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>出队——若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">DeQueue</span><span class=\"params\">(LinkQueue &amp;Q, QElemType &amp;e)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(Q.front == Q.rear) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">  p = Q.front -&gt; next;</span><br><span class=\"line\">  e = p -&gt; data;</span><br><span class=\"line\">  Q.front -&gt; next = p -&gt; next;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(Q.rear == p) Q.rear = Q.front;</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"顺序存储结构中实现循环队列的具体要求\"><a href=\"#顺序存储结构中实现循环队列的具体要求\" class=\"headerlink\" title=\"顺序存储结构中实现循环队列的具体要求\"></a>顺序存储结构中实现循环队列的具体要求</h3><ul>\n<li>在顺序队列中，<code>Q.rear==Maxsize</code>并不能作为判断队列满的条件，但在此时如果再插入新的队尾元素，会发生数组越界问题；</li>\n<li>但此时又不宜像顺序栈那样通过 再分配 来扩大数组空间，因为队列的实际可用空间可能并未占满。这便是一种“假溢出”。</li>\n<li>为解决这种“假溢出”问题，引出了<strong>循环队列</strong>的概念。将顺序队列臆造为一个环状的空间，即把存储队列元素的表<strong>从逻辑上</strong>视为一个环，称为<strong>循环队列</strong>。</li>\n<li>当队首指针或队尾指针到达Maxsize-1后，若要再前进一个位置就自动到0，这里可以通过取模(%)的方式实现。</li>\n<li>初始时：Q.front=Q.rear=0</li>\n<li>队首指针进1：Q.front=(Q.front+1)%Maxszie</li>\n<li>队尾指针进1：Q.rear=(Q.rear+1)%Maxsize</li>\n<li>队列长度：(Q.rear+Maxsize-Q.front)%Maxsize</li>\n<li>出队入队时：指针都按顺时针方向进1</li>\n<li><p><strong>为了区分是队空还是堆满的情况，</strong>有3种处理方式：</p>\n<ol>\n<li>牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法，约定以“队头指针在队尾指针的下一个位置作为队满的标志”。<br>队满条件：(Q.rear+1)%Maxsize==Q.front；<br>队空条件：Q.front == Q.rear；<br>队列中元素的个数：(Q.rear-Q.front+Maxsize)%Maxsize。</li>\n<li>类型中增设size数据成员，表示元素个数。删除成功size—，插入成功size++。<br>队空条件：Q.size==0；<br>队满条件：Q.size==Maxsize。<br>两种情况都有Q.front==Q.rear。</li>\n<li>类型中增设tag数据成员，以区分是队满还是队空。<br>删除成功置tag=0，若导致Q.front==Q.rear，则为队空；<br>插入成功置tag=1，若导致Q.front==Q.rear，则为队满。</li>\n</ol>\n</li>\n<li><p>在C语言中不能用动态分配的一维数组来实现循环队列。如果用户的应用程序中设有循环队列，则必须为它设定一个最大队列长度；若用户无法预估所用的队列的最大长度，则宜采用链队列。</p>\n</li>\n<li>这里会有很多变式，考试的时候随机应变，用手模特殊值，然后换成未知量的形式来做题即可。主要是记住队尾rear是入队，队头front是出队。</li>\n</ul>\n<h4 id=\"循环队列——队列的顺序存储结构\"><a href=\"#循环队列——队列的顺序存储结构\" class=\"headerlink\" title=\"循环队列——队列的顺序存储结构\"></a>循环队列——队列的顺序存储结构</h4><ul>\n<li><p>类型声明</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXQSIZE 100 <span class=\"comment\">//最大队列长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  QElemType *base;</span><br><span class=\"line\">  <span class=\"type\">int</span> front;</span><br><span class=\"line\">  <span class=\"type\">int</span> rear;</span><br><span class=\"line\">&#125;SqQueue;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span> &#123;</span><br><span class=\"line\">  Q.base = (QElemType *)alloc(MAXQSIZE*<span class=\"keyword\">sizeof</span>(QElemType));</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!Q.base) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">  Q.front = Q.rear = <span class=\"number\">0</span>; <span class=\"comment\">//合法操作，在C语言中，赋值操作不仅会将值赋给变量，还会返回这个值本身</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回Q的元素个数，即队列的长度</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">QueueLength</span><span class=\"params\">(SqQueue Q)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (Q.rear-Q.front+MAXQSIZE)%MAXSIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>入队</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q, QElemType e)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>((Q.rear+<span class=\"number\">1</span>) % MAXQSIZE == Q.front) <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//队满</span></span><br><span class=\"line\">  Q.base[Q.rear] = e;</span><br><span class=\"line\">  Q.rear = (Q.rear + <span class=\"number\">1</span>) % MAXQSIZE;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>出队</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">DeQueue</span><span class=\"params\">(SqQueue &amp;Q, QElemType &amp;e)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(Q.front == Q.rear) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">  e = Q.base[Q.front];</span><br><span class=\"line\">  Q.front = (Q.front + <span class=\"number\">1</span>) % MAXQSIZE;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"理解递归调用和栈之间的关系\"><a href=\"#理解递归调用和栈之间的关系\" class=\"headerlink\" title=\"理解递归调用和栈之间的关系\"></a>理解递归调用和栈之间的关系</h3><ul>\n<li><strong>什么是递归？</strong><br>在数学及程序设计方法学中，若一个对象部分包含它自己，或者用它自己定义自己，则称这个对象是递归的；若一个过程直接或间接地调用自己，则称这个过程是递归的过程。</li>\n<li><strong>递归</strong>是一种重要的程序设计方法。简单地说，若在一个<u>函数、过程或数据结构</u>的定义中又应用了它自身，则这个<u>函数、过程、数据结构</u>被称为是递归定义的，简称递归。<br>它通常把一个大型的复杂问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的代码就可以描述出解题过程所需要的多次重复计算，<strong>大大减少了程序的代码量</strong>。但在通常情况下，<strong>它的效率并不是太高</strong>。</li>\n<li>一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做<strong>递归函数</strong>。</li>\n<li><p>栈还有一个重要作用是在程序设计语言中实现递归。（可见栈可以用来实现递归）</p>\n</li>\n<li><p>阶乘函数</p>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Fact</mtext><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>n</mi><mo>×</mo><mtext>Fact</mtext><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">\\text{Fact}(n) =\n\\begin{cases}\n1 &amp; \\text{if } n = 0 \\\\\nn \\times \\text{Fact}(n - 1) &amp; \\text{if } n &gt; 0\n\\end{cases}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Fact</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord text\"><span class=\"mord\">Fact</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// 0 的阶乘为 1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>); <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>Fibonacci数列</p>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Fibo</mtext><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>Fibo</mtext><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mtext>Fibo</mtext><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">\\text{Fibo}(n) =\n\\begin{cases}\n0 &amp; \\text{if } n = 0 \\\\\n1 &amp; \\text{if } n = 1 \\\\\n\\text{Fibo}(n - 1) + \\text{Fibo}(n - 2) &amp; \\text{if } n &gt; 1\n\\end{cases}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Fibo</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:4.32em;vertical-align:-1.91em;\"></span><span class=\"minner\"><span class=\"mopen\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.35em;\"><span style=\"top:-2.2em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎩</span></span></span><span style=\"top:-2.192em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span style=\"height:0.316em;width:0.8889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.8889em\" height=\"0.316em\" style=\"width:0.8889em\" viewBox=\"0 0 888.89 316\" preserveAspectRatio=\"xMinYMin\"><path d=\"M384 0 H504 V316 H384z M384 0 H504 V316 H384z\"/></svg></span></span><span style=\"top:-3.15em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎨</span></span></span><span style=\"top:-4.292em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span style=\"height:0.316em;width:0.8889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.8889em\" height=\"0.316em\" style=\"width:0.8889em\" viewBox=\"0 0 888.89 316\" preserveAspectRatio=\"xMinYMin\"><path d=\"M384 0 H504 V316 H384z M384 0 H504 V316 H384z\"/></svg></span></span><span style=\"top:-4.6em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎧</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.85em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.41em;\"><span style=\"top:-4.41em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-2.97em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-1.53em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Fibo</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord text\"><span class=\"mord\">Fibo</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.91em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.41em;\"><span style=\"top:-4.41em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span><span style=\"top:-2.97em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-1.53em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.91em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fibonacci</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// F(0) = 0</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// F(1) = 1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fibonacci(n - <span class=\"number\">1</span>) + fibonacci(n - <span class=\"number\">2</span>); <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Ackerman函数<br>Ackermann 函数的定义通常限制 m 和 n 为非负整数。</p>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Ack</mtext><mo stretchy=\"false\">(</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>m</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>Ack</mtext><mo stretchy=\"false\">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>m</mi><mo>&gt;</mo><mn>0</mn><mtext> and </mtext><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>Ack</mtext><mo stretchy=\"false\">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mtext>Ack</mtext><mo stretchy=\"false\">(</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>if </mtext><mi>m</mi><mo>&gt;</mo><mn>0</mn><mtext> and </mtext><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">\\text{Ack}(m, n) =\n\\begin{cases}\nn + 1 &amp; \\text{if } m = 0 \\\\\n\\text{Ack}(m - 1, 1) &amp; \\text{if } m &gt; 0 \\text{ and } n = 0 \\\\\n\\text{Ack}(m - 1, \\text{Ack}(m, n - 1)) &amp; \\text{if } m &gt; 0 \\text{ and } n &gt; 0\n\\end{cases}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Ack</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:4.32em;vertical-align:-1.91em;\"></span><span class=\"minner\"><span class=\"mopen\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.35em;\"><span style=\"top:-2.2em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎩</span></span></span><span style=\"top:-2.192em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span style=\"height:0.316em;width:0.8889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.8889em\" height=\"0.316em\" style=\"width:0.8889em\" viewBox=\"0 0 888.89 316\" preserveAspectRatio=\"xMinYMin\"><path d=\"M384 0 H504 V316 H384z M384 0 H504 V316 H384z\"/></svg></span></span><span style=\"top:-3.15em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎨</span></span></span><span style=\"top:-4.292em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span style=\"height:0.316em;width:0.8889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.8889em\" height=\"0.316em\" style=\"width:0.8889em\" viewBox=\"0 0 888.89 316\" preserveAspectRatio=\"xMinYMin\"><path d=\"M384 0 H504 V316 H384z M384 0 H504 V316 H384z\"/></svg></span></span><span style=\"top:-4.6em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎧</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.85em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.41em;\"><span style=\"top:-4.41em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-2.97em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Ack</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span><span style=\"top:-1.53em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Ack</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">Ack</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">))</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.91em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.41em;\"><span style=\"top:-4.41em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span><span style=\"top:-2.97em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span><span class=\"mord text\"><span class=\"mord\"> and </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span><span style=\"top:-1.53em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">if </span></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span><span class=\"mord text\"><span class=\"mord\"> and </span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.91em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ackermann</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (m != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            n = <span class=\"number\">1</span>; <span class=\"comment\">// 当 n 为 0 时，设置 n 为 1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 递归调用，使用一个栈来存储 m 和 n 的值</span></span><br><span class=\"line\">            n = ackermann(m, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m--; <span class=\"comment\">// 减小 m 的值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n + <span class=\"number\">1</span>; <span class=\"comment\">// 返回 n + 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归是程序设计中一个强有力的工具<ol>\n<li>很多数学函数是递归定义的，比如以上三种；</li>\n<li>有的数据结构，如<strong>二叉树、广义表</strong>等，由于结构本身固有的递归特性，则它们的操作可递归地描述；</li>\n<li>还有一类问题，虽然问题本身没有明显的递归结构，但用递归求解比迭代求解更简单，如<strong>八皇后问题、Hanoi塔问题</strong>等。</li>\n</ol>\n</li>\n<li><p>八皇后问题<br>八皇后问题是一个经典的回溯算法问题，其目标是在 8×8 的国际象棋棋盘上放置 8 个皇后，使得它们彼此之间不能互相攻击。皇后可以在同一行、同一列或对角线上攻击其他皇后。因此，解决八皇后问题的关键在于找到一种摆放方式，使得任意两个皇后不在同一行、同一列或同一对角线上。</p>\n<p><strong>问题描述：</strong></p>\n<ol>\n<li>将 8 个皇后放置在 8×8 的棋盘上。</li>\n<li>每一行放置一个皇后，最终找到一种摆放方案满足互不攻击的条件。</li>\n</ol>\n<p><strong>算法思路：</strong></p>\n<ol>\n<li>从第 1 行开始，每一行尝试放置一个皇后。</li>\n<li>对于当前行的每一列，检查该位置是否安全（即，不与前面的皇后冲突）。</li>\n<li>如果安全，则将皇后放置在该位置，递归地求解下一行。</li>\n<li>如果不安全或无法为下一行找到合法位置，则回溯到上一步，尝试在该行的下一个位置放置皇后。</li>\n</ol>\n<p><strong>判定位置安全性：</strong></p>\n<ol>\n<li>检查该列是否已有皇后。</li>\n<li>检查主对角线和副对角线上是否已有皇后（即，使用两条对角线数组记录状态）。</li>\n</ol>\n<p><strong>C语言实现</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N 8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> board[N]; <span class=\"comment\">// board[i] 表示第 i 行皇后所在的列索引</span></span><br><span class=\"line\"><span class=\"type\">int</span> solution_count = <span class=\"number\">0</span>; <span class=\"comment\">// 解的计数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断当前位置是否安全</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">isSafe</span><span class=\"params\">(<span class=\"type\">int</span> row, <span class=\"type\">int</span> col)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; row; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查列冲突和对角线冲突</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (board[i] == col || <span class=\"built_in\">abs</span>(board[i] - col) == <span class=\"built_in\">abs</span>(i - row)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归回溯求解八皇后问题</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">solve</span><span class=\"params\">(<span class=\"type\">int</span> row)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (row == N) &#123;</span><br><span class=\"line\">        solution_count++;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Solution %d:\\n&quot;</span>, solution_count);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; N; j++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(board[i] == j ? <span class=\"string\">&quot; Q &quot;</span> : <span class=\"string\">&quot; . &quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; N; col++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isSafe(row, col)) &#123;</span><br><span class=\"line\">            board[row] = col; <span class=\"comment\">// 放置皇后</span></span><br><span class=\"line\">            solve(row + <span class=\"number\">1</span>); <span class=\"comment\">// 递归放置下一行的皇后</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    solve(<span class=\"number\">0</span>); <span class=\"comment\">// 从第 0 行开始</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Total solutions: %d\\n&quot;</span>, solution_count);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>运行结果</strong><br>每种解法都会在棋盘上打印出 Q 表示皇后的位置，. 表示空位。最后输出总共找到的解的数量。</p>\n</li>\n<li><p>Hanoi塔问题<br>汉诺塔问题（Tower of Hanoi）是一个经典的递归问题，起源于一个古老的传说。假设有三根柱子和一组大小不同（最小圆盘编号为1，最大圆盘编号为n）的圆盘，圆盘一开始按从大到小的顺序（下面大，上面小）堆叠在第一根柱子上。目标是将所有圆盘移动到第三根柱子上，并满足以下规则：</p>\n<ol>\n<li>每次只能移动一个圆盘。</li>\n<li>圆盘只能放在柱子上，并且必须保持小圆盘在大圆盘之上。</li>\n</ol>\n<p><strong>问题描述</strong><br>给定 n 个圆盘，设柱子分别为 A、B 和 C，将圆盘从 A 移动到 C，并使用 B 作为辅助柱子。<br><strong>递归思路</strong><br>汉诺塔问题可以用递归解决，通过将问题分解为子问题逐步求解：</p>\n<ol>\n<li>基本情况：当只有一个圆盘时，直接将圆盘从 A 移动到 C。</li>\n<li>递归情况：<br>(1) 先将 n-1 个圆盘从 A 移动到 B（使用 C 作为辅助柱）。<br>(2) 将第 n 个圆盘从 A 移动到 C。<br>(3) 将 n-1 个圆盘从 B 移动到 C（使用 A 作为辅助柱）。<br>每次递归地解决 n-1 个圆盘的子问题，直到所有圆盘都被移动到目标柱上。<br><strong>C语言实现</strong></li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">hanoi</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">char</span> from, <span class=\"type\">char</span> to, <span class=\"type\">char</span> aux)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Move disk 1 from %c to %c\\n&quot;</span>, from, to);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hanoi(n - <span class=\"number\">1</span>, from, aux, to);  <span class=\"comment\">// 将 n-1 个盘子从 from 移到 aux</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Move disk %d from %c to %c\\n&quot;</span>, n, from, to); <span class=\"comment\">// 将第 n 个盘子移到目标柱</span></span><br><span class=\"line\">    hanoi(n - <span class=\"number\">1</span>, aux, to, from);  <span class=\"comment\">// 将 n-1 个盘子从 aux 移到 to</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Enter the number of disks: &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    hanoi(n, <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>输出示例</strong><br>若n=3</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Move disk 1 from A to C</span><br><span class=\"line\">Move disk 2 from A to B</span><br><span class=\"line\">Move disk 1 from C to B</span><br><span class=\"line\">Move disk 3 from A to C</span><br><span class=\"line\">Move disk 1 from B to A</span><br><span class=\"line\">Move disk 2 from B to C</span><br><span class=\"line\">Move disk 1 from A to C</span><br></pre></td></tr></table></figure>\n<p><strong>时间复杂度</strong><br>汉诺塔问题的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(2^n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，因为每次增加一个盘子，操作数会翻倍。因此，汉诺塔问题适合用递归解法，但当 n 很大时计算量会非常大。</p>\n</li>\n<li>利用栈实现递归调用<br>（gpt给出的）<br><strong>递归调用的定义：</strong><br>递归是一种编程技术，其中一个函数直接或间接地调用自身。递归通常由两个部分组成：<strong>基例（终止条件）</strong>和<strong>递归步骤（即函数如何调用自身）</strong>。<br><strong>栈的作用：</strong><br>在计算机中，递归调用会使用调用栈（Call Stack）来管理函数调用。每当一个函数被调用时，系统会将<strong>该函数的状态（包括参数、局部变量、返回地址等）</strong>压入栈中。当函数执行完毕后，状态会从栈中弹出，<strong>并返回到调用该函数的位置</strong>。<br><strong>栈的增长：</strong><br>当递归调用发生时，每次调用都会在栈上增加一个新的帧（Frame）（调用栈中的每一层，它包含了特定函数调用的所有信息，如参数、局部变量、返回地址等）。如果递归深度较大，栈的空间可能会被耗尽，导致栈溢出（Stack Overflow）错误。<br><strong>基例的重要性：</strong><br>基例是防止无限递归的重要机制。如果没有适当的基例，递归会不断调用自身，直到耗尽栈空间。<br><strong>步骤：</strong><ol>\n<li>初始化栈：创建一个栈，用于存储待处理的函数状态（如参数和局部变量）。</li>\n<li>入栈操作：将初始参数（或状态）压入栈中。</li>\n<li>循环处理：使用循环来处理栈中的元素：<br>(1) 从栈中弹出一个状态。<br>(2) 检查是否满足基例（一个或多个不需要再次递归的情况），如果满足，则处理结果（例如返回值）。<br>(3) 如果不满足基例，计算递归步骤，并将新的状态（参数）压入栈中。</li>\n<li>返回结果：继续处理直到栈为空，最终返回结果。<br>（书上的说法↓）<br>为了保证递归函数正确执行，系统需设立一个“递归工作栈”作为整个递归函数运行期间使用的数据存储区。每一层递归所需信息构成一个“工作记录”，其中包括所有的实在参数、所有的局部变量以及上一层的返回地址。每进入一层递归，就从栈顶弹出一个工作记录，则当前执行层的工作记录必是递归工作栈栈顶的工作记录，称这个记录为“活动记录”，并称指示活动记录的栈顶指针为“当前环境指针”。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"掌握栈和队列的经典应用\"><a href=\"#掌握栈和队列的经典应用\" class=\"headerlink\" title=\"掌握栈和队列的经典应用\"></a>掌握栈和队列的经典应用</h3><h4 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h4><ul>\n<li>递归调用↑</li>\n<li>数制转换<br>十进制→八进制：从低位到高位产生八进制数的各个数位，从高位到地位顺序输出。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">conversion</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  InitStack(S);</span><br><span class=\"line\">  <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;N);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(N) &#123;</span><br><span class=\"line\">    Push(S, N % <span class=\"number\">8</span>);</span><br><span class=\"line\">    N = N / <span class=\"number\">8</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!StackEmpty(S)) &#123;</span><br><span class=\"line\">    Pop(S, e);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>括号匹配的检验</li>\n</ul>\n<ol>\n<li>在算法中设置一个栈，每读入一个括号，若是右括号，则要么使置于栈顶的最急迫的期待得以消解，要么是不合法的情况；</li>\n<li>若是左括号，则作为一个新的更急迫的期待压入栈中，自然使原有的在栈中的所有未消解的期待的急迫性都降了一级。</li>\n<li>另外，在算法的开始和结束时，栈都应该是空的。</li>\n</ol>\n<ul>\n<li>行编辑程序<br>一个简单的行编辑程序的功能是：接受用户的从终端输入的程序或数据，并存入用户的数据区。由于用户在终端上进行输入时，不能保证不出差错，因此，若在编辑程序中，“每接受一个字符即存入用户数据区”的做法显然不是最恰当的。<br>较好的做法是，设立一个输入缓冲区，用以接受用户输入的一行字符，然后逐行存入用户数据区。允许用户输入出差错，并在发现有误时可以及时更正。<br>例如，当用户发现刚刚键入的一个字符是错的时，可补进一个退格符“#”，以表示前一个字符无效；如果发现当前键入的行内差错较多或难以补救，则可以键入一个退行符“@”，以表示当前行中的字符均无效。<br>例如，假设从终端接受了这样的两行字符：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whli##ilr#e(s#*s)</span><br><span class=\"line\">  outcha@putchar(*s++);</span><br></pre></td></tr></table></figure>\n<p>则实际有效的是下列两行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(*s)</span><br><span class=\"line\">  putchar(*s++);</span><br></pre></td></tr></table></figure>\n<p>为此，可设这个输入缓冲区为一个栈结构，每当从终端接受了一个字符之后先作如下判别：</p>\n<ol>\n<li>如果它既不是退格符也不是退行符，则将该字符压入栈顶；</li>\n<li>如果是一个退格符，则从栈顶删去一个字符；</li>\n<li>如果它是一个退行符，则将字符栈清为空栈。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LineEdit</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  InitStack(S);</span><br><span class=\"line\">  ch = getchar(); <span class=\"comment\">//从终端接收第一个字符</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(ch!=EOF) &#123; <span class=\"comment\">//EOF为全文结束符</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch!=EOF&amp;&amp;ch!=<span class=\"string\">&#x27;\\n&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span>(ch) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;#&#x27;</span>: Pop(S, c); <span class=\"keyword\">break</span>; <span class=\"comment\">//仅当栈非空时退栈</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;@&#x27;</span>: ClearStack(S); <span class=\"keyword\">break</span>; <span class=\"comment\">//重置S为空栈</span></span><br><span class=\"line\">        <span class=\"keyword\">default</span>: Push(S,ch); <span class=\"keyword\">break</span>; <span class=\"comment\">//有效字符进栈，未考虑栈满情形</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      ch = getchar(); <span class=\"comment\">//从终端接收下一个字符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    将从栈底到栈顶的栈内字符传送至调用过程的数据区;</span><br><span class=\"line\">    ClearStack(S); <span class=\"comment\">//重置S为空栈</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ch != EOF) ch = getchar();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  DestroyStack(S);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>迷宫求解<br>BFS用队列，DFS用栈。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//BFS</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> directions[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">isValid</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">int</span> n, <span class=\"type\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;&gt;&amp; maze, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;&gt;&amp; visited)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &gt;= <span class=\"number\">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class=\"number\">0</span> &amp;&amp; y &lt; m &amp;&amp; maze[x][y] == <span class=\"number\">0</span> &amp;&amp; !visited[x][y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">bfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;&gt;&amp; maze)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = maze.size();</span><br><span class=\"line\">    <span class=\"type\">int</span> m = maze[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;&gt; visited(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(m, <span class=\"literal\">false</span>));</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"built_in\">pair</span>&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Starting point</span></span><br><span class=\"line\">    q.push(&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">    visited[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> steps = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> size = q.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> [x, y] = q.front();</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Check if we reached the end</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x == n - <span class=\"number\">1</span> &amp;&amp; y == m - <span class=\"number\">1</span>) <span class=\"keyword\">return</span> steps;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; dir : directions) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> nx = x + dir[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> ny = y + dir[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isValid(nx, ny, n, m, maze, visited)) &#123;</span><br><span class=\"line\">                    q.push(&#123;nx, ny&#125;);</span><br><span class=\"line\">                    visited[nx][ny] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        steps++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// If there&#x27;s no path to the destination</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//DFS</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> directions[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;&gt;&amp; maze, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;&gt;&amp; visited, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">int</span> n, <span class=\"type\">int</span> m)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If out of bounds or not a path, return false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span> || x &gt;= n || y &lt; <span class=\"number\">0</span> || y &gt;= m || maze[x][y] == <span class=\"number\">1</span> || visited[x][y]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check if reached destination</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == n - <span class=\"number\">1</span> &amp;&amp; y == m - <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    visited[x][y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; dir : directions) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> nx = x + dir[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> ny = y + dir[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dfs(maze, visited, nx, ny, n, m)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// Path found</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// No path found from this cell</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">hasPathDFS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;&gt;&amp; maze)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = maze.size();</span><br><span class=\"line\">    <span class=\"type\">int</span> m = maze[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;&gt; visited(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(m, <span class=\"literal\">false</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(maze, visited, <span class=\"number\">0</span>, <span class=\"number\">0</span>, n, m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//书上写的（用栈）</span></span><br><span class=\"line\"><span class=\"comment\">//看不下去，太乱了</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>表达式求值<br><code>#</code>是表达式的结束符，为了算法简洁，在表达式的最左边也虚设一个<code>#</code>构成整个表达式的一对括号。<br><code>(</code>和<code>)</code>相遇时，表示括号内的运算已经完成，<code>#</code>和<code>#</code>相遇时表示整个表达式求值完毕。<br>两个工作栈，OPTR寄存运算符，OPND寄存操作数或运算结果。<br>对算术表达式<code>3*(7-2)</code>求值</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th><code>OPTR</code> 栈</th>\n<th><code>OPND</code> 栈</th>\n<th>输入字符</th>\n<th>主要操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><code>#</code></td>\n<td></td>\n<td>3*(7-2)#</td>\n<td><code>PUSH(OPND, &#39;3&#39;)</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>#</code></td>\n<td>3</td>\n<td>*(7-2)#</td>\n<td><code>PUSH(OPTR, &#39;*&#39;)</code></td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>#*</code></td>\n<td>3</td>\n<td>(7-2)#</td>\n<td><code>PUSH(OPTR, &#39;(&#39;)</code></td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>#*(</code></td>\n<td>3</td>\n<td>7-2)#</td>\n<td><code>PUSH(OPND, &#39;7&#39;)</code></td>\n</tr>\n<tr>\n<td>5</td>\n<td><code>#*(</code></td>\n<td>3 7</td>\n<td>-2)#</td>\n<td><code>PUSH(OPTR, &#39;-&#39;)</code></td>\n</tr>\n<tr>\n<td>6</td>\n<td><code>#*(-</code></td>\n<td>3 7</td>\n<td>2)#</td>\n<td><code>PUSH(OPND, &#39;2&#39;)</code></td>\n</tr>\n<tr>\n<td>7</td>\n<td><code>#*(-</code></td>\n<td>3 7 2</td>\n<td>)#</td>\n<td><code>OPERATE(&#39;7&#39;, &#39;-&#39;, &#39;2&#39;)</code></td>\n</tr>\n<tr>\n<td>8</td>\n<td><code>#*(</code></td>\n<td>3 5</td>\n<td>)#</td>\n<td><code>POP(OPTR)&#123;消去一对括号&#125;</code></td>\n</tr>\n<tr>\n<td>9</td>\n<td><code>#*</code></td>\n<td>3 5</td>\n<td>#</td>\n<td><code>OPERATE(&#39;3&#39;, &#39;*&#39;, &#39;5&#39;)</code></td>\n</tr>\n<tr>\n<td>10</td>\n<td><code>#</code></td>\n<td>15</td>\n<td>#</td>\n<td><code>RETURN(GETTOP(OPND))</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>前缀、中缀、后缀表达式（书p129）<br>前缀表达式：- + A <em> B - C D / E F<br>中缀表达式：A + B </em> (C - D) - E / F<br>后缀表达式：A B C D - * + E F / -<br>前缀、中缀、后缀表达式分别对应表达式树的先序、中序、后序遍历。中缀表达式的括号是必须的。</li>\n</ul>\n<p><strong>转换中缀表达式为前缀表达式的步骤</strong></p>\n<ol>\n<li>首先构造一个运算符栈（也可放置括号），栈中的运算符（以括号为分界点）按照<strong>越往栈顶优先级不降低</strong>的原则进行排列。</li>\n<li>从右至左扫描中缀表达式，从右边第一个字符开始判断：<ul>\n<li>如果当前字符是数字，则分析到数字串的结尾并将数字串直接输出。</li>\n<li>如果是运算符，则比较优先级：<ul>\n<li>如果当前运算符的<strong>优先级大于等于</strong>栈顶运算符的优先级（当栈顶是括号时，直接入栈），则将运算符直接<strong>入栈</strong>。</li>\n<li>否则，将栈顶运算符出栈并输出，直到当前运算符的优先级大于等于栈顶运算符的优先级（当栈顶是括号时，直接入栈），再将当前运算符入栈。</li>\n</ul>\n</li>\n<li>如果是括号，则根据括号的方向进行处理：<ul>\n<li>如果是右括号，则直接入栈；</li>\n<li>否则，在遇到左括号之前，将所有的运算符全部出栈并输出；遇到右括号后将左右括号一起出栈（但不输出）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>重复步骤 2，直到扫描结束，将栈内剩余运算符全部出栈并输出。最后逆序输出字符串，中缀表达式就转换为前缀表达式了。</li>\n</ol>\n<p><strong>转换示例表格</strong><br>将中缀表达式“1+((2+3)*4)-5”转换为前缀表达式。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>中缀表达式</th>\n<th>前缀表达式</th>\n<th>运算符栈（栈顶）</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5</td>\n<td>5</td>\n<td>空</td>\n<td><code>5</code> 是数字串，直接输出</td>\n</tr>\n<tr>\n<td>-</td>\n<td>5</td>\n<td>-</td>\n<td><code>-</code> 栈内无运算符，直接入栈</td>\n</tr>\n<tr>\n<td>)</td>\n<td>5</td>\n<td>- )</td>\n<td><code>)</code> 直接入栈</td>\n</tr>\n<tr>\n<td>4</td>\n<td>5 4</td>\n<td>- )</td>\n<td><code>4</code> 是数字串，直接输出</td>\n</tr>\n<tr>\n<td>*</td>\n<td>5 4</td>\n<td>- ) *</td>\n<td><code>*</code> 栈顶是括号，直接入栈</td>\n</tr>\n<tr>\n<td>)</td>\n<td>5 4</td>\n<td>- ) * )</td>\n<td><code>)</code> 直接入栈</td>\n</tr>\n<tr>\n<td>3</td>\n<td>5 4 3</td>\n<td>- ) * )</td>\n<td><code>3</code> 是数字串，直接输出</td>\n</tr>\n<tr>\n<td>+</td>\n<td>5 4 3</td>\n<td>- ) * ) +</td>\n<td><code>+</code> 栈顶是括号，直接入栈</td>\n</tr>\n<tr>\n<td>2</td>\n<td>5 4 3 2</td>\n<td>- ) * ) +</td>\n<td><code>2</code> 是数字串，直接输出</td>\n</tr>\n<tr>\n<td>(</td>\n<td>5 4 3 2 +</td>\n<td>- ) *</td>\n<td><code>(</code> 抵消栈中最后一个 <code>)</code> 并释放它们之间的 <code>+</code></td>\n</tr>\n<tr>\n<td>(</td>\n<td>5 4 3 2 + *</td>\n<td>-</td>\n<td><code>(</code> 抵消方法同上</td>\n</tr>\n<tr>\n<td>+</td>\n<td>5 4 3 2 + *</td>\n<td>- +</td>\n<td><code>+</code> 优先级大于等于栈顶运算符，直接入栈</td>\n</tr>\n<tr>\n<td>1</td>\n<td>5 4 3 2 + * 1</td>\n<td>- +</td>\n<td><code>1</code> 是数字串，直接输出</td>\n</tr>\n<tr>\n<td>空</td>\n<td>5 4 3 2 + * 1 + -</td>\n<td>空</td>\n<td>扫描结束，将栈内剩余运算符全部出栈并输出</td>\n</tr>\n<tr>\n<td>空</td>\n<td>- + 1 * + 2 3 4 5</td>\n<td>空</td>\n<td>逆序输出字符串</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>中缀表达式转后缀表达式的步骤</strong></p>\n<ol>\n<li>设定一个运算符栈。</li>\n<li>假设表达式的结束符为 <code>#</code>，并预设运算符栈底元素也为 <code>#</code>。</li>\n<li>扫描表达式，按以下规则处理每个字符：<ul>\n<li>如果当前字符是操作数，则直接添加到后缀表达式中。</li>\n<li>如果当前字符是运算符且优先级<strong>高于</strong>栈顶运算符，则将其入栈；否则，将从栈顶开始，依次<strong>弹出</strong>栈中<strong>优先级高于或等于</strong>当前运算符的所有运算符，并加入后缀表达式，然后将当前运算符入栈。</li>\n<li>如果当前字符是结束符 <code>#</code>，则依次将栈中剩余的运算符出栈并添加到后缀表达式。</li>\n<li>如果当前字符是左括号 <code>(</code>，则直接入栈。</li>\n<li>如果当前字符是右括号 <code>)</code>，则从栈顶开始，依次将运算符出栈并添加到后缀表达式，直到遇到左括号 <code>(</code>。将 <code>(</code> 出栈，但不添加到后缀表达式中，然后继续扫描表达式。</li>\n</ul>\n</li>\n</ol>\n<p>（详见gpt和王道p93，书上没看到有写,2018真题有考小题目）</p>\n<h4 id=\"队列的应用\"><a href=\"#队列的应用\" class=\"headerlink\" title=\"队列的应用\"></a>队列的应用</h4><ul>\n<li>离散事件模拟<br>书p65。讲的是模拟银行业务，不同的客户在随机时间到达，如果前边有其他客户还在办理业务则需要等待。计算客户的平均逗留时间。<br>每个窗口都被设置成一个<strong>队列</strong>，客户到达银行时排队排在人数最少的那个队伍后边。总之就是用到了<strong>队列</strong>。</li>\n<li>队列在层次遍历（BFS）中需要用到。</li>\n<li>数据缓冲区</li>\n<li><p>CPU（即中央处理器，它包括运算器和控制器）资源的竞争。在一个带有多终端的计算机系统上，有多个用户需要CPU各自运行自己的程序，它们分别通过各自的终端向操作系统提出占用CPU的请求。操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个<strong>队列</strong>，每次把CPU分配给队首请求的用户使用。当相应的程序运行结束或用完规定的时间间隔后，令其出队，再把CPU分配给新的队首请求的用户使用。这样既满足每个用户的请求，又使CPU能够正常运行。</p>\n</li>\n<li><p>（看一下书p49、p65，王道里也有内容别忘记）</p>\n</li>\n</ul>\n<h2 id=\"五、二叉树、树和森林\"><a href=\"#五、二叉树、树和森林\" class=\"headerlink\" title=\"五、二叉树、树和森林\"></a>五、二叉树、树和森林</h2><h3 id=\"二叉树、树、森林的定义以及它们之间的异同点\"><a href=\"#二叉树、树、森林的定义以及它们之间的异同点\" class=\"headerlink\" title=\"二叉树、树、森林的定义以及它们之间的异同点\"></a>二叉树、树、森林的定义以及它们之间的异同点</h3><h4 id=\"二叉树的定义\"><a href=\"#二叉树的定义\" class=\"headerlink\" title=\"二叉树的定义\"></a>二叉树的定义</h4><ul>\n<li><strong>二叉树</strong>是一种树型结构，它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。</li>\n</ul>\n<ol>\n<li>二叉树可以为<strong>空</strong>，或由一个根节点和两个互不相交的分别被称为左子树和右子树的二叉树组成。</li>\n<li>二叉树是有序树。<br>(1) 若将其左、右子树颠倒，则成为另一棵不同的二叉树。<br>(2) 即使树中结点只有一棵子树，也要区分它是左子树还是右子树。</li>\n<li>二叉树与度为2的有序树的区别：<br>(1) 度为2的树至少有3个结点（因为至少要有一个结点的度为2）。<br>(2) 度为2的有序树，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序；而二叉树不管孩子是否是2个，都区分次序。</li>\n<li>非空二叉树上的<strong>叶结点数</strong>等于<strong>度为2的结点数</strong>加<strong>1</strong>，即n0=n2+1。<blockquote>\n<p><strong>证明：</strong> ①结点总数n=n0+n1+n2 ②除根节点外，其余结点都有一个<strong>分支进入</strong>，n=B（分支总数）+1 ③这些分支是由度为1或2的结点<strong>射出</strong>的，B=n1+2n2 ④n0+n1+n2=n1+2n2+1，则n0=n2+1。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li><strong>度为m的树和m叉树的区别</strong><br>度为m的树：至少有一个节点的度为m。<br>m叉树：允许所有节点的度&lt;m，可以是空树。</li>\n</ul>\n<table>\n  <tr>\n    <th style=\"text-align: center;\"></th>\n    <th style=\"text-align: center;\">度为 m</th>\n    <th style=\"text-align: center;\">m 叉树</th>\n  </tr>\n  <tr>\n    <td style=\"text-align: center;\">结点数与度数</td>\n    <td colspan=\"2\" style=\"text-align: center;\">结点数 = 度数 + 1</td>\n  </tr>\n  <tr>\n    <td style=\"text-align: center;\">第 i 层上结点数</td>\n    <td colspan=\"2\" style=\"text-align: center;\">第 i 层上最多有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">m^{i-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点（<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i \\geq 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7955em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>）</td>\n  </tr>\n  <tr>\n    <td style=\"text-align: center;\">高度为 h，总结点数</td>\n    <td colspan=\"2\" style=\"text-align: center;\">至多有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{m^h - 1}{m - 1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.4463em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0429em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.927em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 个结点</td>\n  </tr>\n  <tr>\n    <td style=\"text-align: center;\"><b>高度为 h，总结点数</b></td>\n    <td style=\"text-align: center;\"><b>至少有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">h + m - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 个结点</b></td>\n    <td style=\"text-align: center;\"><b>至少有 h 个结点</b></td>\n  </tr>\n  <tr>\n    <td style=\"text-align: center;\">有 n 个结点，</td>\n    <td colspan=\"2\" style=\"text-align: center;\">最小高度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>m</mi></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil \\log_m(n(m - 1) + 1) \\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mop\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0573em;\"><span style=\"top:-2.4559em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2441em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)⌉</span></span></span></span>，根据<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≤</mo><mfrac><mrow><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">n \\leq \\frac{m^h - 1}{m - 1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.4463em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0429em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.927em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>得出</td>\n  </tr>\n  <tr>\n    <td style=\"text-align: center;\"><b>有 n 个结点，</b></td>\n    <td style=\"text-align: center;\"><b>最大高度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n - m + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></b></td>\n    <td style=\"text-align: center;\"><b>最大高度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></b></td>\n  </tr>\n</table>\n\n<ul>\n<li><strong>满二叉树</strong><br>一棵高度为h，且有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^h-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9324em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>个结点的二叉树称为<strong>满二叉树</strong>，即二叉树中的每层都含有最多的结点。<br>（与树相似，二叉树也以递归的形式定义）</li>\n</ul>\n<ol>\n<li><strong>叶结点</strong>都集中在二叉树的<strong>最下一层</strong></li>\n<li>除叶结点外的每个结点<strong>度数均为2</strong>。</li>\n<li>可以按照层次对满二叉树进行编号，自上而下，自左向右。对于编号为<code>i</code>的结点，<ul>\n<li>若有双亲（<code>i&gt;1</code>），则其<strong>双亲</strong>为<code>⌊i/2⌋</code></li>\n<li>若有左孩子，则其<strong>左孩子</strong>为<code>2i</code></li>\n<li>若有有孩子，则其<strong>右孩子</strong>为<code>2i+1</code></li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/articles/9eb01842/满二叉树.jpg\" /></p>\n<ul>\n<li><strong>完全二叉树</strong><br>高度为h，有n个结点的二叉树，<strong>当且仅当</strong>其每个结点都与高度为h的<strong>满二叉树</strong>中编号为1～n的结点<strong>一一对应</strong>时，称为<strong>完全二叉树</strong>。</li>\n</ul>\n<ol>\n<li>若<code>i≤⌊n/2⌋</code>，则结点<code>i</code>为<strong>分支节点</strong>，<u>否则为叶结点</u>。</li>\n<li><strong>叶结点</strong>只可能在<strong>层次最大的两层上</strong>出现。对于<strong>最大层次</strong>中的叶结点，都依次排列在该层<strong>最左边</strong>的位置上。</li>\n<li>若有<strong>度为1的结点</strong>，则<strong>最多只可能有一个</strong>，且该结点<strong>只有左孩子</strong>而无右孩子。</li>\n<li><strong>按层次编号后</strong>，一旦出现某结点（编号为i）<strong>为叶结点或只有左孩子</strong>，则<strong>编号大于i</strong>的结点均为<strong>叶结点</strong>。</li>\n<li>若<strong>n为奇数</strong>，则<strong>每个分支节点都有左孩子和右孩子</strong>；若<strong>n为偶数</strong>，则编号最大的分支节点（编号为<strong>n/2</strong>）<strong>只有左孩子</strong>，没有右孩子，其余分支节点左、右孩子都有。</li>\n<li>（和满二叉树一样）对于编号为<code>i</code>的结点，<ul>\n<li>若有双亲（<code>i&gt;1</code>），则其<strong>双亲</strong>为<code>⌊i/2⌋</code></li>\n<li>若有左孩子，则其<strong>左孩子</strong>为<code>2i</code></li>\n<li>若有有孩子，则其<strong>右孩子</strong>为<code>2i+1</code></li>\n</ul>\n</li>\n<li>结点<code>i</code>所在层次（深度）为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil log_2(i+1) \\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)⌉</span></span></span></span>或<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>i</mi><mo stretchy=\"false\">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\lfloor log_2 i \\rfloor + 1 </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">⌋</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>（情况与8一致，证明见下）</li>\n<li>有n(n&gt;0)个结点的完全二叉树的高度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil log_2(n+1) \\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)⌉</span></span></span></span>或<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\lfloor log_2 n \\rfloor + 1 </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">⌋</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。<blockquote>\n<p><strong>证明：</strong>①<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>&lt;</mo><mi>n</mi><mo>≤</mo><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn><mtext>或者</mtext><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≤</mo><mi>n</mi><mo>&lt;</mo><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^{h-1}-1 &lt; n \\leq 2^h-1 或者 2^{h-1} \\leq n &lt; 2^h </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9324em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">h</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9324em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9851em;vertical-align:-0.136em;\"></span><span class=\"mord\">1</span><span class=\"mord cjk_fallback\">或者</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">h</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span></span></span></span> ②得<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>≤</mo><msup><mn>2</mn><mi>h</mi></msup><mo separator=\"true\">,</mo><mtext>  </mtext><mi>h</mi><mo>−</mo><mn>1</mn><mo>&lt;</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>≤</mo><mi>h</mi><mtext>  </mtext><mtext>或者得</mtext><mtext>  </mtext><mi>h</mi><mo>−</mo><mn>1</mn><mo>≤</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>&lt;</mo><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">2^{h-1} &lt; n+1 \\leq 2^h, \\; h-1 &lt; log_2 (n+1) \\leq h \\; 或者得 \\; h-1 \\leq log_2 n &lt; h </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8882em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">h</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0435em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord cjk_fallback\">或者得</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span> ③∴ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mo>=</mo><mo stretchy=\"false\">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">⌉</mo><mtext>或者</mtext><mi>h</mi><mo>=</mo><mo stretchy=\"false\">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">h=\\lceil log_2(n+1) \\rceil 或者 h=\\lfloor log_2 n \\rfloor +1 </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)⌉</span><span class=\"mord cjk_fallback\">或者</span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">⌋</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"/articles/9eb01842/完全二叉树.jpg\" /></p>\n<ul>\n<li><p><strong>二叉排序树</strong><br>左子树上所有结点的关键字均小于根节点的关键字；右子树上所有结点的关键字均大于根节点的关键字；左子树和右子树又各是一棵二叉排序树。</p>\n</li>\n<li><p><strong>平衡二叉树</strong><br>树中任意一个结点的左子树和右子树的高度之差的绝对值不超过1。</p>\n</li>\n<li><p><strong>正则二叉树</strong><br>树中每个分支结点都有2个孩子，即<strong>树中只有度为0或2的结点</strong>。</p>\n</li>\n</ul>\n<h4 id=\"树的定义\"><a href=\"#树的定义\" class=\"headerlink\" title=\"树的定义\"></a>树的定义</h4><ul>\n<li>树是n(n≥0)个结点的有限集。当n=0时，称为<strong>空树</strong>。</li>\n<li>在任意一个非空树中应满足：<ol>\n<li>有且仅有一个特定的称为<strong>根</strong>的结点。</li>\n<li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">T_1,T_2,\\cdots,T_m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，其中每个集合本身又是一棵树，并且称为根的<strong>子树</strong>。</li>\n</ol>\n</li>\n<li>显然，树的定义是递归的（二叉树也是），即<strong>在树的定义中又用到了其自身</strong>，树是一种递归的数据结构。树作为一种<strong>逻辑结构</strong>，同时也是一种<strong>分层结构</strong>，具有以下两个特点：<ol>\n<li>树的根节点没有前驱，除根节点外的所有结点有且只有一个前驱。</li>\n<li>树中所有结点都可以有零个或多个后继。</li>\n</ol>\n</li>\n<li><p>树适用于表示<strong>具有层次结构的数据</strong>。树中的某个结点（除根节点外）<strong>最多</strong>只和上一层的一个结点（即其父结点）有<strong>直接关系</strong>，根节点没有直接上层结点，因此在n个结点的树中有n-1条边。而树中每个结点与其下一层的0个或多个结点（即其孩子结点）都有直接关系。</p>\n</li>\n<li><p><strong>基本术语</strong></p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        A</span><br><span class=\"line\">      / | \\</span><br><span class=\"line\">    B   C   D</span><br><span class=\"line\">   / \\  |  /|\\</span><br><span class=\"line\">  E   F G H I J</span><br><span class=\"line\"> / \\      |</span><br><span class=\"line\">K   L     M</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p><strong>祖先：</strong>考虑结点K，从根A到结点K的唯一路径上的所有其他结点，称为结点K的祖先。</p>\n<blockquote>\n<p><strong>注：</strong>双亲也算祖先！！！</p>\n</blockquote>\n</li>\n<li><p><strong>子孙：</strong>如果结点B是结点K的祖先，则K是B的子孙。</p>\n<blockquote>\n<p><strong>注：</strong>孩子也算子孙！！！</p>\n</blockquote>\n</li>\n<li><p><strong>双亲结点：</strong>路径上最接近K的结点E称为K的双亲。根A是树中唯一没有双亲的结点。</p>\n</li>\n<li><strong>孩子结点：</strong>而K为E的孩子。</li>\n<li><strong>兄弟结点：</strong>有相同双亲的结点称为兄弟，K和L为兄弟。</li>\n<li><strong>堂兄弟结点：</strong><u>双亲在同一层的结点互为堂兄弟。</u><blockquote>\n<p><strong>注意：</strong>G与E，F，H，I，J互为堂兄弟！！！！！</p>\n</blockquote>\n</li>\n<li><strong>结点的度：</strong>树中一个结点的孩子个数称为该结点的度。</li>\n<li><strong>树的度：</strong>树中结点的<strong>最大度数（要存在以这个数为度的结点）</strong>称为树的度。</li>\n<li><strong>分支结点：</strong>度大于0的结点称为分支结点（又称<strong>非终端结点</strong>）。每个结点的分支数就是该结点的度。</li>\n<li><strong>叶结点：</strong>度为0（没有孩子结点）的结点称为叶结点（又称<strong>终端结点</strong>）。</li>\n<li><strong>结点的层次：</strong>从树根开始定义，根节点为第1层，它的孩子为第2层，以此类推。（↓）</li>\n<li><strong>结点的深度：</strong>就是结点所在的层次。（↓）</li>\n<li><strong>结点的高度：</strong>是<strong>以该结点为根的子树</strong>的高度。（↑）<blockquote>\n<p>结点的层次＝深度≠高度；树的最大层次＝深度＝高度。 王道P129，书P120</p>\n</blockquote>\n</li>\n<li><strong>有序树和无序树：</strong>树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，否则称为无序树。若将有序树的子结点位置互换，则变成一棵不同的树。</li>\n<li><strong>路径：</strong>树中<strong>两个结点之间的路径</strong>是由这两个结点之间所经过的<strong>结点序列</strong>构成的。</li>\n<li><strong>路径长度：</strong>是路径上所经过的<strong>边</strong>的个数。</li>\n</ol>\n<ul>\n<li><strong>树的性质</strong></li>\n</ul>\n<ol>\n<li>树的结点数n等于所有结点的度数之和加1。树中所有结点的度数之和等于树中的边数之和。<br><a href=\"./9eb01842.html#二叉树的定义\">（其他在二叉树的“度为m的树和m叉树的区别”表格里有）</a></li>\n</ol>\n<h4 id=\"森林的定义\"><a href=\"#森林的定义\" class=\"headerlink\" title=\"森林的定义\"></a>森林的定义</h4><ul>\n<li>森林是m(m≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以森林和树相互递归的定义来描述树。</li>\n</ul>\n<h4 id=\"二叉树、树、森林的异同点\"><a href=\"#二叉树、树、森林的异同点\" class=\"headerlink\" title=\"二叉树、树、森林的异同点\"></a>二叉树、树、森林的异同点</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>树</th>\n<th>二叉树</th>\n<th>森林</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>根节点</td>\n<td>有且仅有一个根节点</td>\n<td>有且仅有一个根节点</td>\n<td>每棵树有一个根节点</td>\n</tr>\n<tr>\n<td>子节点数</td>\n<td>不限</td>\n<td>每个节点最多两个子节点</td>\n<td>每棵树的节点数不限</td>\n</tr>\n<tr>\n<td>节点顺序</td>\n<td>没有严格顺序</td>\n<td>子节点有左右之分</td>\n<td>各棵树和节点无顺序</td>\n</tr>\n<tr>\n<td>连通性</td>\n<td>必须连通</td>\n<td>必须连通</td>\n<td>每棵树是连通的</td>\n</tr>\n<tr>\n<td>结构关系</td>\n<td>是一种特殊的无向无环图</td>\n<td>是树的一种特殊类型</td>\n<td>是多个树的集合</td>\n</tr>\n<tr>\n<td>应用</td>\n<td>文件系统、家谱等</td>\n<td>表达式树、二叉搜索树等</td>\n<td>多棵树的集合作为林</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"二叉树的实现（包括）\"><a href=\"#二叉树的实现（包括）\" class=\"headerlink\" title=\"二叉树的实现（包括）\"></a>二叉树的实现（包括）</h3><blockquote>\n<p>理解二叉树采用顺序存储结构和链式存储结构的差异性</p>\n</blockquote>\n<h4 id=\"顺序存储结构\"><a href=\"#顺序存储结构\" class=\"headerlink\" title=\"顺序存储结构\"></a>顺序存储结构</h4><ul>\n<li>二叉树的顺序存储是指用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为<code>i</code>的结点元素存储在一维数组下标为<code>i-1</code>的分量中。（书上讲的就是<code>i-1</code>哦）</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     1</span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  2     3</span><br><span class=\"line\">   \\     \\</span><br><span class=\"line\">    4     5</span><br><span class=\"line\">   /</span><br><span class=\"line\">  6</span><br><span class=\"line\"></span><br><span class=\"line\">1 2 3 0 4 0 5 0 0 6</span><br></pre></td></tr></table></figure>\n<ul>\n<li>会导致很多空间被浪费。在最坏的情况下，一个深度为k且只有k个结点的单支树（树中不存在度为2的结点）需要长度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^k-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9324em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>的一维数组。因此顺序存储结构仅适用于完全二叉树。</li>\n</ul>\n<h4 id=\"链式存储结构\"><a href=\"#链式存储结构\" class=\"headerlink\" title=\"链式存储结构\"></a>链式存储结构</h4><ul>\n<li>由于顺序存储的空间利用率低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉树中的每个结点。</li>\n<li>链表的头指针指向二叉树的根节点。</li>\n<li><p><strong>二叉链表</strong><br>由二叉树的定义得知，二叉树的结点由一个数据元素和分别指向其左、右子树的两个分支构成，则表示二叉树的链表中的结点至少包含3个域：数据域和左、右指针域。</p>\n<table>\n  <tr>\n    <td style=\"border: 1px solid; text-align: center;\">lchild</td>\n    <td style=\"border: 1px solid; text-align: center;\">data</td>\n    <td style=\"border: 1px solid; text-align: center;\">rchild</td>\n  </tr>\n</table>\n\n<p><strong>注意：容易证得，在含有n个结点的二叉链表中有n+1个空链域。</strong></p>\n</li>\n<li><p><strong>三叉链表</strong><br>有时，为了便于找到结点的双亲，则还可以在结点结构中增加一个指向其双亲结点的指针域。 </p>\n<table>\n  <tr>\n    <td style=\"border: 1px solid; text-align: center;\">lchild</td>\n    <td style=\"border: 1px solid; text-align: center;\">data</td>\n    <td style=\"border: 1px solid; text-align: center;\">parent</td>\n    <td style=\"border: 1px solid; text-align: center;\">rchild</td>\n  </tr>\n</table>\n</li>\n<li><p><strong>如果要找结点x的双亲结点，在三叉链表很容易实现，而在二叉链表中则需从根指针出发巡查。</strong></p>\n</li>\n</ul>\n<h3 id=\"二叉树的遍历（四种）\"><a href=\"#二叉树的遍历（四种）\" class=\"headerlink\" title=\"二叉树的遍历（四种）\"></a>二叉树的遍历（四种）</h3><blockquote>\n<p>掌握二叉树的四种遍历，并具有能够依赖遍历完成对二叉树进行操作的能力<br>书p128<br><a href=\"https://cloud.tencent.com/developer/article/1511790\">二叉树—层序、前序中序后序(递归、非递归)遍历详解</a>这篇博客光是先序遍历的非递归算法就包含了两种，不错，可以看一下</p>\n</blockquote>\n<ul>\n<li>遍历二叉树是以一定规则将二叉树中结点排列成一个线性序列，得到二叉树中结点的先序序列或中序序列或后序序列。这实质上是对一个非线性结构进行线性化操作，使每个结点（除第一个结点和最后一个外）在这些线性序列中有且仅有一个直接前驱和直接后继。</li>\n</ul>\n<p>L-&gt;遍历左子树；D-&gt;访问根节点；R-&gt;遍历右子树。<br>则可有DLR、LDR、LRD、DRL、RDL、RLD这6种方案。<br>若限定先左后右，则只有前3种情况。<br>基于二叉树的递归定义，可得下述遍历二叉树的递归定义。</p>\n<h4 id=\"先序遍历\"><a href=\"#先序遍历\" class=\"headerlink\" title=\"先序遍历\"></a>先序遍历</h4><p>先序遍历二叉树的操作定义为：<br>若二叉树为空，则空操作；否则</p>\n<ol>\n<li>访问根节点；</li>\n<li>先序遍历左子树；</li>\n<li>先序遍历右子树。</li>\n</ol>\n<p><strong>递归算法</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">preorder</span><span class=\"params\">(BiTree T)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (T!=<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(T);                  <span class=\"comment\">// 访问根节点</span></span><br><span class=\"line\">    <span class=\"built_in\">preorder</span>(T-&gt;lchild);      <span class=\"comment\">// 递归遍历左子树</span></span><br><span class=\"line\">    <span class=\"built_in\">preorder</span>(T-&gt;rchild);     <span class=\"comment\">// 递归遍历右子树</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>非递归算法</strong><br>第一种，<code>这个节点，再右节点进栈，左节点进栈</code><br><img src=\"/articles/9eb01842/先序遍历非递归法一.jpeg\" width=100% height=70% /></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">preorderIterative</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    stack&lt;TreeNode*&gt; s;</span><br><span class=\"line\">    s.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        TreeNode* node = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        cout &lt;&lt; node-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;      <span class=\"comment\">// 访问根节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;right) s.<span class=\"built_in\">push</span>(node-&gt;right);   <span class=\"comment\">// 先将右子节点压栈</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;left) s.<span class=\"built_in\">push</span>(node-&gt;left);     <span class=\"comment\">// 再将左子节点压栈</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二种，传统（王道p148）。遍历左子结点的链，直到没有左子结点，然后回溯处理右子结点。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">preorderIterativeAlt</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    stack&lt;TreeNode*&gt; s;</span><br><span class=\"line\">    TreeNode* current = root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span> || !s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; current-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;   <span class=\"comment\">// 访问当前节点</span></span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(current);               <span class=\"comment\">// 当前节点入栈</span></span><br><span class=\"line\">            current = current-&gt;left;       <span class=\"comment\">// 向左子树移动</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        current = current-&gt;right;          <span class=\"comment\">// 处理右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p>中序遍历二叉树的操作定义为：<br>若二叉树为空，则空操作；否则</p>\n<ol>\n<li>中序遍历左子树；</li>\n<li>访问根节点；</li>\n<li>中序遍历右子树。</li>\n</ol>\n<p><strong>递归算法</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inorderRecursive</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">inorderRecursive</span>(root-&gt;left);       <span class=\"comment\">// 递归遍历左子树</span></span><br><span class=\"line\">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;           <span class=\"comment\">// 访问根节点</span></span><br><span class=\"line\">    <span class=\"built_in\">inorderRecursive</span>(root-&gt;right);      <span class=\"comment\">// 递归遍历右子树</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>非递归算法</strong><br>第一种，类似于先序遍历的第一种，只不过引入了标记。（已经用很多特殊的二叉树例子运行完整代码来验证过了，且手模了一下，没发现什么问题）<br>每次取出栈顶结点：</p>\n<ul>\n<li><strong>如果节点未被标记</strong>，意味着我们还没有访问它。因此：<ul>\n<li>按照<strong>中序遍历的顺序</strong>，需要先遍历左子树，再访问根节点，最后遍历右子树。</li>\n<li>为此，我们首先将<strong>右子结点</strong>入栈（如果存在），然后将<strong>当前结点重新入栈并标记为已访问</strong>，最后将<strong>左子结点</strong>入栈（如果存在）。</li>\n</ul>\n</li>\n<li><strong>如果节点已被标记</strong>，意味着这是第二次从栈中取出它。此时，我们可以访问该节点，因为它的左子树已经处理过了。、<br>这样处理的效果就是，在中序遍历的顺序上保证了左子树→根节点→右子树的顺序。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">StackNode</span> &#123;</span><br><span class=\"line\">    TreeNode* node;</span><br><span class=\"line\">    <span class=\"type\">bool</span> visited;  <span class=\"comment\">// true 表示该节点的左子树已访问</span></span><br><span class=\"line\">    <span class=\"built_in\">StackNode</span>(TreeNode* n, <span class=\"type\">bool</span> v) : <span class=\"built_in\">node</span>(n), <span class=\"built_in\">visited</span>(v) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inorderIterativeWithMark</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    stack&lt;StackNode&gt; s;</span><br><span class=\"line\">    s.<span class=\"built_in\">push</span>(<span class=\"built_in\">StackNode</span>(root, <span class=\"literal\">false</span>));  <span class=\"comment\">// 初始根节点未访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        StackNode current = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.visited) &#123;</span><br><span class=\"line\">            cout &lt;&lt; current.node-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>; <span class=\"comment\">// 访问已标记的当前节点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将节点标记为已访问并重新压入栈中</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (current.node-&gt;right) s.<span class=\"built_in\">push</span>(<span class=\"built_in\">StackNode</span>(current.node-&gt;right, <span class=\"literal\">false</span>)); <span class=\"comment\">// 右子节点</span></span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(<span class=\"built_in\">StackNode</span>(current.node, <span class=\"literal\">true</span>));  <span class=\"comment\">// 标记当前节点为已访问（表示左子树已访问）</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (current.node-&gt;left) s.<span class=\"built_in\">push</span>(<span class=\"built_in\">StackNode</span>(current.node-&gt;left, <span class=\"literal\">false</span>));   <span class=\"comment\">// 左子节点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二种，（传统，王道p148），类似于先序遍历的第二种<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inorderIterative</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    stack&lt;TreeNode*&gt; s;</span><br><span class=\"line\">    TreeNode* current = root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span> || !s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(current);</span><br><span class=\"line\">            current = current-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        cout &lt;&lt; current-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;    <span class=\"comment\">// 访问根节点</span></span><br><span class=\"line\">        current = current-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><p>后序遍历二叉树的操作定义为：<br>若二叉树为空，则空操作；否则</p>\n<ol>\n<li>后序遍历左子树；</li>\n<li>后序遍历右子树；</li>\n<li>访问根节点。</li>\n</ol>\n<p><strong>递归算法</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">postorderRecursive</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">postorderRecursive</span>(root-&gt;left);     <span class=\"comment\">// 递归遍历左子树</span></span><br><span class=\"line\">    <span class=\"built_in\">postorderRecursive</span>(root-&gt;right);    <span class=\"comment\">// 递归遍历右子树</span></span><br><span class=\"line\">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;           <span class=\"comment\">// 访问根节点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>非递归算法</strong><br>第一种（双栈）<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">postorderIterative</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    stack&lt;TreeNode*&gt; s1, s2;</span><br><span class=\"line\">    s1.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!s1.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        TreeNode* node = s1.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        s1.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        s2.<span class=\"built_in\">push</span>(node);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;left) s1.<span class=\"built_in\">push</span>(node-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;right) s1.<span class=\"built_in\">push</span>(node-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!s2.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; s2.<span class=\"built_in\">top</span>()-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        s2.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二种，（传统，王道p167-168，03题）<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">postorderIterative</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    stack&lt;TreeNode*&gt; s;</span><br><span class=\"line\">    TreeNode* prev = <span class=\"literal\">nullptr</span>;  <span class=\"comment\">// 记录上一个访问的节点</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!s.<span class=\"built_in\">empty</span>() || root != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(root);  <span class=\"comment\">// 将当前节点压入栈中</span></span><br><span class=\"line\">            root = root-&gt;left;  <span class=\"comment\">// 继续向左子树深入</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            TreeNode* node = s.<span class=\"built_in\">top</span>();  <span class=\"comment\">// 获取栈顶节点</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果当前节点的右子树未被访问过，先访问右子树</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node-&gt;right != <span class=\"literal\">nullptr</span> &amp;&amp; node-&gt;right != prev) &#123;</span><br><span class=\"line\">                root = node-&gt;right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cout &lt;&lt; node-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;  <span class=\"comment\">// 后序遍历的访问节点</span></span><br><span class=\"line\">                prev = node;  <span class=\"comment\">// 标记当前节点为已访问</span></span><br><span class=\"line\">                s.<span class=\"built_in\">pop</span>();  <span class=\"comment\">// 弹出栈顶节点</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为什么需要标记？<br>答：如果栈顶节点的右子树已经访问过，说明当前节点已经是后序遍历顺序中的最后一个步骤（即根节点），我们可以访问这个节点并将其从栈中弹出。</p>\n<h4 id=\"层次遍历\"><a href=\"#层次遍历\" class=\"headerlink\" title=\"层次遍历\"></a>层次遍历</h4><p>利用队列，BFS<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">levelOrder</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        TreeNode* node = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        cout &lt;&lt; node-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;       <span class=\"comment\">// 访问节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;left) q.<span class=\"built_in\">push</span>(node-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;right) q.<span class=\"built_in\">push</span>(node-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"二叉树的遍历和表达式的关系\"><a href=\"#二叉树的遍历和表达式的关系\" class=\"headerlink\" title=\"二叉树的遍历和表达式的关系\"></a>二叉树的遍历和表达式的关系</h4><p>书p129<br>前缀表达式（波兰式）对应先序遍历<br>中缀表达式对应中序遍历<br>后缀表达式（逆波兰式）对应后序遍历</p>\n<h4 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h4><table>\n  <tr>\n    <td style=\"border: 1px solid; text-align: center;\">lchild</td>\n    <td style=\"border: 1px solid; text-align: center;\">LTag</td>\n    <td style=\"border: 1px solid; text-align: center;\">data</td>\n    <td style=\"border: 1px solid; text-align: center;\">RTag</td>\n    <td style=\"border: 1px solid; text-align: center;\">rchild</td>\n  </tr>\n</table>\n\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi>T</mi><mi>a</mi><mi>g</mi><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>l</mi><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mtext> 指示结点的左孩子</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>l</mi><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mtext> 指示结点的前驱</mtext></mrow></mstyle></mtd></mtr></mtable></mrow><mspace width=\"1em\"/><mi>R</mi><mi>T</mi><mi>a</mi><mi>g</mi><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>r</mi><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mtext> 指示结点的右孩子</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>r</mi><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mtext> 指示结点的后继</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">LTag = \\begin{cases} \n    0 &amp; lchild \\text{ 指示结点的左孩子} \\\\ \n    1 &amp; lchild \\text{ 指示结点的前驱} \n\\end{cases} \n\\quad \nRTag = \\begin{cases} \n    0 &amp; rchild \\text{ 指示结点的右孩子} \\\\ \n    1 &amp; rchild \\text{ 指示结点的后继} \n\\end{cases}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">d</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">指示结点的左孩子</span></span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">d</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">指示结点的前驱</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">RT</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">rc</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">d</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">指示结点的右孩子</span></span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">rc</span><span class=\"mord mathnormal\">hi</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">d</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">指示结点的后继</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>\n<ul>\n<li>以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做<strong>线索链表</strong>，其中指向结点前驱和后继的指针，叫做<strong>线索</strong>。</li>\n<li>加上线索的二叉树称之为<strong>线索二叉树</strong>。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做<strong>线索化</strong>。</li>\n<li>在后序线索树上招后继时需知道结点的双亲，即需带标志域的三叉链表作存储结构。</li>\n<li>若在某程序中所用二叉树需经常遍历或查找结点在遍历所得线性序列中的前驱和后继，应采用线索链表作存储结构。</li>\n<li>为方便起见，仿照线性表的存储结构，在二叉树的线索链表上也添加一个头结点，并令其lchild域的指针指向二叉树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点；令二叉树中序序列中的第一个结点的lchild域指针和最后一个结点rchild域的指针均指向头结点。这好比为二叉树建立了一个双向线索链表，既可以从第一个结点其顺后继进行遍历，也可从最后一个结点起顺前驱进行遍历。</li>\n</ul>\n<p><strong>中序线索化</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 中序线索化二叉树</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inThread</span><span class=\"params\">(ThreadedTreeNode* root, ThreadedTreeNode*&amp; pre)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 先线索化左子树</span></span><br><span class=\"line\">    <span class=\"built_in\">inThread</span>(root-&gt;left, pre);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 线索化当前节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left) &#123;</span><br><span class=\"line\">        root-&gt;lTag = <span class=\"literal\">true</span>;  <span class=\"comment\">// 左子树为空，指向前驱</span></span><br><span class=\"line\">        root-&gt;left = pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre &amp;&amp; !pre-&gt;right) &#123;</span><br><span class=\"line\">        pre-&gt;rTag = <span class=\"literal\">true</span>;  <span class=\"comment\">// 右子树为空，指向后继</span></span><br><span class=\"line\">        pre-&gt;right = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pre = root;  <span class=\"comment\">// 更新前驱节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 线索化右子树</span></span><br><span class=\"line\">    <span class=\"built_in\">inThread</span>(root-&gt;right, pre);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>中序线索化后，找结点a的后继</strong></p>\n<ol>\n<li>若其右标志为“1”，则右链为线索，指示其后继；</li>\n<li>否则遍历右子树中第一个访问的结点（右子树中最左下的结点）。找到其右子树的根节点<code>b</code>，然后顺其左指针往下至其左标志为1（无左孩子，且线索指向<code>b</code>）的结点，即为<code>a</code>的后继。</li>\n</ol>\n<p><strong>中序线索化后，找结点a的前驱</strong></p>\n<ol>\n<li>若其左标志为“1”，则左链为线索，指示其前驱；</li>\n<li>否则遍历左子树时最后访问的一个结点（左子树中最右下的结点）为其前驱。</li>\n</ol>\n<p><strong>先序线索化</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先序线索化二叉树</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">preThread</span><span class=\"params\">(ThreadedTreeNode* root, ThreadedTreeNode*&amp; pre)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 线索化当前节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left) &#123;</span><br><span class=\"line\">        root-&gt;lTag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        root-&gt;left = pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre &amp;&amp; !pre-&gt;right) &#123;</span><br><span class=\"line\">        pre-&gt;rTag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        pre-&gt;right = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre = root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 先线索化左子树</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;lTag) <span class=\"built_in\">preThread</span>(root-&gt;left, pre);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后线索化右子树</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;rTag) <span class=\"built_in\">preThread</span>(root-&gt;right, pre);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>先序线索化后，找结点a的后继</strong></p>\n<ol>\n<li>若有左孩子，则左孩子就是其后继；</li>\n<li>若无左孩子，但有右孩子，则右孩子就是其后继；</li>\n<li>若为叶结点，则右链域直接指示了结点的后继。</li>\n</ol>\n<p><strong>先序线索化后，找结点a的前驱</strong>（书上没有，自己写的）</p>\n<ol>\n<li>若无左孩子，则左链域直接指示了结点的前驱；</li>\n<li>若有左孩子，<br>①若<code>a</code>无双亲结点，即其为整棵树的根节点，则无前驱；<br>②若<code>a</code>有双亲结点，且<code>a</code>为双亲结点的左孩子，则其前驱为双亲结点；<br>③若<code>a</code>有双亲结点，且<code>a</code>为双亲结点的右孩子，则其前驱为双亲结点的左子树按照先序遍历下的最后一个结点，不一定是左子树的最右侧结点，因为可以是最右侧结点<code>b</code>的左孩子<code>c</code>（<code>b</code>没有右孩子的情况下）</li>\n</ol>\n<p><strong>注：</strong>这个应该也需要三叉链表，因为需要知道其双亲结点。</p>\n<p><strong>后序线索化</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 后序线索化二叉树</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">postThread</span><span class=\"params\">(ThreadedTreeNode* root, ThreadedTreeNode*&amp; pre)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 先线索化左子树</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;lTag) <span class=\"built_in\">postThread</span>(root-&gt;left, pre);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 再线索化右子树</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;rTag) <span class=\"built_in\">postThread</span>(root-&gt;right, pre);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 线索化当前节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left) &#123;</span><br><span class=\"line\">        root-&gt;lTag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        root-&gt;left = pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre &amp;&amp; !pre-&gt;right) &#123;</span><br><span class=\"line\">        pre-&gt;rTag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        pre-&gt;right = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pre = root;  <span class=\"comment\">// 更新前驱节点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>后序线索化后，找结点a的后继</strong></p>\n<ol>\n<li>若结点<code>a</code>是二叉树的根，则其后继为空；</li>\n<li>若结点<code>a</code>是①<u>其双亲结点的右孩子</u>或是②<u>其双亲的左孩子且其双亲没有右子树</u>，则其后继即为双亲结点；</li>\n<li>若结点<code>a</code>是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按照后序遍历列出的第一个结点。</li>\n</ol>\n<p><strong>注：</strong>可见，在后序线索化树上找后继时需知道结点双亲，即需带标志域的三叉链表作存储结构。</p>\n<p><strong>后序线索化后，找结点a的前驱</strong>（书上没有，自己写的）</p>\n<ol>\n<li>若结点<code>a</code>无左孩子，则其前驱为左链域所指示的结点。</li>\n<li>若结点<code>a</code>有左孩子，若其有右孩子则前驱为右孩子，若其无右孩子则前驱为左孩子。</li>\n</ol>\n<h3 id=\"二叉树结构下的应用及扩展（例如）\"><a href=\"#二叉树结构下的应用及扩展（例如）\" class=\"headerlink\" title=\"二叉树结构下的应用及扩展（例如）\"></a>二叉树结构下的应用及扩展（例如）</h3><blockquote>\n<p>掌握利用二叉树及其扩展下的检索技术；掌握Huffman编码、堆的<strong>实现及应用</strong></p>\n</blockquote>\n<h4 id=\"二叉检索树\"><a href=\"#二叉检索树\" class=\"headerlink\" title=\"二叉检索树\"></a>二叉检索树</h4><p>二叉排序树(BST)、二叉查找树、二叉搜索树</p>\n<ul>\n<li><strong>二叉排序树</strong>或者是一棵空树；或者是具有下列性质的二叉树：</li>\n</ul>\n<ol>\n<li>若它的左子树不空，则左子树上<strong>所有</strong>结点的值<strong>均小于</strong>它的根结点的值；</li>\n<li>若它的右子树不空，则右子树上<strong>所有</strong>结点的值<strong>均大于</strong>它的根结点的值；</li>\n<li>它的左、右子树也分别为二叉排序树。</li>\n</ol>\n<ul>\n<li>通常可取<strong>二叉链表</strong>作为二叉排序树的<strong>存储结构</strong>。</li>\n<li>和次优二叉树相对，二叉排序树是一种动态树表。其特点是，树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字（所以结点不能重复）等于给定值的结点时再进行插入。<br>新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查找的关键字序列：&#123;45, 24, 53, 45, 12, 24, 90&#125;</span><br><span class=\"line\">生成的二叉排序树：</span><br><span class=\"line\">        45</span><br><span class=\"line\">      /    \\</span><br><span class=\"line\">     24     53</span><br><span class=\"line\">    /         \\</span><br><span class=\"line\">   12         90</span><br></pre></td></tr></table></figure>\n<ul>\n<li>二叉排序树既拥有类似于折半查找的特性，又采用了链表作为存储结构，因此是动态查找表的一种适宜表示。</li>\n<li>同样，在二叉排序树上删去一个结点也很方便。<br>对于一般的二叉树来说，删去树中一个结点是没有意义的。因为它将使以被删结点为根的子树成为森林，破坏了整棵树的结构。<br>然而，对于二叉排序树，删去树上一个结点相当于删去有序序列中的一个记录，只要在删除某个结点之后依旧保持二叉排序树的特性即可。</li>\n<li>设被删结点为<code>*p</code>，其双亲结点为<code>*f</code>，且不失一般性，可设<code>*p</code>是<code>*f</code>的左孩子。</li>\n</ul>\n<ol>\n<li>若<code>*p</code>结点为叶子结点，即<code>P_L</code>（<code>*p</code>的左子树）和<code>P_R</code>（右子树）均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。</li>\n<li>若<code>*p</code>结点只有左子树<code>P_L</code>或者只有右子树<code>P_R</code>，此时只要令<code>P_L</code>或<code>P_R</code>直接成为其双亲结点<code>*f</code>的左子树即可。显然，作此修改也不破坏二叉排序树的特性。</li>\n<li>若<code>*p</code>结点的左子树和右子树均不空。</li>\n</ol>\n<p><img src=\"/articles/9eb01842/BST_del.jpg\" width=100% /></p>\n<ul>\n<li>ASL(书P231)<br>查找成功的平均查找长度ASL=(Σ每层结点数*深度)/结点总数<br>二叉排序树的查找效率，主要取决于树的高度。</li>\n</ul>\n<ol>\n<li>（和折半查找的判定树相同，最好情况，和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">log_2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span></span></span></span>成正比）若二叉排序树的左、右子树的高度之差的绝对值不超过1（平衡二叉树），它的平均查找长度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log_2n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>（先后插入的关键字有序，单支树，和顺序查找相同，最坏情况，=<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n+1}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>）若二叉排序树是一个只有右（左）孩子的单支树（类似于有序的单链表），则其平均查找长度为O(n)。</li>\n<li>随机情况下，二叉排序树的平均查找长度和logn是等数量级的。</li>\n</ol>\n<ul>\n<li>二分（折半）查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入的顺序不同可能生成不同的二叉排序树（如有序，则生成单支树）。</li>\n<li>当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其查找操作；若有序表是动态查找表，则应选择二叉排序树作为其逻辑结构。</li>\n</ul>\n<h4 id=\"2-3-4树\"><a href=\"#2-3-4树\" class=\"headerlink\" title=\"2-3-4树\"></a>2-3-4树</h4><blockquote>\n<p><a href=\"https://oi-wiki.org/ds/2-3-tree/\">oiwiki 2-3树</a><br><a href=\"https://oi-wiki.org/ds/2-3-4-tree/\">oiwiki 2-3-4树</a></p>\n</blockquote>\n<h4 id=\"B树-B\"><a href=\"#B树-B\" class=\"headerlink\" title=\"B树(B-)\"></a>B树(B-)</h4><blockquote>\n<p><a href=\"https://oi-wiki.org/ds/b-tree/\">oiwiki B树</a></p>\n</blockquote>\n<p>B 树是一种平衡的多路搜索树，广泛用于数据库和文件系统中，以支持高效的数据插入、删除和查找操作。B 树的设计目标是最大限度减少磁盘 I/O 操作，因此特别适合处理大量数据的场景。</p>\n<p><strong>B 树的结构与特性</strong><br>B 树的关键特性如下：</p>\n<ol>\n<li><p><strong>多路搜索树</strong>：  </p>\n<ul>\n<li>B 树的每个结点可以包含多个数据项和多个子结点。</li>\n<li>对于一个 m 阶的 B 树，每个结点最多可以有 m 个子结点，至少有 ⌈m/2⌉ 个子结点（除了根结点可以少于此数目）。</li>\n</ul>\n</li>\n<li><p><strong>数据项的有序性</strong>：  </p>\n<ul>\n<li>每个结点中的数据项按从小到大的顺序排列。</li>\n<li>每个子树对应的值范围在当前结点的数据项之间。<ul>\n<li>比如，如果结点包含数据项 <code>[A, B, C]</code>，则其子树的数据项满足：<ul>\n<li>第一个子树的数据项小于 <code>A</code>；</li>\n<li>第二个子树的数据项在 <code>A</code> 和 <code>B</code> 之间；</li>\n<li>第三个子树的数据项在 <code>B</code> 和 <code>C</code> 之间；</li>\n<li>第四个子树的数据项大于 <code>C</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>平衡性</strong>：  </p>\n<ul>\n<li>B 树是平衡树，所有叶子结点的深度相同，从根到任一叶子结点的路径长度一致。这使得查找的时间复杂度在 <code>O(log n)</code> 范围内。</li>\n</ul>\n</li>\n<li><p><strong>高度控制</strong>：  </p>\n<ul>\n<li>B 树的高度相对较低，通常通过较大的分支因子（m 的值较大）来控制树的高度，使得每个结点包含更多数据，从而减少查找路径长度。</li>\n<li>对于磁盘存储，树的高度越低，磁盘 I/O 次数越少，因此性能越高。</li>\n</ul>\n</li>\n</ol>\n<p><strong>B 树的基本操作</strong><br>B 树的基本操作主要包括查找、插入和删除：</p>\n<ol>\n<li><p><strong>查找</strong>：<br>查找操作与二叉搜索树类似，通过与每个结点的数据项逐一比较，进入对应范围的子树。由于 B 树是平衡的，所以查找的时间复杂度为 <code>O(log n)</code>。</p>\n</li>\n<li><p><strong>插入</strong>：<br>插入操作包括以下几个步骤：</p>\n<ul>\n<li><strong>定位叶结点</strong>：先从根结点查找，找到适合插入新数据项的叶结点。</li>\n<li><strong>插入数据项</strong>：将新数据项插入到叶结点中，并保持结点中的数据项顺序。</li>\n<li><strong>分裂结点</strong>：如果插入后结点的数据项数量超过 m-1，则该结点需要分裂。分裂时，选择中间的数据项上移到父结点，分裂后的两个新结点分别成为父结点的子结点。</li>\n<li><strong>上溢处理</strong>：如果父结点也满了，则父结点同样需要分裂，这可能导致分裂操作逐层向上传播，甚至需要分裂根结点，从而使树的高度增加。</li>\n</ul>\n</li>\n<li><p><strong>删除</strong>：<br>删除操作分为以下几种情况：</p>\n<ul>\n<li><strong>删除叶结点的数据项</strong>：直接删除数据项即可，但要检查该结点是否满足最小数据项数要求（即至少含有 ⌈m/2⌉ 个数据项）。</li>\n<li><strong>删除内部结点的数据项</strong>：可以通过以下策略进行替换：<ul>\n<li>找到左子树的最大值或右子树的最小值来替换该数据项。</li>\n<li>然后在对应子树中递归删除这个替换的数据项。</li>\n</ul>\n</li>\n<li><strong>借用和合并</strong>：如果删除后某结点数据项不足，可从相邻的兄弟结点中“借”一个数据项，或将该结点与兄弟结点合并。如果合并导致父结点数据项不足，则继续向上递归调整，直到树重新平衡。</li>\n</ul>\n</li>\n</ol>\n<p><strong>B 树的应用场景</strong><br>B 树广泛应用于数据库系统、文件系统、键-值存储等，因为它能够有效地支持大量数据的动态存储与管理，并优化磁盘 I/O 操作。在实际应用中，通常会用 B+ 树或 B* 树，因为它们对顺序访问进行了进一步优化。</p>\n<p><strong>B 树的优点</strong>  </p>\n<ul>\n<li><strong>平衡性</strong>：自动保持平衡，避免了二叉搜索树退化为链表的情况。</li>\n<li><strong>高效的磁盘访问</strong>：B 树的高度较低，结点中包含多个数据项，因此每次磁盘读取获取更多数据，有效减少磁盘 I/O 次数。</li>\n<li><strong>支持范围查找</strong>：B 树中的数据项有序排列，因此支持按范围查找（例如查找所有小于某个值的项）。</li>\n</ul>\n<p><strong>B 树的缺点</strong>  </p>\n<ul>\n<li><strong>实现复杂性</strong>：插入、删除需要多种特殊情况处理，尤其是分裂和合并操作。</li>\n<li><strong>内存利用率</strong>：B 树的内存利用率不如二叉树，因为每个结点中可能存在未使用的指针。</li>\n</ul>\n<p>通过这些特性，B 树能够很好地管理大量有序数据，使得查找、插入和删除都在 <code>O(log n)</code> 时间内完成，非常适合高效管理大规模数据。</p>\n<blockquote>\n<p><strong>B树和2-3-4树有什么区别？</strong></p>\n<ol>\n<li>2-3-4 树是 B 树的一个特例，阶数为 4 的 B 树。</li>\n<li>2-3-4 树和 B 树的主要区别在于 B 树的阶数 m 更为灵活，而 2-3-4 树的阶数固定为 4。</li>\n<li>在结构上，2-3-4 树的结点数目（子结点和数据项数目）正好符合 B 树的一个具体实现。</li>\n</ol>\n</blockquote>\n<h4 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h4><blockquote>\n<p><a href=\"https://oi-wiki.org/ds/bplus-tree/\">oiwiki B+树</a></p>\n</blockquote>\n<h4 id=\"Huffman编码\"><a href=\"#Huffman编码\" class=\"headerlink\" title=\"Huffman编码\"></a>Huffman编码</h4><ul>\n<li><strong>路径：</strong>从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。</li>\n<li><strong>路径长度：</strong>路径上的分支数目。</li>\n<li><strong>权：</strong>树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。</li>\n<li><strong>带权路径长度：</strong>从树的根到一个结点的路径长度与该结点上权值的乘积，称为该结点的权。<br>树中所有<strong>叶结点</strong>的带权路径长度之和称为<strong>该树的带权路径长度</strong>，记为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>w</mi><mi>i</mi></msub><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">WPL=\\sum\\limits_{i=1}^{n}w_i l_i </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</li>\n<li><strong>哈夫曼树：</strong>在含有n各带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称<strong>最优二叉树</strong>。</li>\n<li><p><strong>哈夫曼树的构造：</strong>给定n各权值分别为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>w</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">w_1, w_2, \\cdots, w_n </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的结点，构造哈夫曼树的算法描述如下：</p>\n<ol>\n<li>将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。</li>\n<li>构造一个新结点，从F中选取两棵<strong>根节点权值最小</strong>的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。</li>\n<li>从F中删除刚才选出的两棵树，同时将新得到的树加入F中。</li>\n<li>重复步骤2和3，直至F中只剩下一棵树为止。</li>\n</ol>\n</li>\n<li><p><strong>哈夫曼树的性质：</strong>从上述构造过程中可以看出哈夫曼树具有如下特点：</p>\n<ol>\n<li>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。</li>\n<li>构造过程中共新建了n-1个结点（双分支结点），因此哈夫曼树的<strong>结点总数为2n-1</strong>。</li>\n<li>每次构造都选择2棵树作为新结点的孩子，因此<strong>哈夫曼树中不存在度为1的结点</strong>。</li>\n</ol>\n</li>\n<li><p><strong>哈夫曼编码：</strong></p>\n<ul>\n<li><strong>固定长度编码：</strong>在数据通信中，若对每个字符用相等长度的二进制表示，称这种编码方式为固定长度编码。</li>\n<li><strong>可变长度编码：</strong>若允许对不同字符用不等长的二进制位表示，则这种编码方式称为可变长度编码。</li>\n<li><strong>可变长度编码比固定长度编码要好得多</strong>，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。</li>\n<li><strong>前缀编码：</strong>若没有一个编码是另一个编码的前缀，则称这样的编码为<strong>前缀编码</strong>。<ul>\n<li><code>e.g.</code> 0, 10, 110</li>\n</ul>\n</li>\n<li><p>可以利用二叉树来设计<strong>二进制前缀编码</strong>。<br><img src=\"/articles/9eb01842/前缀编码.jpg\" width=60% /></p>\n</li>\n<li><p>哈夫曼编码是一种非常有效的<strong>数据压缩编码</strong>。<br><img src=\"/articles/9eb01842/哈夫曼编码.jpg\" width=60% /><br>这棵哈夫曼树的WPL=1×45+3×(12+13+16)+4×(5+9)=224<br>此处的WPL可视为最终编码得到二进制编码的长度，共224位。若采用3位固定长度编码，则得到的二进制编码长度为300位(45+12+13+16+5+9=100)，因此<strong>哈夫曼树可以设计出总长度最短的二进制前缀编码</strong>。</p>\n</li>\n<li>左分支和右分支究竟是表示0还是表示1没有明确规定，因此构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度WPL相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但WPL必然相同且为最优。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h4><ul>\n<li>n个关键字序列L[1…n]称为堆，当且仅当该序列满足：<ol>\n<li>L(i)≥L(2i)且L(i)≥L(2i+1) （大根堆）或</li>\n<li>L(i)≤L(2i)且L(i)≤L(2i+1) (1≤i≤⌊n/2⌋) （小根堆）</li>\n</ol>\n</li>\n<li><strong>堆一定是完全二叉树。</strong></li>\n<li><strong>堆的插入</strong><br>先将新结点放在堆的末端，再对这个新结点向上执行调整操作。<br><img src=\"/articles/9eb01842/堆插入.jpg\" width=100% /></li>\n</ul>\n<h3 id=\"平衡二叉树的定义和意义-AVL\"><a href=\"#平衡二叉树的定义和意义-AVL\" class=\"headerlink\" title=\"平衡二叉树的定义和意义(AVL)\"></a>平衡二叉树的定义和意义(AVL)</h3><h3 id=\"平衡因子的定义\"><a href=\"#平衡因子的定义\" class=\"headerlink\" title=\"平衡因子的定义\"></a>平衡因子的定义</h3><h3 id=\"平衡二叉树的旋转操作-TODO\"><a href=\"#平衡二叉树的旋转操作-TODO\" class=\"headerlink\" title=\"平衡二叉树的旋转操作(TODO)\"></a>平衡二叉树的旋转操作(TODO)</h3><h3 id=\"树和森林的存储结构\"><a href=\"#树和森林的存储结构\" class=\"headerlink\" title=\"树和森林的存储结构\"></a>树和森林的存储结构</h3><blockquote>\n<p>掌握树、森林能够采用的各种存储方式的差异性</p>\n</blockquote>\n<p>树和森林在计算机中有多种不同的存储方式，每种方式各有优缺点，适合不同的应用场景。下面介绍几种常见的树和森林的存储方法及它们的差异性。</p>\n<h4 id=\"1-链式存储方式\"><a href=\"#1-链式存储方式\" class=\"headerlink\" title=\"1. 链式存储方式\"></a>1. 链式存储方式</h4><p>链式存储方式使用<strong>指针</strong>来表示树结点之间的父子关系，常见的有<strong>双亲表示法</strong>、<strong>孩子表示法</strong>和<strong>孩子兄弟表示法</strong>。链式存储适合<strong>不定度的树</strong>（即每个结点的子结点数不确定的树），例如文件目录结构、HTML DOM 树等。</p>\n<p><strong>a. 双亲表示法</strong><br>每个结点使用一个结构体表示，并包含一个指向其<strong>父结点</strong>的指针或索引。适合查找父结点，但查找子结点效率较低。</p>\n<p><img src=\"/articles/9eb01842/双亲表示法.jpg\" width=100% /></p>\n<ul>\n<li><strong>结构</strong>：每个结点存储自己的值和父结点的指针或索引。</li>\n<li><strong>优点</strong>：利用了每个结点（根结点除外）只有唯一双亲地性质，查找父结点很方便。</li>\n<li><strong>缺点</strong>：查找子结点不方便，需要遍历整个数组来找到该结点的所有子结点。</li>\n</ul>\n<p><strong>b. 孩子表示法</strong><br>为每个结点分配一个<strong>孩子链表</strong>，链表中的每个结点包含指向一个子结点的指针。</p>\n<p><img src=\"/articles/9eb01842/孩子表示法.jpg\" width=100% /></p>\n<ul>\n<li><strong>结构</strong>：每个结点存储自己的值，以及一个链表指针指向其所有的子结点。</li>\n<li><strong>优点</strong>：方便查找子结点，适合不定度的树。</li>\n<li><strong>缺点</strong>：存储结构较为复杂，查找父结点不方便，需要从根结点遍历。</li>\n</ul>\n<p><strong>c. 孩子兄弟表示法（又称二叉树表示法）</strong><br>将树转化为<strong>二叉树</strong>来存储。每个结点使用两个指针：一个指向其<strong>第一个孩子</strong>，另一个指向其<strong>下一个兄弟</strong>。这种方法特别适合存储<strong>森林</strong>结构。</p>\n<p><img src=\"/articles/9eb01842/孩子兄弟表示法.jpg\" width=100% /></p>\n<ul>\n<li><strong>结构</strong>：每个结点存储自己的值，一个孩子指针和一个兄弟指针。</li>\n<li><strong>优点</strong>：适合任意度的树，且能够高效地存储森林结构。</li>\n<li><strong>缺点</strong>：编程逻辑复杂，查找特定的孩子结点或兄弟结点需要遍历。</li>\n</ul>\n<h4 id=\"2-其他存储方式\"><a href=\"#2-其他存储方式\" class=\"headerlink\" title=\"2. 其他存储方式\"></a>2. 其他存储方式</h4><p><strong>a. 数组表示法（用于完全二叉树）</strong><br>对完全二叉树的结点按层次从左到右编号，可以使用数组存储。对于父结点在<strong>数组中的索引（从0开始）</strong>为<code>i</code>：</p>\n<ul>\n<li><strong>左子结点</strong>在位置<code>2*i + 1</code></li>\n<li><strong>右子结点</strong>在位置<code>2*i + 2</code></li>\n</ul>\n<p>这种方法适合<strong>完全二叉树</strong>或<strong>近似完全二叉树</strong>。</p>\n<ul>\n<li><strong>优点</strong>：占用空间小，定位子结点和父结点的效率高。</li>\n<li><strong>缺点</strong>：如果是一般的树或不规则的二叉树，会浪费大量空间，且不适合查找任意度的树。</li>\n</ul>\n<p><strong>b. 邻接矩阵或邻接表（用于森林）</strong><br>可以用邻接矩阵或邻接表来表示森林，将每棵树的结点当作一个图的顶点，将父子关系当作图的边。</p>\n<ul>\n<li><strong>优点</strong>：适合表示复杂的关系，特别是用于图结构的算法。</li>\n<li><strong>缺点</strong>：邻接矩阵会占用大量空间；邻接表适合稀疏图结构，不适合高密度的父子关系。</li>\n</ul>\n<h4 id=\"存储方式的对比总结\"><a href=\"#存储方式的对比总结\" class=\"headerlink\" title=\"存储方式的对比总结\"></a>存储方式的对比总结</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>存储方式</th>\n<th>适用场景</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>双亲表示法</strong></td>\n<td>查找父节点频繁的场景</td>\n<td>查找父节点方便</td>\n<td>查找子节点效率低</td>\n</tr>\n<tr>\n<td><strong>孩子表示法</strong></td>\n<td>查找子节点频繁、不定度的树结构</td>\n<td>查找子节点方便</td>\n<td>查找父节点困难，数据结构复杂</td>\n</tr>\n<tr>\n<td><strong>孩子兄弟表示法</strong></td>\n<td>不定度的树、森林</td>\n<td>适合任意度的树，能存储森林</td>\n<td>逻辑复杂，查找指定孩子或兄弟节点时不便</td>\n</tr>\n<tr>\n<td><strong>数组表示法</strong></td>\n<td>完全二叉树、近似完全二叉树</td>\n<td>占用空间小，定位节点快</td>\n<td>不适合非完全二叉树，存储一般树浪费空间</td>\n</tr>\n<tr>\n<td><strong>邻接矩阵/表</strong></td>\n<td>复杂的森林结构、图结构</td>\n<td>表示关系灵活，特别适合图算法</td>\n<td>邻接矩阵空间大；邻接表不适合高密度父子关系的树</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>根据树的结构和操作需求选择合适的存储方式，可以有效提高数据操作的效率并节省空间。</p>\n<h3 id=\"树和森林的遍历\"><a href=\"#树和森林的遍历\" class=\"headerlink\" title=\"树和森林的遍历\"></a>树和森林的遍历</h3><blockquote>\n<p>掌握树、森林在遍历方面和二叉树的不同以及相关性</p>\n</blockquote>\n<p>树和森林的遍历是理解数据结构中结点访问顺序的关键部分。树的遍历有不同的策略，包括深度优先遍历（如先序、中序、后序遍历）和广度优先遍历（层次遍历）。对于森林，遍历也遵循类似的策略。与二叉树的遍历相比，树和森林的遍历在实现上有一些独特的地方，尤其是当树的度（每个结点的子结点数）不固定时。</p>\n<h4 id=\"1-树的遍历\"><a href=\"#1-树的遍历\" class=\"headerlink\" title=\"1. 树的遍历\"></a>1. 树的遍历</h4><p>树的遍历与二叉树的遍历类似，但树的每个结点可能有多个子结点，因此其遍历方式会有所调整。树的遍历方法一般包括<strong>先根遍历</strong>、<strong>后根遍历</strong>和<strong>层次遍历</strong>，但在每个结点的子结点的访问顺序上有所不同。</p>\n<p><strong>a. 树的先根遍历</strong><br>对于一般树（多子树的树），<strong>前根遍历</strong>访问顺序为：<br>（若树非空）</p>\n<ol>\n<li>访问根结点。</li>\n<li>遍历根结点的每一个子结点，按从左到右的顺序递归遍历每个子结点。</li>\n</ol>\n<p>其遍历序列与这棵树相应的<strong>二叉树的先序序列</strong>相同。</p>\n<p><strong>b. 树的后根遍历</strong><br>对于一般树的<strong>后根遍历</strong>，访问顺序为：<br>（若树非空）</p>\n<ol>\n<li>递归遍历每个子结点（从左到右）。</li>\n<li>访问根结点。</li>\n</ol>\n<p>其遍历序列与这棵树相应的<strong>二叉树的中序序列</strong>相同。</p>\n<p><strong>c. 树的层次遍历</strong><br>树的<strong>层次遍历</strong>类似于二叉树的层次遍历，按层次逐层从上到下、从左到右访问每个结点。这通常通过队列来实现：</p>\n<ol>\n<li>将根结点加入队列。</li>\n<li>取出队列中的结点并访问它。</li>\n<li>如果该结点有子结点，将子结点按顺序加入队列。</li>\n</ol>\n<h4 id=\"3-森林的遍历\"><a href=\"#3-森林的遍历\" class=\"headerlink\" title=\"3. 森林的遍历\"></a>3. 森林的遍历</h4><p>森林是多个树的集合，因此森林的遍历可以看作是对每一棵树进行遍历。在遍历森林时，通常会对森林中的每一棵树单独进行遍历，遍历的方法与树的遍历方法相同。</p>\n<p><strong>先序遍历森林</strong><br>（若森林非空）</p>\n<ol>\n<li>访问森林中第一棵树的根结点。</li>\n<li>先序遍历第一棵树中根结点的子树森林。</li>\n<li>先序遍历除去第一棵之后剩余的树构成的森林。</li>\n</ol>\n<p>其遍历序列与这个森林对应的<strong>二叉树的先序序列</strong>相同。</p>\n<p><strong>中序遍历森林</strong>（类似于树的后根遍历，先子树后根）<br>（若森林非空）</p>\n<ol>\n<li>中序遍历森林中第一棵树的根结点的子树森林。</li>\n<li>访问第一棵树的根结点。</li>\n<li>中序遍历除去第一棵树之后剩余的树构成的森林。</li>\n</ol>\n<p>其遍历序列与这个森林相应的<strong>二叉树的中序序列</strong>相同。</p>\n<h3 id=\"森林与二叉树的转换\"><a href=\"#森林与二叉树的转换\" class=\"headerlink\" title=\"森林与二叉树的转换\"></a>森林与二叉树的转换</h3><ul>\n<li>二叉树和树都可以用二叉链表作为存储结构。从物理结构上看，树的孩子兄弟表示法与二叉树的二叉链表表示法是相同的，因此可以用同一存储结构的不同解释将一棵树转换为二叉树。</li>\n</ul>\n<p><strong>1. 树转换为二叉树</strong></p>\n<p><img src=\"/articles/9eb01842/树变二叉树.jpg\" width=100%/></p>\n<p>树转换为二叉树的画法：</p>\n<ol>\n<li>在兄弟结点之间加一条线；</li>\n<li>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；</li>\n<li>以树根为轴心，顺时针旋转45°。</li>\n</ol>\n<p><strong>2. 森林转换为二叉树</strong><br>将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任意一棵树对应的二叉树的右子树必空，若把森林中第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应的二叉树当作第一棵二叉树根的右子树，将第三棵树对应的二叉树当作第二课二叉树根的右子树，以此类推，就可以将森林转换为二叉树。<br>森林转换为二叉树的画法：</p>\n<ol>\n<li>将森林中的每棵树转换成相应的二叉树；</li>\n<li>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；</li>\n<li>以第一棵树的根为轴心，顺时针旋转45°。</li>\n</ol>\n<p><strong>3. 二叉树转换为森林</strong></p>\n<p><img src=\"/articles/9eb01842/二叉树变森林.jpg\" width=100%/></p>\n<h3 id=\"森林结构的应用（例如）\"><a href=\"#森林结构的应用（例如）\" class=\"headerlink\" title=\"森林结构的应用（例如）\"></a>森林结构的应用（例如）</h3><h4 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h4><blockquote>\n<p>理解并查集的意义，以及掌握并查集的基本操作的实现</p>\n</blockquote>\n<p><strong>并查集的概念</strong><br>并查集是一种简单的集合表示，它支持以下3种操作：</p>\n<ol>\n<li>Initia(S): 将集合S中的每个元素都初始化为只有一个单元素的子集合。</li>\n<li>Union(S, Root1, Root2): 把集合S中的子集合Root2并入子集合Root1。要求Root1和Root2互不相交，否则不执行合并。</li>\n<li>Find(S, x): 查找集合S中单元素x所在的子集合，并返回该子集合的根结点。</li>\n</ol>\n<p><strong>并查集的存储结构</strong><br>通常用<strong>树的双亲表示</strong>作为并查集的存储结构，每个子集合以一棵树表示。所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内。<br>通常用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲域为负数（可设置为该子集合元素数量的相反数）。</p>\n<p><img src=\"/articles/9eb01842/并查集.jpg\" width=100%/></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//并查集的结构定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE 100</span></span><br><span class=\"line\"><span class=\"type\">int</span> UFSets[SIZE];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//并查集的初始化操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Initial</span><span class=\"params\">(<span class=\"type\">int</span> S[])</span> </span>&#123; <span class=\"comment\">//S即为并查集</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class=\"line\">    s[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查找操作</span></span><br><span class=\"line\"><span class=\"comment\">//判断两个元素是否属于同一个集合，只需分别找到它们的根，再比较根是否相同即可。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(S[x] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    x = S[x];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//合并操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> Root1, <span class=\"type\">int</span> Root2)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(Root1 == Root2) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  S[Root2] = S[Root1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//并查集实现的优化</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">在极端情况下，n个元素构成的集合树的深度为n，则Find操作的最坏时间复杂度为O(n)</span></span><br><span class=\"line\"><span class=\"comment\">改进：令根结点的绝对值＝集合树的成员数量，将小树合并到大树</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> Root1, <span class=\"type\">int</span> Root2)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(Root1 == Root2) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">abs</span>(S[Root2]) &lt; <span class=\"built_in\">abs</span>(S[Root1])) &#123; <span class=\"comment\">//Root2结点数更少</span></span><br><span class=\"line\">    S[Root1] += S[Root2];</span><br><span class=\"line\">    S[Root2] = Root1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    S[Root2] += S[Root1];</span><br><span class=\"line\">    S[Root1] = Root2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">采用这种方法构造得到的集合树，其深度不超过⌊log_2 n⌋+1</span></span><br><span class=\"line\"><span class=\"comment\">随着子集逐对合并，集合树的深度越来越大，</span></span><br><span class=\"line\"><span class=\"comment\">为了进一步减少确定元素所在集合的时间，还可优化Find操作，</span></span><br><span class=\"line\"><span class=\"comment\">即将从根到元素x路径上的所有元素都变成根的孩子</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> root = x;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(S[root] &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    root = S[root];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(x != root) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> t = S[x];</span><br><span class=\"line\">    S[x] = root;</span><br><span class=\"line\">    x = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">通过Find操作的“压缩路径”优化后，可使集合树的深度不超过O(α(n))，</span></span><br><span class=\"line\"><span class=\"comment\">其中α(n)是一个增长极其缓慢的函数，对于常见的正整数n，通常α(n)≤4。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或递归</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (S[x] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> S[x] = <span class=\"built_in\">Find</span>(S, S[x]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>什么是并查集？并查集主要用在什么地方？</strong><br>答：并查集又称为不相交集合，是表示集合的不相交子集合的一种集合表示，它主要有三种操作：初始化，查找和合并。并查集主要用于判断和构造等价类。</p>\n<p><strong>为什么并查集的实现采用树或森林的双亲数组？</strong><br>答：一般集合的实现采用位数组或有序链表，但这两种存储表示对于<strong>描述子集合的集合、查找某个集合元素在哪个子集合</strong>有一定的困难。<br>采用树或森林的双亲表示数组，同一子集合的元素位于同一棵树中，子集合的集合用森林表示，可以方便地实现查找和合并操作。</p>\n<p><strong>为什么在并查集的双亲数组中树（子集合）的根的双亲指针为负数？</strong><br>答：子集合用树的根来标识，根的双亲指针为负数，可区别树的根结点和树中的其他结点。该负数的绝对值可能表示的是树中结点的个数，也可能表示的是树的高度。</p>\n<p><strong>在合并操作<code>Merge(S, R1, R2)</code>中，为什么规定<code>R1</code>和<code>R2</code>是两棵树的根？</strong><br>答：若允许<code>R1</code>和<code>R2</code>是两棵树的任意结点，如让<code>R2</code>的双亲指针指向<code>R1</code>，可能会把以<code>R2</code>为根的子树从原来<code>R2</code>所在的树中脱离出去，造成运算错误。</p>\n<h2 id=\"六、图\"><a href=\"#六、图\" class=\"headerlink\" title=\"六、图\"></a>六、图</h2><h3 id=\"图的定义（包括）\"><a href=\"#图的定义（包括）\" class=\"headerlink\" title=\"图的定义（包括）\"></a>图的定义（包括）</h3><p>图G由顶点集V和边集E组成，记为G=(V,E)，其中V(G)表示图G中顶点的有限非空集，E(G)表示图G中顶点之间的关系（边）的集合。<br>若<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>=</mo><mrow><msub><mi>v</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>n</mi></msub></mrow></mrow><annotation encoding=\"application/x-tex\">V={v_1, v_2, \\cdots, v_n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>，则用|V|表示图G中顶点的个数，E={(u,v)|u∈V,v∈V}，用|E|表示图G中边的条数。</p>\n<h4 id=\"完全图（又称简单完全图）\"><a href=\"#完全图（又称简单完全图）\" class=\"headerlink\" title=\"完全图（又称简单完全图）\"></a>完全图（又称简单完全图）</h4><p>用n表示图中顶点数目，不考虑顶点到其自身的弧或边的情况下，<br>（无向图的边数目的取值范围：0到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{2}n(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，有向图的弧数目的取值范围：0到n(n-1)。）<br>有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{2}n(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>条边的无向图称为<strong>完全图</strong>；<br>有n(n-1)条弧的有向图称为<strong>有向完全图</strong>。<br>有很少条边或弧（如 e &lt; nlogn）的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong>。</p>\n<h4 id=\"连通图\"><a href=\"#连通图\" class=\"headerlink\" title=\"连通图\"></a>连通图</h4><p><strong>在无向图中</strong>，如果从顶点v到顶点w有路径存在，则称v和w是<strong>连通</strong>的。<br>若图中任意两个顶点都是连通的，则称其为<strong>连通图</strong>，否则称为<strong>非连通图</strong>。<br><strong>连通分量</strong>：<strong>无向图</strong>中的极大连通子图。</p>\n<p><strong>在有向图中</strong>，若有一对顶点v和w，从v到w和从w到v之间都有路径，则称这两个顶点是<strong>强连通</strong>的。<br>若图中任意一对顶点都是强连通的，则称此图为<strong>强连通图</strong>。<br><strong>强连通分量</strong>：<strong>有向图</strong>中的极大强连通子图。<br>若一张有向图的节点两两互相可达，则称这张图是<strong>强连通</strong>的 (strongly connected)。<br>若一张有向图的边替换为无向边后可以得到一张连通图，则称原来这张有向图是<strong>弱连通</strong>的 (weakly connected)。<br><strong>弱连通分量</strong>(weakly connected component)（极大弱连通子图）<br><strong>强连通分量</strong>(strongly connected component)（极大强连通子图）。</p>\n<h4 id=\"简单路径\"><a href=\"#简单路径\" class=\"headerlink\" title=\"简单路径\"></a>简单路径</h4><p><strong>路径：</strong>一个顶点到另一个顶点之间的<strong>顶点序列</strong>。<br><strong>路径长度：</strong>路径上的<strong>边（无向图）或弧（有向图）</strong>的数目。<br><strong>距离：</strong>从顶点u出发到顶点v的<strong>最短</strong>路径若存在，则<strong>此路径的长度</strong>称为从u到v的距离。若从u到v根本不存在路径，则记该距离为无穷（∞）。<br><strong>回路或环：</strong>第一个顶点和最后一个顶点相同的<strong>路径</strong>（说明是顶点序列）称为<strong>回路</strong>或<strong>环</strong>。<br><strong>简单路径：</strong>序列中顶点不重复出现的路径。<br><strong>简单回路或环：</strong>除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路。<br><strong>简单图：</strong>①不存在重复边；②不存在顶点到自身的边；的图。<br><strong>多重图：</strong>存在某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联的图。</p>\n<h4 id=\"有向图\"><a href=\"#有向图\" class=\"headerlink\" title=\"有向图\"></a>有向图</h4><p>有向图（Digraph）是由一组顶点和一组有向边组成的图。在有向图中，边有方向，即一条边从一个顶点指向另一个顶点。若存在一条边从顶点 A 指向顶点 B，则只能从 A 到 B，不能从 B 到 A。<br>弧是顶点地有序对，记为<v,w>，v称为<strong>弧尾</strong>，w称为<strong>弧头</strong>。</p>\n<p><v,w>称为从v到w的弧，也称v邻接到w。</p>\n<h4 id=\"无向图\"><a href=\"#无向图\" class=\"headerlink\" title=\"无向图\"></a>无向图</h4><p>无向图（Undigraph）是由一组顶点和一组无向边组成的图。在无向图中，边没有方向，即如果存在一条边连接顶点 A 和顶点 B，则可以从 A 到 B，也可以从 B 到 A。<br>边是顶点的无序对，记为(v, w)或(w,v)。<br>可以说w和v互为邻接点。<br>边(v,w)依附于w和v，或称边(v,w)和v，w相关联。</p>\n<h4 id=\"无环图\"><a href=\"#无环图\" class=\"headerlink\" title=\"无环图\"></a>无环图</h4><p><strong>在无环图中，从任何一个顶点出发，沿着图中的边所走的路径都不能回到该顶点。</strong><br>无环图有两种常见的类型：<strong>有向无环图（DAG）</strong>和<strong>无向无环图（UAG，又称森林）</strong>。<br><strong>注：</strong>①<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA\">无向、无环、连通图：树</a>#)；  ②<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA\">无向、无环图：森林</a>#%E6%A3%AE%E6%9E%97)。</p>\n<h4 id=\"等\"><a href=\"#等\" class=\"headerlink\" title=\"等\"></a>等</h4><p><strong>子图的定义</strong></p>\n<p>子图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo separator=\"true\">,</mo><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G&#x27; = (V&#x27;, E&#x27;) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 是图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G = (V, E) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span> 的一个子集，其中：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊆</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V&#x27; \\subseteq V </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8879em;vertical-align:-0.136em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> 的顶点集合的子集。</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊆</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E&#x27; \\subseteq E </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8879em;vertical-align:-0.136em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> 是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> 的边集合的子集，且 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">E&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> 中的每一条边都连接 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">V&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> 中的顶点。</li>\n</ul>\n<p><strong>真子图的定义</strong></p>\n<p>真子图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo separator=\"true\">,</mo><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G&#x27; = (V&#x27;, E&#x27;) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 是图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G = (V, E) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span> 的一个<strong>真子集</strong>，即：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊂</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V&#x27; \\subset V </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.791em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊂</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E&#x27; \\subset E </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.791em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>，并且至少有一个顶点或边不在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">G&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> 中。</li>\n</ul>\n<p><strong>注：</strong>真子图必须少于原图的顶点或边，不能与原图完全相同。</p>\n<p><strong>导出子图的定义</strong></p>\n<p>导出子图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo separator=\"true\">,</mo><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G&#x27; = (V&#x27;, E&#x27;) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 是由原图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G = (V, E) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span> 中的一个顶点子集 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊆</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V&#x27; \\subseteq V </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8879em;vertical-align:-0.136em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 生成的，且包含 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">V&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> 中顶点之间在原图中的所有边：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>E</mi><mo>∣</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo>∈</mo><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">E&#x27; = \\{(u, v) \\in E \\mid u, v \\in V&#x27;\\} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>\n</li>\n</ul>\n<p>导出子图是由顶点子集及其间所有连接边构成的子图。</p>\n<p><strong>生成子图（或支撑子图）的定义</strong></p>\n<p>对一张图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G = (V, E)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span> ，若存在另一张图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo separator=\"true\">,</mo><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G&#x27; = (V&#x27;, E&#x27;) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 满足 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V&#x27; = V </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊆</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E&#x27; \\subseteq E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8879em;vertical-align:-0.136em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> ，则称 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">G&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> 是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> 的 生成子图/支撑子图 (spanning subgraph)。</p>\n<p><strong>子图、真子图、导出子图和生成子图的区别</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>图类型</th>\n<th>定义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>子图</strong></td>\n<td>从原图中选取部分顶点和与之连接的部分边构成的图。</td>\n<td>可以是原图的任意部分，包括可能包含整个图。</td>\n</tr>\n<tr>\n<td><strong>真子图</strong></td>\n<td>是一个子图，但必须少于原图，即不等于原图。</td>\n<td>真子图不能包含原图的所有顶点和边。</td>\n</tr>\n<tr>\n<td><strong>导出子图</strong></td>\n<td>从原图中选取一个顶点集合，生成包含这些顶点和它们之间的所有边的子图。</td>\n<td>导出子图必须保留选定顶点之间的原始边，通常导出子图是从子集顶点产生的最小图。</td>\n</tr>\n<tr>\n<td><strong>生成子图</strong></td>\n<td>从原图中选取全部顶点和与之连接的部分边构成的图。</td>\n<td>生成子图G’中顶点个数V’必须和原图G中V的数量相同，而E’∈E即可。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>显然，原图 G 是自身的子图，支撑子图，导出子图；无边图 是 G 的支撑子图。</p>\n<p><strong>生成树：</strong>一个<strong>连通图（无向）</strong>的生成树是一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的n-1条边。</p>\n<ul>\n<li>如果在一棵生成树上添加一条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。</li>\n<li>一棵有n个顶点的生成树有且仅有n-1条边。<ol>\n<li>如果一个图有n个顶点和小于n-1条边，则是非连通图。</li>\n<li>如果它多于n-1条边，则一定有环。</li>\n<li>但是，有n-1条边的图不一定是生成树。</li>\n</ol>\n</li>\n</ul>\n<p>如果一个<strong>有向图</strong>恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵<strong>有向树</strong>。</p>\n<p><strong>生成森林：</strong>在非连通图中，连通分量的生成树构成了<strong>非连通图的生成森林</strong>。<br>一个<strong>有向图</strong>的<strong>生成森林</strong>由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的<strong>有向树</strong>的弧。</p>\n<p><strong>顶点的度、入度、出度</strong><br>在<strong>无向图</strong>中，顶点v的度是指依附于顶点v的边的条数，记为<strong>TD(v)</strong>。<br>无向图全部顶点的<strong>度之和</strong>等于<strong>边数的2倍</strong>，因为每条边和两个顶点相关联。<br>在<strong>有向图</strong>中，顶点v的度分为<strong>入度</strong>和<strong>出度</strong>，<strong>入度</strong>是以顶点v为终点的有向边的数目，记为<strong>ID(v)</strong>；而<strong>出度</strong>是以顶点v为起点的有向边的数目，记为<strong>OD(v)</strong>。顶点v的度<strong>TD(v)=ID(v)+OD(v)</strong>。<br>有向图的<strong>全部顶点的入度之和与出度之和</strong>相等，这是因为每条有向边都有一个起点和终点。</p>\n<p><strong>边的权和网</strong><br>在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的<strong>权值</strong>。<br>这种边上带有权值的图称为<strong>带权图</strong>，也称<strong>网</strong>。</p>\n<h3 id=\"图和二叉树、树和森林这种结构之间的异同点（明确理解）\"><a href=\"#图和二叉树、树和森林这种结构之间的异同点（明确理解）\" class=\"headerlink\" title=\"图和二叉树、树和森林这种结构之间的异同点（明确理解）\"></a>图和二叉树、树和森林这种结构之间的异同点（明确理解）</h3><p><a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA\">无向、无环、连通图：树</a>#)<br>森林是指互相不交并树的集合。<br><a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA\">无向、无环图：森林</a>#%E6%A3%AE%E6%9E%97)</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>结构</strong></th>\n<th><strong>连通性</strong></th>\n<th><strong>环的存在</strong></th>\n<th><strong>边的数量</strong></th>\n<th><strong>子节点数量</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>图</strong></td>\n<td>可以连通，也可以不连通</td>\n<td>可以有环</td>\n<td>没有固定要求</td>\n<td>没有限制</td>\n</tr>\n<tr>\n<td><strong>树</strong></td>\n<td>连通</td>\n<td>无环</td>\n<td>( n-1 )（( n ) 为顶点数）</td>\n<td>每个结点有且仅有一个父节点</td>\n</tr>\n<tr>\n<td><strong>二叉树</strong></td>\n<td>连通</td>\n<td>无环</td>\n<td>( n-1 )（( n ) 为顶点数）</td>\n<td>每个结点最多两个子节点</td>\n</tr>\n<tr>\n<td><strong>森林</strong></td>\n<td>不一定连通</td>\n<td>无环</td>\n<td>( n - k )（( k ) 为树的数量）</td>\n<td>每棵树都是一棵独立的无环连通树</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"图的存储（包括）\"><a href=\"#图的存储（包括）\" class=\"headerlink\" title=\"图的存储（包括）\"></a>图的存储（包括）</h3><h4 id=\"邻接矩阵法\"><a href=\"#邻接矩阵法\" class=\"headerlink\" title=\"邻接矩阵法\"></a>邻接矩阵法</h4><ul>\n<li>所谓<strong>邻接矩阵存储</strong>，是指用一个一维矩阵存储图中顶点的信息，用一个二维矩阵存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为<strong>邻接矩阵</strong>。</li>\n<li>顶点数为n的图的邻接矩阵A是n×n的。通常用0或∞来代表两个顶点之间不存在边。</li>\n<li><strong>无向图</strong>的邻接矩阵是<strong>对称矩阵</strong>，对规模特大的邻接矩阵可采用压缩存储。</li>\n<li><strong>空间复杂度</strong>为O(n)，其中n为图的顶点数|V|。</li>\n<li>对于<strong>无向图</strong>，邻接矩阵的第i行（或列）非零（或∞）元素的个数正好是顶点i的度TD(i)。</li>\n<li>对于<strong>有向图</strong>，i行-&gt;出度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mi>D</mi><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">OD(v_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，i列-&gt;入度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mi>D</mi><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ID(v_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n<li>设图G的邻接矩阵为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mtext>，</mtext><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">A \\text{，} A^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">，</span></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>的元素<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mi>n</mi></msup><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A^n[i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span>等于由顶点i到顶点j的长度为n的路径的数目。</li>\n</ul>\n<h4 id=\"邻接表法\"><a href=\"#邻接表法\" class=\"headerlink\" title=\"邻接表法\"></a>邻接表法</h4><ul>\n<li>所谓邻接表，是指对图G中的每个顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 建立一个单链表，第i个单链表中的结点表示依附于顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的边（对于有向图则是以顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 为尾的弧），这个单链表就称为顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的<strong>边表</strong>（对于有向图则称为<strong>出边表</strong>）。边表的头指针和顶点的数据信息采用顺序存储，称为<strong>顶点表</strong>，所以在邻接表中存在两种结点：顶点表和边表结点。</li>\n<li><strong>顶点表结点</strong>由两个域组成：顶点域（data）存储顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的相关信息，边表头指针域（firstarc）指向第一条边的边表结点。</li>\n<li><strong>边表结点</strong>至少由两个域组成：邻接点域（adjvex）存储与头结点顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 邻接的顶点编号，指针域（nextarc）指向下一条边的边表结点。</li>\n<li><strong>空间复杂度：</strong>无向图-&gt;O(|V|+2|E|)，有向图-&gt;O(|V|+|E|)。</li>\n<li>找有向图的入度必须遍历整个邻接表。</li>\n<li>图的邻接表表示法并<strong>不唯一</strong>，因为在每个顶点对应的边表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。</li>\n</ul>\n<h4 id=\"差异性\"><a href=\"#差异性\" class=\"headerlink\" title=\"差异性\"></a>差异性</h4><blockquote>\n<p>掌握图采用邻接矩阵和邻接表进行存储的差异性</p>\n</blockquote>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>邻接矩阵</th>\n<th>邻接表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>空间复杂度</strong></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(V^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td>无向图：O(V + 2E)，有向图：O(V + E)</td>\n</tr>\n<tr>\n<td><strong>找相邻边</strong></td>\n<td>需要遍历整行或列，O(V)</td>\n<td>找有向图的入度必须遍历整个邻接表</td>\n</tr>\n<tr>\n<td><strong>删除边或顶点</strong></td>\n<td>删除边很方便，删除顶点需要大量移动数据</td>\n<td>无向图中删除边或顶点都不方便</td>\n</tr>\n<tr>\n<td><strong>适用图类型</strong></td>\n<td>稠密图（图中的边较多）</td>\n<td>稀疏图（图中的边较少）</td>\n</tr>\n<tr>\n<td><strong>表示方式</strong></td>\n<td>唯一</td>\n<td>不唯一</td>\n</tr>\n<tr>\n<td><strong>实现难度</strong></td>\n<td>简单</td>\n<td>稍复杂</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"十字链表（大纲这里没写）\"><a href=\"#十字链表（大纲这里没写）\" class=\"headerlink\" title=\"十字链表（大纲这里没写）\"></a>十字链表（大纲这里没写）</h4><p>十字链表是<strong>有向图</strong>的一种链式存储结构。在十字链表中，有向图的每条弧用一个结点（弧结点）来表示，每个结点（顶点结点）来表示。<br>弧结点有5个域：</p>\n<ul>\n<li><code>tailvex</code>和<code>headvex</code>两个域分别指示狐尾和弧头这两个顶点的编号；</li>\n<li>头链域<code>hlink</code>指向弧头相同的下一个弧结点；</li>\n<li>尾链域<code>tlink</code>指向弧尾相同的下一个弧结点；</li>\n<li><code>info</code>域存放该弧的相关信息。</li>\n</ul>\n<p>顶点结点中有3个域：</p>\n<ul>\n<li><code>data</code>域存放该顶点的数据信息，如顶点名称；</li>\n<li><code>firstin</code>域指向以该顶点为弧头的第一个弧结点；</li>\n<li><code>firstout</code>域指向以该顶点为弧尾的第一个弧结点。</li>\n</ul>\n<p>弧结点</p>\n<table>\n  <tr>\n    <td style=\"border: 1px solid; text-align: center;\">tailvex</td>\n    <td style=\"border: 1px solid; text-align: center;\">headvex</td>\n    <td style=\"border: 1px solid; text-align: center;\">hlink</td>\n    <td style=\"border: 1px solid; text-align: center;\">tlink</td>\n    <td style=\"border: 1px solid; text-align: center;\">(info)</td>\n  </tr>\n</table>\n\n<p>顶点结点</p>\n<table>\n  <tr>\n    <td style=\"border: 1px solid; text-align: center;\">data</td>\n    <td style=\"border: 1px solid; text-align: center;\">firstin</td>\n    <td style=\"border: 1px solid; text-align: center;\">firstout</td>\n  </tr>\n</table>\n\n<p><img src=\"/articles/9eb01842/十字链表.jpg\" width=100%/></p>\n<p>注意，顶点结点之间是顺序存储的，弧结点省略了info域。<br>在十字链表中，既容易找到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>为尾的弧，也容易找到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>为头的弧，因而容易求得顶点的出度和入度。图的十字链表表示是不唯一的，但一个十字链表表示唯一确定的图。</p>\n<h4 id=\"邻接多重表（大纲这里没写）\"><a href=\"#邻接多重表（大纲这里没写）\" class=\"headerlink\" title=\"邻接多重表（大纲这里没写）\"></a>邻接多重表（大纲这里没写）</h4><p>邻接多重表是<strong>无向图</strong>的一种链式存储结构。在邻接表中，容易求得顶点和边得各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点得边表中遍历，效率极低。<br>与十字链表类似，在邻接多重表中，每条边用一个结点表示，每个顶点也用一个结点表示。<br>边结点</p>\n<table>\n  <tr>\n    <td style=\"border: 1px solid; text-align: center;\">ivex</td>\n    <td style=\"border: 1px solid; text-align: center;\">ilink</td>\n    <td style=\"border: 1px solid; text-align: center;\">jvex</td>\n    <td style=\"border: 1px solid; text-align: center;\">jlink</td>\n    <td style=\"border: 1px solid; text-align: center;\">(info)</td>\n  </tr>\n</table>\n\n<ul>\n<li><code>ivex</code>和<code>jvex</code>这两个域指示该边依附的两个顶点的编号；</li>\n<li><code>ilink</code>域指向下一条依附于顶点ivex的边；</li>\n<li><code>jlink</code>域指向下一条依附于顶点jvex的边；</li>\n<li><code>info</code>域存放该边的相关信息。</li>\n</ul>\n<p>顶点结点</p>\n<table>\n  <tr>\n    <td style=\"border: 1px solid; text-align: center;\">data</td>\n    <td style=\"border: 1px solid; text-align: center;\">firstedge</td>\n  </tr>\n</table>\n\n<ul>\n<li><code>data</code>域存放该顶点的相关信息；</li>\n<li><code>firstedge</code>域指向第一条依附于该顶点的边。</li>\n</ul>\n<p>在邻接多重表中，所有依附于同一顶点的边串联在同一链表中；因为每条边依附于两个顶点，所以每个边结点同时链接在两个链表中。<br>对无向图而言，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。</p>\n<p><img src=\"/articles/9eb01842/邻接多重表.jpg\" width=100%/></p>\n<p><img src=\"/articles/9eb01842/四存区别.jpg\" width=100%/></p>\n<h3 id=\"图的基本操作\"><a href=\"#图的基本操作\" class=\"headerlink\" title=\"图的基本操作\"></a>图的基本操作</h3><p>略</p>\n<h3 id=\"图的两种遍历\"><a href=\"#图的两种遍历\" class=\"headerlink\" title=\"图的两种遍历\"></a>图的两种遍历</h3><ul>\n<li>图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的<strong>所有顶点</strong>访问一次，且仅访问一次。</li>\n<li>注意树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的遍历。</li>\n</ul>\n<h4 id=\"广度优先遍历\"><a href=\"#广度优先遍历\" class=\"headerlink\" title=\"广度优先遍历\"></a>广度优先遍历</h4><ul>\n<li>Breadth-First-Search, BFS</li>\n<li>Dijkstra单源最短路径算法和Prim最小生成树算法也应用了类似的思想。</li>\n<li>逐层访问，不回溯。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//标准写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph, vector&lt;<span class=\"type\">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(start);</span><br><span class=\"line\">    visited[start] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> node = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历当前结点的邻接结点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> neighbor : graph[node]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[neighbor]) &#123;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(neighbor);</span><br><span class=\"line\">                visited[neighbor] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//邻接表法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(AlGraph G, <span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">  visited[i] = TRUE;</span><br><span class=\"line\">  <span class=\"built_in\">EnQueue</span>(Q, i);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!<span class=\"built_in\">IsEmpty</span>(Q)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">DeQueue</span>(Q, v); <span class=\"comment\">//队首顶点v出队</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (p = G.vertices[v].firstarc; p; p = p -&gt; nextarc) &#123;</span><br><span class=\"line\">      w = p -&gt; adjvex;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(visited[w] == FALSE) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">visit</span>(w);</span><br><span class=\"line\">        visited[w] = TRUE;</span><br><span class=\"line\">        <span class=\"built_in\">EnQueue</span>(Q, w);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//邻接矩阵法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(MGraph G, <span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">  visited[i] = TRUE;</span><br><span class=\"line\">  <span class=\"built_in\">EnQueue</span>(Q, i);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!<span class=\"built_in\">IsEmpty</span>(Q)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">DeQueue</span>(Q, v);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (w = <span class=\"number\">0</span>; w &lt; G.vexnum; w ++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(visited[w] == FALSE &amp;&amp; G.edge[v][w] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">visit</span>(w);</span><br><span class=\"line\">        visited[w] = TRUE;</span><br><span class=\"line\">        <span class=\"built_in\">EnQueue</span>(Q, w);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>图的广度优先遍历是二叉树的层次遍历算法的扩展。</li>\n<li>最坏时间复杂度为O(|V|)。</li>\n<li>邻接表时间复杂度为O(|V|+|E|)，因为每个顶点均需搜索（或入队）一次（O(|V|)），在搜索每个顶点的邻接点时，每条边至少访问一次（O(|E|)）。</li>\n<li>邻接矩阵时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 求非带权图的单源最短路径</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">shortestPath</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = graph.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">distance</span><span class=\"params\">(n, <span class=\"number\">-1</span>)</span></span>; <span class=\"comment\">// 距离数组，初始化为-1表示未访问</span></span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    </span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(start);</span><br><span class=\"line\">    distance[start] = <span class=\"number\">0</span>; <span class=\"comment\">// 起始结点到自身的距离为0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> node = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> neighbor : graph[node]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (distance[neighbor] == <span class=\"number\">-1</span>) &#123; <span class=\"comment\">// 如果未访问</span></span><br><span class=\"line\">                distance[neighbor] = distance[node] + <span class=\"number\">1</span>; <span class=\"comment\">// 更新最短距离</span></span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(neighbor);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> distance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>广度优先生成树</strong></p>\n<ul>\n<li>同一个图的邻接矩阵存储表示是唯一的，所以广度优先生成树也是唯一的。</li>\n<li>但因为邻接表存储表示不唯一，所以广度优先生成树也是不唯一的。</li>\n</ul>\n<h4 id=\"深度优先遍历\"><a href=\"#深度优先遍历\" class=\"headerlink\" title=\"深度优先遍历\"></a>深度优先遍历</h4><ul>\n<li>Depth-First-Search, DFS</li>\n<li>类似于树的先序遍历。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 递归实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS_recursive</span><span class=\"params\">(<span class=\"type\">int</span> node, <span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph, vector&lt;<span class=\"type\">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class=\"line\">    visited[node] = <span class=\"literal\">true</span>; <span class=\"comment\">// 标记当前结点为已访问</span></span><br><span class=\"line\">    cout &lt;&lt; node &lt;&lt; <span class=\"string\">&quot; &quot;</span>;  <span class=\"comment\">// 输出当前访问的结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> neighbor : graph[node]) &#123; <span class=\"comment\">// 遍历相邻结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[neighbor]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">DFS_recursive</span>(neighbor, graph, visited); <span class=\"comment\">// 递归访问未访问的结点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//非递归</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS_iterative</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(graph.size(), <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\">    s.<span class=\"built_in\">push</span>(start);</span><br><span class=\"line\">    visited[start] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> node = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        cout &lt;&lt; node &lt;&lt; <span class=\"string\">&quot; &quot;</span>; <span class=\"comment\">// 输出当前访问的结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> neighbor : graph[node]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[neighbor]) &#123;</span><br><span class=\"line\">                s.<span class=\"built_in\">push</span>(neighbor);</span><br><span class=\"line\">                visited[neighbor] = <span class=\"literal\">true</span>; <span class=\"comment\">// 标记为已访问，防止重复入栈</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//邻接表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(ALGraph G, <span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">  visited[i] == TRUE;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (p = G.vertices[i]; p; p = p -&gt; nextarc) &#123;</span><br><span class=\"line\">    j = p -&gt; adjvex;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(visited[j] == FALSE) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">DFS</span>(G, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//邻接矩阵</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(MGraph G, <span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">  visited[i] = TRUE;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; G.vexnum; j ++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(visited[j] == FALSE &amp;&amp; G.edge[i][j] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">DFS</span>(G, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>图的邻接矩阵表示是唯一的，但对邻接表来说，若边的输入次序不同，则生成的邻接表也不同。</li>\n<li><p>因此，对于同一张图，基于<strong>邻接矩阵</strong>的遍历得到的DFS序列和BFS序列是唯一的，基于<strong>邻接表</strong>的遍历得到的DFS序列和BFS序列是不唯一的。</p>\n</li>\n<li><p>空间复杂度为O(|V|)。</p>\n</li>\n<li>邻接表O(|V|+|E|)，邻接矩阵<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n<li>连通图-深度优先生成树，非连通图-深度优先生成森林。</li>\n<li>与BFS类似，基于邻接表存储的深度优先生成树是不唯一的。</li>\n</ul>\n<h4 id=\"图的遍历与图的连通性\"><a href=\"#图的遍历与图的连通性\" class=\"headerlink\" title=\"图的遍历与图的连通性\"></a>图的遍历与图的连通性</h4><ul>\n<li><strong>图的遍历算法可以用来判断图的连通性。</strong></li>\n<li>对于有向图来说，若从初始顶点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。</li>\n</ul>\n<h3 id=\"图的基本应用（包括）\"><a href=\"#图的基本应用（包括）\" class=\"headerlink\" title=\"图的基本应用（包括）\"></a>图的基本应用（包括）</h3><h4 id=\"最小支撑树（最小生成树）\"><a href=\"#最小支撑树（最小生成树）\" class=\"headerlink\" title=\"最小支撑树（最小生成树）\"></a>最小支撑树（最小生成树）</h4><ul>\n<li>一个连通图的<strong>生成树</strong>包含图的所有顶点，并且只含尽可能少的边。</li>\n<li>对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路。</li>\n<li>对于<strong>带权连通无向图</strong>G，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。权值之和最小的那棵生成树称为G的<strong>最小生成树</strong>。</li>\n<li>①若图G存在权值相同的边，则G的最小生成树<strong>可能</strong>不唯一；②当G中的各边权值互不相等时，G的最小生成树是唯一的；③若无向连通图G的边数比顶点数少一，即G本身是一棵树时，则G的最小生成树就是它本身。</li>\n<li>虽然最小生成树（树形）不唯一，但其对应的边的权值之和总是唯一的，而且是最小的。</li>\n<li>最小生成树的边数为顶点数-1。</li>\n<li><strong>注意：</strong>最小生成树中所有边的权值之和最小，但不能保证任意两个顶点之间的路径是最短路径。</li>\n</ul>\n<p>Prim和Kruskal都基于贪心算法。</p>\n<ul>\n<li><p><strong>Prim算法</strong></p>\n<blockquote>\n<p>（记忆：PV (Prim vertices)，经常写博客会注重page view）</p>\n</blockquote>\n</li>\n<li><p>假设<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G=(V,T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span></span></span></span>是连通图，其最小生成树<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>U</mi><mo separator=\"true\">,</mo><msub><mi>E</mi><mi>T</mi></msub><mo stretchy=\"false\">)</mo><mtext>，</mtext><msub><mi>E</mi><mi>T</mi></msub></mrow><annotation encoding=\"application/x-tex\">T=(U,E_T)，E_T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>是最小生成树中边的集合。</p>\n</li>\n<li>初始化：向空树<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>U</mi><mo separator=\"true\">,</mo><msub><mi>E</mi><mi>T</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T=(U,E_T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>中添加图<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G=(V,E)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span>的任意一个顶点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>u</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">u_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，使<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>=</mo><msub><mi>u</mi><mn>0</mn></msub><mtext>，</mtext><msub><mi>E</mi><mi>T</mi></msub><mo>=</mo><mtext>Ø</mtext></mrow><annotation encoding=\"application/x-tex\">U={u_0}，E_T=Ø</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">，</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7806em;vertical-align:-0.0486em;\"></span><span class=\"mord\">Ø</span></span></span></span>。</li>\n<li>循环（重复下列操作直至<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>=</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">U=V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>：从图G中选择满足<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∣</mi><mi>u</mi><mo>∈</mo><mi>U</mi><mo separator=\"true\">,</mo><mi>v</mi><mo>∈</mo><mi>V</mi><mo>−</mo><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">{(u,v)|u∈U, v∈V-U}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span></span>且具有最小权值的边(u,v)，加入树T，置<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>=</mo><mi>U</mi><mo>∪</mo><mi>v</mi><mtext>，</mtext><msub><mi>E</mi><mi>T</mi></msub><mo>=</mo><msub><mi>E</mi><mi>T</mi></msub><mo>∪</mo><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">U=U∪{v}，E_T=E_T∪{(u,v)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span><span class=\"mord cjk_fallback\">，</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span></span>。</li>\n<li><p>Prim算法的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，不依赖于|E|，因此它适用于求解<strong>边稠密</strong>的图的最小生成树。</p>\n</li>\n<li><p><strong>Kruskal算法</strong></p>\n</li>\n<li>假设<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G=(V,E)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span>是连通图，其最小生成树<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>U</mi><mo separator=\"true\">,</mo><msub><mi>E</mi><mi>T</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T=(U, E_T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>初始化：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>=</mo><mi>V</mi><mo separator=\"true\">,</mo><msub><mi>E</mi><mi>T</mi></msub><mo>=</mo><mtext>Ø</mtext></mrow><annotation encoding=\"application/x-tex\">U=V, E_T=Ø</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7806em;vertical-align:-0.0486em;\"></span><span class=\"mord\">Ø</span></span></span></span>。即每个顶点构成一棵独立的树，T此时是一个仅含|V|个顶点的森林。</li>\n<li>循环（重复直至T是一棵树）：按G的边的权值递增顺序依次从<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>−</mo><msub><mi>E</mi><mi>T</mi></msub></mrow><annotation encoding=\"application/x-tex\">E-E_T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>中选择一条边，若这条边加入T后不构成回路，则将其加入T后不构成回路，则将其加入<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>E</mi><mi>T</mi></msub></mrow><annotation encoding=\"application/x-tex\">E_T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，否则舍弃，直到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>E</mi><mi>T</mi></msub></mrow><annotation encoding=\"application/x-tex\">E_T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>中含有n-1条边。</li>\n<li>在Kruskal算法中，最坏情况需要对|E|条边各扫描一次。通常采用堆来存放边的集合，每次选择最小权值的边需要<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log_2|E|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span>的时间；每次使用并查集来快速判断两个顶点是否属于一个集合所需的时间为O(α(|V|))，α(|V|)的增长极其缓慢，可视为常数。</li>\n<li>算法的总时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|E|log_2|E|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span>，不依赖于|V|，因此Kruskal算法适合于<strong>边稀疏而顶点较多</strong>的图。</li>\n</ul>\n<h4 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h4><ul>\n<li><strong>Dijkstra算法</strong></li>\n<li>求单源最短路径问题</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">int</span> n, <span class=\"type\">const</span> vector&lt;vector&lt;Edge&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(n, INT_MAX)</span></span>; <span class=\"comment\">// 初始化所有节点的距离为无穷大</span></span><br><span class=\"line\">    dist[start] = <span class=\"number\">0</span>; <span class=\"comment\">// 起点到自己的距离为0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    priority_queue&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;, vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;, greater&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;&gt; pq;</span><br><span class=\"line\">    pq.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>, start&#125;); <span class=\"comment\">// 将起点加入优先队列</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!pq.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> [d, u] = pq.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        pq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (d &gt; dist[u]) <span class=\"keyword\">continue</span>; <span class=\"comment\">// 已有更短路径，跳过</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; edge : graph[u]) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> v = edge.to;</span><br><span class=\"line\">            <span class=\"type\">int</span> weight = edge.weight;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dist[u] + weight &lt; dist[v]) &#123;</span><br><span class=\"line\">                dist[v] = dist[u] + weight;</span><br><span class=\"line\">                pq.<span class=\"built_in\">push</span>(&#123;dist[v], v&#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dist;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用邻接矩阵表示时，时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。使用带权的邻接表表示时，虽然修改dist[]的时间可以减少，但由于在dist[]中选择最小分量的时间不变，所以时间复杂度仍为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>人们可能只希望找到从源点到某个特定顶点的最短路径，但这个问题和求解源点到其他所有顶点的最短路径一样复杂，时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>不适合负权。</li>\n</ul>\n<ul>\n<li><strong>BellmanFord算法</strong></li>\n</ul>\n<ol>\n<li>算法步骤<br>假设图中有 𝑉 个节点和 𝐸 条边，起点为 start，算法的主要步骤如下：<br>① <strong>初始化：</strong>将起点到自身的距离设为0，其他节点的初始距离设为无穷大（表示不可达）。<br>② <strong>松弛边：</strong>重复 𝑉−1 次，对所有边进行松弛操作。<ul>\n<li>对于每一条边 (u, v, weight)，如果 dist[u] + weight &lt; dist[v]，则更新 dist[v] = dist[u] + weight。</li>\n<li>之所以重复 𝑉−1 次，是因为最短路径最多包含 𝑉−1 条边，多余的边不会影响路径长度。<br>③ <strong>检测负环：</strong>在执行完𝑉−1 轮松弛操作后，再对所有边执行一次松弛操作。如果此时还能找到更短路径（即 dist[u] + weight &lt; dist[v] 依然成立），则说明图中存在负权回路（负环）。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">bellmanFord</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> start, <span class=\"type\">const</span> vector&lt;Edge&gt;&amp; edges, vector&lt;<span class=\"type\">int</span>&gt;&amp; dist)</span> </span>&#123;</span><br><span class=\"line\">    dist.<span class=\"built_in\">assign</span>(n, INT_MAX);</span><br><span class=\"line\">    dist[start] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进行 n-1 次松弛操作</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; edge : edges) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dist[edge.from] != INT_MAX &amp;&amp; dist[edge.from] + edge.weight &lt; dist[edge.to]) &#123;</span><br><span class=\"line\">                dist[edge.to] = dist[edge.from] + edge.weight;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 检测负环</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; edge : edges) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dist[edge.from] != INT_MAX &amp;&amp; dist[edge.from] + edge.weight &lt; dist[edge.to]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 存在负环</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 没有负环</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用于求单源最短路径，支持带负权边的图。Bellman-Ford的时间复杂度为O(V×E)，可以检测负权回路（负环）。<br>适合稀疏图：在稀疏图中（边数较少的图），Bellman-Ford的效率较高，但在稠密图中效率不如Floyd-Warshall。</p>\n<ul>\n<li><strong>Floyd算法</strong></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> INF = INT_MAX;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">floydWarshall</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; dist)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; n; ++k) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dist[i][k] != INF &amp;&amp; dist[k][j] != INF) &#123;</span><br><span class=\"line\">                    dist[i][j] = <span class=\"built_in\">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用于求解任意两点之间的最短路径。该算法的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，适用于较小规模的稠密图。</li>\n<li>Floyd算法允许出现带负权值的边，但是不允许有包含<strong>带负权值的边</strong>组成的<strong>回路</strong>。</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>Dijkstra：快速且适合无负权边的单源最短路径。<br>Floyd-Warshall：适合小规模图的任意两点最短路径，但无法处理负环。<br>Bellman-Ford：支持负权边且能检测负环，适合较低效率需求的单源最短路径。</p>\n<ol>\n<li><p><strong>Bellman-Ford算法</strong><br><strong>回路检测能力：</strong>Bellman-Ford可以检测<strong>负权回路（负环）</strong>。在执行完 𝑉−1 轮松弛操作后，如果还能进一步松弛，说明图中存在负权回路。<br><strong>适用场景：</strong>当我们需要检测负权回路，或者在存在负权边的图中寻找单源最短路径时，Bellman-Ford非常适用。</p>\n<blockquote>\n<p><strong>①Bellman-Ford算法能算出负权回路的最小路径吗？</strong><br><strong>不能算出负权回路的最小路径：</strong>Bellman-Ford算法确实只能检测到负权回路的存在，但无法求出包含负权回路的最小路径。<br><strong>为什么无法求出最小路径：</strong>因为负权回路的性质是可以让路径不断缩短——随着每次通过负权回路，路径权重会持续降低。因此，如果图中存在负权回路，任意包含该回路的路径长度可以趋近负无穷大。<br><strong>结论：</strong>一旦图中有负权回路，Bellman-Ford就无法得到正确的最短路径，只能返回一个错误标志，提示“图中存在负权回路”。<br><strong>②带负权回路的图是否能求最小路径？</strong><br><strong>带负权回路的图整体上不能求最小路径：</strong>如果图中有负权回路，且这个回路能够从起点达到（即负权回路在从起点到某个节点的路径中），则不存在“最短路径”，因为我们可以沿着负权回路无限循环，让路径长度趋向负无穷。<br><strong>局部求解：</strong>如果负权回路在图中的某个孤立部分，并不影响起点到其他节点的路径，则在受影响的节点之外，我们仍然可以使用Bellman-Ford求出正确的最短路径。但一般情况下，一旦存在负权回路就难以求得全局最短路径。</p>\n</blockquote>\n</li>\n<li><p><strong>Dijkstra算法</strong><br><strong>回路检测能力：</strong>Dijkstra不能检测回路，也无法正确处理负权边。<br><strong>适用场景：</strong>主要用于无负权边的图的单源最短路径问题。</p>\n<blockquote>\n<p><strong>①Dijkstra是不是连普通的回路都不能检测？</strong><br><strong>Dijkstra无法检测回路：</strong>Dijkstra算法的设计初衷是用于求解无负权边的单源最短路径，因此它不具备回路检测能力。<br><strong>为什么无法检测回路：</strong>Dijkstra假设路径是单调递增的，因此一旦确定某个节点的最短路径后，它不会再访问该节点，也不会追踪是否形成回路。这种设计避免了多次访问同一节点，但也因此放弃了回路检测的能力。<br><strong>结论：</strong>Dijkstra既不能检测负权回路，也不能检测普通回路。<br><strong>②为什么Dijkstra不能正确处理负权边？</strong><br><strong>Dijkstra的贪心策略依赖非负权边</strong>，一旦节点的最短路径确定，它不会再更改。如果存在负权边，后续路径可能提供更短的路径，贪心策略就被破坏。<br><strong>负权边破坏了路径长度递增的假设</strong>，Dijkstra没有更新已确定最短路径的机制，因此最终结果可能不正确。</p>\n</blockquote>\n</li>\n<li><p><strong>Floyd-Warshall算法</strong><br><strong>回路检测能力：</strong>Floyd-Warshall不直接检测回路，但可以在结果矩阵中检测到负权回路。<br><strong>方法：</strong>如果在计算过程中发现 dist[i][i] &lt; 0（即一个节点到自身的最短路径为负值），则说明存在负权回路。<br><strong>适用场景：</strong>适用于较小规模的图，可以同时解决任意两点的最短路径问题。</p>\n<blockquote>\n<p><strong>注：</strong>利用dist[i][i] &lt; 0条件不一定能判出存在“带有负权值的边组成的回路”<strong>（但负环的定义是跑一圈是负数）</strong>，因为比如某个负环走一圈仍是正的，如图所示。</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"/articles/9eb01842/Floyd判负环.png\" width=50% height=70% /></p>\n<ol>\n<li><strong>BFS算法</strong><br><strong>回路检测能力：</strong>在无向图和有向图中，BFS都可以检测到回路。<br><strong>无向图：</strong>如果在遍历过程中遇到一个已经访问过的邻居节点，且该邻居节点不是当前节点的父节点，则存在回路。<br><strong>有向图：</strong>如果在遍历过程中遇到一个已经在当前访问路径中的节点（即一个祖先节点），则存在回路。<br><strong>适用场景：</strong>主要用于无权图中的最短路径和环检测，尤其在广度优先搜索遍历时很适用。</li>\n</ol>\n<blockquote>\n<p>BFS算法可以算边权相同情况下的最短路径。</p>\n</blockquote>\n<p><strong>使用BFS检测无向图中的回路</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">bfsCycle</span><span class=\"params\">(<span class=\"type\">int</span> start, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph, vector&lt;<span class=\"type\">int</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class=\"line\">    queue&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; q;</span><br><span class=\"line\">    visited[start] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(&#123;start, <span class=\"number\">-1</span>&#125;); <span class=\"comment\">// 存储节点和父节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> node = q.<span class=\"built_in\">front</span>().first;</span><br><span class=\"line\">        <span class=\"type\">int</span> parent = q.<span class=\"built_in\">front</span>().second;</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> neighbor : graph[node]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[neighbor]) &#123;</span><br><span class=\"line\">                visited[neighbor] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(&#123;neighbor, node&#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (neighbor != parent) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 找到回路</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[i] &amp;&amp; <span class=\"built_in\">bfsCycle</span>(i, graph, visited)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">4</span>;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; graph = &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;,  <span class=\"comment\">// 节点 0 -&gt; 节点 1 和 节点 2</span></span><br><span class=\"line\">        &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>&#125;,  <span class=\"comment\">// 节点 1 -&gt; 节点 0 和 节点 2</span></span><br><span class=\"line\">        &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>&#125;,  <span class=\"comment\">// 节点 2 -&gt; 节点 0, 节点 1 和 节点 3</span></span><br><span class=\"line\">        &#123;<span class=\"number\">2</span>&#125;     <span class=\"comment\">// 节点 3 -&gt; 节点 2</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">hasCycle</span>(graph, n)) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;图中存在回路&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;图中不存在回路&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li><strong>DFS算法</strong><br><strong>回路检测能力：</strong>DFS同样可以检测回路，是一种常用的回路检测方法。<br><strong>无向图：</strong>如果在遍历过程中遇到一个已经访问过的邻居节点，且该邻居节点不是当前节点的父节点，则存在回路。<br><strong>有向图：</strong>DFS通过维护一个访问状态数组来检测环。在遍历过程中，如果遇到一个正在访问的节点（即当前路径中的祖先节点），则存在回路。<br><strong>适用场景：</strong>DFS广泛用于图遍历和回路检测，包括拓扑排序、检测强连通分量等。</li>\n</ol>\n<blockquote>\n<p>DFS算法不能求最短路径。</p>\n</blockquote>\n<p><strong>使用DFS检测有向图中的回路</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> node, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph, vector&lt;<span class=\"type\">int</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class=\"line\">    visited[node] = <span class=\"number\">1</span>; <span class=\"comment\">// 标记当前节点正在访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> neighbor : graph[node]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[neighbor] == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 未访问过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">dfs</span>(neighbor, graph, visited)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 找到环</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (visited[neighbor] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 遇到正在访问的节点，说明存在回路</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    visited[node] = <span class=\"number\">2</span>; <span class=\"comment\">// 标记当前节点已访问完毕</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// 0-未访问, 1-正在访问, 2-已访问完毕</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[i] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">dfs</span>(i, graph, visited)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">4</span>; <span class=\"comment\">// 节点数</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; graph = &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">1</span>&#125;,      <span class=\"comment\">// 节点 0 -&gt; 节点 1</span></span><br><span class=\"line\">        &#123;<span class=\"number\">2</span>&#125;,      <span class=\"comment\">// 节点 1 -&gt; 节点 2</span></span><br><span class=\"line\">        &#123;<span class=\"number\">0</span>, <span class=\"number\">3</span>&#125;,   <span class=\"comment\">// 节点 2 -&gt; 节点 0 和 节点 3</span></span><br><span class=\"line\">        &#123;&#125;        <span class=\"comment\">// 节点 3 没有相邻节点</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">hasCycle</span>(graph, n)) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;图中存在回路&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;图中不存在回路&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><img src=\"/articles/9eb01842/最短路径总结表格.jpg\" width=100% height=70% /></p>\n<h4 id=\"有向无环图描述表达式（考点无）\"><a href=\"#有向无环图描述表达式（考点无）\" class=\"headerlink\" title=\"有向无环图描述表达式（考点无）\"></a>有向无环图描述表达式（考点无）</h4><p>王道p246<br>在二叉树描述表达式的基础上，实现对相同子式的共享，从而节省存储空间。</p>\n<h4 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h4><ul>\n<li><strong>AOV网：</strong>若用有向无环图（DAG）表示一个工程，其顶点表示活动，用有向边<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><msub><mi>V</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>V</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;V_i,V_j&gt;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span>表示活动<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>必须先于活动<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>进行的这样一种关系，则将这种有向图称为<strong>顶点表示活动的网络</strong>，简称<strong>AOV网</strong>。</li>\n<li>任何活动<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>不能以它自己作为自己的前驱或后继。</li>\n<li><p><strong>拓扑排序：</strong>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：</p>\n<ol>\n<li>每个顶点出现且仅出现一次。</li>\n<li>若顶点A在序列中排在顶点B的前面，则在图中不存在从B到A的路径。<br>或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中B出现在A的后面。每个AOV网都有一个或多个拓扑排序序列。</li>\n</ol>\n</li>\n<li><p>对一个AOV网进行拓扑排序的算法有很多，下面介绍比较常见的一种方法的步骤：</p>\n<ol>\n<li>从AOV网中选择一个没有前驱（入度为0）的顶点并输出。</li>\n<li>从网中删除该顶点和所有以它为起点的有向边。</li>\n<li>重复1和2直到当前的AOV网为空或<strong>当前网中不存在无前驱的顶点</strong>为止，<strong>后一种情况说明有向图中必然存在环</strong>。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">topologicalSort</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">inDegree</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;  <span class=\"comment\">// 入度数组</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">adj</span>(n);  <span class=\"comment\">// 邻接表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建邻接表并计算每个结点的入度</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; edge : edges) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u = edge[<span class=\"number\">0</span>], v = edge[<span class=\"number\">1</span>];</span><br><span class=\"line\">        adj[u].<span class=\"built_in\">push_back</span>(v);</span><br><span class=\"line\">        inDegree[v]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    <span class=\"comment\">// 将入度为 0 的结点入队</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inDegree[i] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; topoOrder;  <span class=\"comment\">// 存储拓扑排序结果</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        topoOrder.<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历当前结点的邻接结点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> v : adj[u]) &#123;</span><br><span class=\"line\">            inDegree[v]--;  <span class=\"comment\">// 将相邻结点的入度减 1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (inDegree[v] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果拓扑排序结果中的结点数不等于总结点数，说明图中有环</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (topoOrder.<span class=\"built_in\">size</span>() != n) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;图中存在环，无法进行拓扑排序&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> topoOrder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>时间复杂度：邻接矩阵<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，邻接表<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|+|E|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span>。</p>\n</li>\n<li><p>DFS的方式：</p>\n<ol>\n<li>若u是v的祖先，则在调用DFS访问u之前，必然已对v进行了DFS访问，即v的DFS结束时间先于u的DFS结束时间。从而可以考虑在DFS函数中设置一个时间标记，在DFS调用结束时，对各顶点计时。因此，祖先的结束时间必然大于子孙的结束时间。</li>\n<li>若u是v的子孙，则v为u的祖先，按上述思路，v的结束时间大于u的结束时间。</li>\n<li>若u和v没有路径关系，则u和v在拓扑序列的关系任意。</li>\n<li>最后按照结束时间从大到小排列，就可以得到一个拓扑排序序列。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> node, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; adj, vector&lt;<span class=\"type\">bool</span>&gt;&amp; visited, vector&lt;<span class=\"type\">int</span>&gt;&amp; finishTime, <span class=\"type\">int</span>&amp; time)</span> </span>&#123;</span><br><span class=\"line\">    visited[node] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 递归访问所有未访问的邻接结点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> neighbor : adj[node]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[neighbor]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(neighbor, adj, visited, finishTime, time);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当前结点的所有邻接结点访问完成后，记录完成时间</span></span><br><span class=\"line\">    finishTime[node] = time++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">topologicalSort</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">adj</span>(n);      <span class=\"comment\">// 邻接表</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(n, <span class=\"literal\">false</span>)</span></span>;  <span class=\"comment\">// 访问标记</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">finishTime</span><span class=\"params\">(n)</span></span>;       <span class=\"comment\">// 记录每个结点的完成时间</span></span><br><span class=\"line\">    <span class=\"type\">int</span> time = <span class=\"number\">0</span>;                    <span class=\"comment\">// 时间计数器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建邻接表</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; edge : edges) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u = edge[<span class=\"number\">0</span>], v = edge[<span class=\"number\">1</span>];</span><br><span class=\"line\">        adj[u].<span class=\"built_in\">push_back</span>(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对所有未访问的结点进行 DFS，并记录完成时间</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[i]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(i, adj, visited, finishTime, time);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据完成时间对结点进行排序，完成时间大的在前</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">topoOrder</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        topoOrder[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(topoOrder.<span class=\"built_in\">begin</span>(), topoOrder.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"type\">int</span> a, <span class=\"type\">int</span> b) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> finishTime[a] &gt; finishTime[b];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> topoOrder;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">6</span>;  <span class=\"comment\">// 结点数</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; edges = &#123;&#123;<span class=\"number\">5</span>, <span class=\"number\">2</span>&#125;, &#123;<span class=\"number\">5</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">4</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">4</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;, &#123;<span class=\"number\">3</span>, <span class=\"number\">1</span>&#125;&#125;;  <span class=\"comment\">// 边</span></span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; result = <span class=\"built_in\">topologicalSort</span>(n, edges);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;拓扑排序结果: &quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> node : result) &#123;</span><br><span class=\"line\">        cout &lt;&lt; node &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>对一个AOV网，若采用下列步骤进行排序，则称之为<strong>逆拓扑排序</strong>：</p>\n<ol>\n<li>从AOV网中选择一个没有后继（出度为0）的顶点并输出/</li>\n<li>从网中删除该顶点和所有以它为终点的有向边。</li>\n<li>重复1和2直到当前的AOV网为空。</li>\n</ol>\n</li>\n<li><p>用拓扑排序算法处理AOV网时，应注意以下问题：</p>\n<ol>\n<li>入度为0的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续。</li>\n<li>若一个顶点有多个直接后继，则拓扑排序的结果通常不唯一；但若各个顶点已经排在一个线性有序的序列中，每个顶点有唯一的前驱后继关系，则拓扑排序的结果是唯一的。</li>\n<li>由于AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵；但对一般的图来说，<strong>若其邻接矩阵是三角矩阵，则存在拓扑序列；反之不一定成立</strong>。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p><strong>什么条件下会存在多条拓扑路径？</strong><br>大致可以归纳为：</p>\n<ol>\n<li>存在多个入度为零的结点。</li>\n<li>图中的结点之间没有完全的依赖关系。</li>\n</ol>\n</blockquote>\n<h4 id=\"关键路径\"><a href=\"#关键路径\" class=\"headerlink\" title=\"关键路径\"></a>关键路径</h4><ul>\n<li><strong>AOE网：</strong>在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为<strong>用边表示活动的网络</strong>，简称<strong>AOE网</strong>。</li>\n<li>AOE网和AOV网都是有向无环图，不同之处在于它们的边和顶点所代表的的含义是不同的，AOE网中的边有权值，而AOV网中的边无权值，仅表示顶点之间的前后关系。</li>\n<li>AOE网具有以下两个性质：<ol>\n<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</li>\n<li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。<br>在AOE网中仅有一个入度为0的顶点，称为<strong>开始顶点（源点）</strong>，它表示整个工程的开始；也仅有一个出度为0的顶点，称为<strong>结束顶点（汇点）</strong>，它表示整个工程的结束。</li>\n</ol>\n</li>\n<li>在AOE网中，有些活动时可以并行进行的。从源点到汇点的有向路径可能有多条，并且这些路径长度可能不同。完成不同路径上的活动所需的时间虽然不同，但是只有所有路径上的活动都已完成，整个工程才能算结束。因此，从源点到汇点的所有路径中，<strong>具有最大路径长度的路径</strong>称为<strong>关键路径</strong>，而把<strong>关键路径上的活动</strong>称为<strong>关键活动</strong>。</li>\n<li>完成整个工程的<strong>最短时间</strong>就是<strong>关键路径的长度</strong>，即<strong>关键路径上各活动花费开销的总和</strong>。这是因为关键活动影响了整个工程的时间，即若关键活动不能按时完成，则整个工程的完成时间就会延长。因此，只要找到了关键活动，就找到了关键路径，也就可以得出最短完成时间。</li>\n</ul>\n<p><strong>事件</strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的<strong>最早</strong>发生时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_e(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></p>\n<ul>\n<li>它是指从源点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>到顶点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的<strong>最长</strong>路径长度。</li>\n<li>事件<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的最早发生时间决定了所有从<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>开始的活动能够开工的最早时间。</li>\n<li>可用下面的递推公式来计算（用拓扑排序）：<ol>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mtext>源点</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">v_e(\\text{源点})=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">源点</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">{</mo><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mi>j</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>k</mi></msub><mtext>为</mtext><msub><mi>v</mi><mi>j</mi></msub><mtext>的任意后继，</mtext><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mi>j</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mtext>表示</mtext><mo>&lt;</mo><msub><mi>v</mi><mi>j</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>k</mi></msub><mo>&gt;</mo><mtext>上的权值</mtext></mrow><annotation encoding=\"application/x-tex\">v_e(k)=Max\\{v_e(j)+Weight(v_j,v_k)\\},v_k\\text{为}v_j\\text{的任意后继，}Weight(v_j,v_k)\\text{表示}&lt;v_j,v_k&gt;\\text{上的权值}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">为</span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">的任意后继，</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">表示</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8252em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">上的权值</span></span></span></span></span>\n</li>\n</ol>\n</li>\n</ul>\n<p><strong>事件</strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的<strong>最迟</strong>发生时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_l(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></p>\n<ul>\n<li>它是指在<strong>不推迟整个工程完成</strong>的前提下，即保证它的后继事件<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7167em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>在其最迟发生事件<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_l(j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span>能够发生时，该事件最迟必须发生的时间。</li>\n<li>可用下面的递推公式来计算（用逆拓扑排序）：<ol>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mtext>汇点</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mtext>汇点</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_l(\\text{汇点})=v_e(\\text{汇点})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">汇点</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">汇点</span></span><span class=\"mclose\">)</span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">{</mo><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>−</mo><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mi>k</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>k</mi></msub><mtext>为</mtext><msub><mi>v</mi><mi>j</mi></msub><mtext>的任意前驱</mtext></mrow><annotation encoding=\"application/x-tex\">v_l(k)=Min\\{v_l(j)-Weight(v_k,v_j)\\},v_k\\text{为}v_j\\text{的任意前驱}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\">in</span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">为</span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">的任意前驱</span></span></span></span></span>\n</li>\n</ol>\n</li>\n</ul>\n<p><strong>活动</strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的<strong>最早</strong>开始时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">e(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span></p>\n<ul>\n<li>它是指该活动弧的起点所表示的事件的最早发生时间。若边<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>k</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;v_k,v_j&gt;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8252em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span>表示活动<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，则有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">e(i)=v_e(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<p><strong>活动</strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的<strong>最迟</strong>开始时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">l(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span></p>\n<ul>\n<li>它是指该活动弧的终点所表示时间的最迟发生时间与该活动所需时间之差。若边<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>k</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;v_k,v_j&gt;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8252em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span>表示活动<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，则有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>−</mo><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mi>k</mi></msub><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">l(i)=v_l(j)-Weight(v_k,v_j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<p>一个<strong>活动</strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的<strong>最迟</strong>开始时间l(i)和其<strong>最早</strong>开始时间e(i)的差额d(i)=l(i)-e(i)</p>\n<ul>\n<li>它是指该活动完成的时间余量，即在不增加完成整个工程所需总时间的情况下，活动<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>可以拖延的时间。若一个活动的时间余量为0，则说明该活动必须要如期完成，否则会拖延整个工程的进度。</li>\n<li>所以称l(i)=e(i)的活动<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>是关键活动。</li>\n</ul>\n<p><strong>求关键路径的算法</strong>步骤如下：</p>\n<ol>\n<li><p>从源点出发，令<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mtext>源点</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">v_e(\\text{源点})=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">源点</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>，按拓扑有序求其余顶点的最早发生时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_e()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<blockquote>\n<p>最早发生时间即为前面的任务要全部完成了才能做这个任务<br>如果是选择题，在这一步就可以得出关键路径。（具有最大路径长度的路径）</p>\n</blockquote>\n</li>\n<li><p>从汇点出发，令<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mtext>汇点</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mtext>汇点</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_l(汇点)=v_e(汇点)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord cjk_fallback\">汇点</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord cjk_fallback\">汇点</span><span class=\"mclose\">)</span></span></span></span>，按逆拓扑有序求其余顶点的最迟发生时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_l()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<blockquote>\n<p>最迟发生时间即为该事件再不发生，后续任务就得推迟进行了。</p>\n</blockquote>\n</li>\n<li><p>根据各顶点的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_e()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>值求所有弧的最早开始时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">e()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<blockquote>\n<p>弧的起点的最早开始时间<br>记住，<strong>早</strong>找前面，因为要前面全部完成任务。</p>\n</blockquote>\n</li>\n<li><p>根据各顶点的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>l</mi></msub><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_l()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>值求所有弧的最迟开始时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">l()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<blockquote>\n<p>弧的终点的最迟开始时间-弧的权值<br>记住，<strong>迟</strong>找后面，因为要后面不被这边拖进度。</p>\n</blockquote>\n</li>\n<li><p>求AOE网中所有活动的差额d()，找出所有d()=0的活动构成关键路径。</p>\n</li>\n</ol>\n<blockquote>\n<p>对于<strong>关键路径</strong>，需要<strong>注意</strong>以下几点：</p>\n<ol>\n<li>关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可以通过加快关键活动来缩短整个工程的工期。但也<strong>不能任意缩短关键活动</strong>，因为一旦缩短到一定的程度，该关键活动就可能变成非关键活动。</li>\n<li>网中的关键路径并不一定唯一，且对于有几条路径的网，<strong>只提高一条</strong>关键路径上的关键活动速度<strong>并不能缩短</strong>整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。</li>\n</ol>\n</blockquote>\n<h4 id=\"不同存储结构时各种图算法的时间复杂度\"><a href=\"#不同存储结构时各种图算法的时间复杂度\" class=\"headerlink\" title=\"不同存储结构时各种图算法的时间复杂度\"></a>不同存储结构时各种图算法的时间复杂度</h4><p><img src=\"/articles/9eb01842/不同存储结构时间复杂度总结.jpg\" width=100% height=70% /></p>\n<h2 id=\"七、查找\"><a href=\"#七、查找\" class=\"headerlink\" title=\"七、查找\"></a>七、查找</h2><blockquote>\n<p>查找的定义和与查找有关的算法：顺序查找法、折半查找法、散列（Hash）技术。</p>\n</blockquote>\n<h3 id=\"理解查找的定义\"><a href=\"#理解查找的定义\" class=\"headerlink\" title=\"理解查找的定义\"></a>理解查找的定义</h3><ol>\n<li>查找。在数据集合中寻找满足某种条件的数据元素的过程称为<strong>查找</strong>。</li>\n<li>在数据集合中找了满足条件的数据元素为<strong>查找成功</strong>，否则为<strong>查找失败</strong>。</li>\n<li>用于查找的数据集合为<strong>查找表</strong>，它是由同一类型的数据元素（或记录）组成的。对查找表的<strong>常见操作</strong>有：① 查询符合条件的数据元素；② 插入、删除数据元素。</li>\n<li>静态查找表。若一个查找表的操作只涉及查找操作，则无须动态地修改查找表，此类查找表称为<strong>静态查找表</strong>。与此对应，需要动态地插入或删除的查找表称为<strong>动态查找表</strong>。适合静态查找表的<strong>查找方法</strong>有顺序查找、折半查找、散列查找等；适合动态查找表的<strong>查找方法</strong>有二叉排序树的查找、散列查找等。</li>\n<li>关键字。数据元素中的唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在有一个学生元素构成的数据集合中，学生元素中“学号”这一数据项的值唯一地标识一名学生。</li>\n<li>平均查找长度。在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>P</mi><mi>i</mi></msub><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">ASL=\\sum\\limits_{i=1}^{n}P_i C_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. 式中，n是查找表的长度（因为每一个元素都要查找，所有都得考虑进去），Pi是查找第i个数据元素的概率，<strong>一般认为每个数据元素的查找概率相等</strong>，即Pi=1/n；Ci是找到第i个数据元素所需进行的<strong>比较次数</strong>。平均查找长度是<strong>衡量算法效率</strong>的<strong>最主要</strong>指标。</li>\n<li><strong>有序线性表</strong>的<strong>顺序查找</strong>中的线性表可以是<strong>链式存储结构</strong>，而<strong>折半查找</strong>中的线性表只能是顺序存储结构。</li>\n</ol>\n<h3 id=\"衡量查找算法的一些指标：三个查找长度\"><a href=\"#衡量查找算法的一些指标：三个查找长度\" class=\"headerlink\" title=\"衡量查找算法的一些指标：三个查找长度\"></a>衡量查找算法的一些指标：三个查找长度</h3><h4 id=\"顺序查找法\"><a href=\"#顺序查找法\" class=\"headerlink\" title=\"顺序查找法\"></a>顺序查找法</h4><ul>\n<li><strong>一般无序线性表</strong><blockquote>\n<p>从后往前找，a[0]=x作为哨兵，若查找不成功，说明是从n比较到0都没找到，即比较了n+1次。</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>平均查找长度（成功不成功都计入，每个概率为1/2n）<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mn>3</mn><mn>4</mn></mfrac><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ASL=\\frac{1}{2n}\\sum\\limits_{i=1}^{n}(n-1+1)+\\frac{1}{2}(n+1)=\\frac{3}{4}(n+1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>成功查找的（平均）查找长度  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>P</mi><mi>i</mi></msub><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">ASL=\\sum\\limits_{i=1}^{n}P_i C_i= \\frac{1}{n} \\sum\\limits_{i=1}^{n} (n-i+1)=\\frac{n+1}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3291em;vertical-align:-0.9777em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3514em;\"><span style=\"top:-2.1223em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\">∑</span></span></span><span style=\"top:-3.95em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9777em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></li>\n<li>不成功查找的（平均）查找长度  ASL=n+1</li>\n</ol>\n<ul>\n<li><strong>有序线性表</strong></li>\n</ul>\n<ol>\n<li>平均查找长度</li>\n<li>成功查找的（平均）查找长度<br>有序的结果和一般线性表的顺序查找一样，<strong>但是！！！要注意！！！这里的查找顺序若是从前往后，就不是和上面一样的结果！！！</strong></li>\n<li>不成功查找的（平均）查找长度<blockquote>\n<p>表L是按关键字从小到大排列的，查找的顺序是从前往后。假设有n个结点（这些是查找成功的结点），虚构n+1个查找失败结点。Pi为1/(n+1)，1,2,…,n,n为查找失败时的比较次数。</p>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>n</mi><mo>+</mo><mi>n</mi></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi>n</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">ASL=\\frac{1+2+\\cdots+n+n}{n+1}=\\frac{n}{2}+\\frac{n}{n+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2484em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span><span class=\"mbin mtight\">+</span><span class=\"minner mtight\">⋯</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0404em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6954em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0987em;vertical-align:-0.4033em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6954em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li><strong>分块查找（索引顺序查找）</strong></li>\n</ul>\n<p>它吸取了<strong>顺序查找</strong>和<strong>折半查找</strong>各自的优点，既有动态结构，又适用于快速查找。</p>\n<ol>\n<li>在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；</li>\n<li>在块内顺序查找。</li>\n</ol>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><msub><mi>L</mi><mi>I</mi></msub><mo stretchy=\"false\">(</mo><mtext>索引查找</mtext><mo stretchy=\"false\">)</mo><mo>+</mo><msub><mi>L</mi><mi>S</mi></msub><mo stretchy=\"false\">(</mo><mtext>块内查找</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mrow><mi>b</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo>+</mo><mfrac><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><msup><mi>s</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>s</mi><mo>+</mo><mi>n</mi></mrow><mrow><mn>2</mn><mi>s</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">ASL=L_I(\\text{索引查找})+L_S(\\text{块内查找})=\\frac{b+1}{2}+\\frac{s+1}{2}=\\frac{s^2+2s+n}{2s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">索引查找</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">块内查找</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2251em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3629em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0179em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">s</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">s</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>（在块内和索引均采用顺序查找）\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>若</mtext><mi>s</mi><mo>=</mo><msqrt><mi>n</mi></msqrt><mtext>，则平均查找长度取最小值</mtext><msqrt><mi>n</mi></msqrt><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\text{若}s=\\sqrt{n}\\text{，则平均查找长度取最小值}\\sqrt{n}+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">若</span></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.2397em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8003em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-2.7603em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2397em;\"><span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">，则平均查找长度取最小值</span></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8003em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-2.7603em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2397em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>\n<h4 id=\"折半查找法（二分查找）\"><a href=\"#折半查找法（二分查找）\" class=\"headerlink\" title=\"折半查找法（二分查找）\"></a>折半查找法（二分查找）</h4><ol>\n<li>平均查找长度</li>\n<li><p>成功查找的（平均）查找长度</p>\n<blockquote>\n<p>等概率，Pi为1/n。树上的每个结点都要考虑进去，每个结点的比较次数为它的层数。第一层次数为1（层高），有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup><mtext>（</mtext><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup><mtext>）</mtext></mrow><annotation encoding=\"application/x-tex\">2^0（2^{j-1}）</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8247em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">（</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">）</span></span></span></span>个结点要计算；第二层次数为2（层高），有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mtext>（</mtext><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup><mtext>）</mtext></mrow><annotation encoding=\"application/x-tex\">2^1（2^{j-1}）</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8247em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">（</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">）</span></span></span></span>个结点要计算……直到最后一层，这里不一定是满二叉树，但就按照满二叉树近似计算了。</p>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo stretchy=\"false\">(</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>×</mo><mn>2</mn><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>h</mi><mo>×</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>−</mo><mn>1</mn><mo>≈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">ASL=\\frac{1}{n}(1×1+2×2+\\cdots+h×2^{h-1})=\\frac{n+1}{n}log_2(n+1)-1≈log_2(n+1)-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0991em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">h</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>\n<p>这里记一下最终结果！（因为不知道咋算出来的）<br>另外，h为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil log_2(n+1) \\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)⌉</span></span></span></span>.<br>所以折半查找的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log_2n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，平均情况下比顺序查找的效率高。</p>\n</blockquote>\n</li>\n<li><p>不成功查找的（平均）查找长度</p>\n<blockquote>\n<p>虚构出方形结点，挂到圆形结点的下方。如果查找失败，即为方形结点，但是次数是上面那个圆形结点的层数。比如二叉树第3层下面总共挂了4个方形结点，第4层挂了8个方形节点：<br>ASL=(3×4+4×8)/12=11/3</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"散列（Hash）查找法\"><a href=\"#散列（Hash）查找法\" class=\"headerlink\" title=\"散列（Hash）查找法\"></a>散列（Hash）查找法</h4><ol>\n<li>平均查找长度</li>\n<li>成功查找的（平均）查找长度</li>\n<li>不成功查找的（平均）查找长度<br>（见王道，直接看解析p341-03，p343-07）</li>\n</ol>\n<ul>\n<li><strong>执行步骤：</strong><br>初始化：Addr=Hash(key);</li>\n</ul>\n<ol>\n<li>检测查找表中地址为Addr的位置上是否有记录，若无记录，返回<strong>查找失败</strong>；若有记录（可能同义词放在这了），比较它与key的值，若相等，则返回<strong>查找成功</strong>标志，否则执行步骤2.</li>\n<li>用给定的处理冲突方法计算“下一个散列地址”，并把Addr置为此地址，转入步骤1.</li>\n</ol>\n<p><img src=\"/articles/9eb01842/散列查找分析.jpg\" width=70% /></p>\n<ul>\n<li>对同一组关键字，设定相同的散列函数，则不同的处理冲突的方法得到的散列表不同，它们的平均查找长度也不同，本例与采用拉链法的平均查找长度不同。</li>\n<li>从散列表的查找过程可见：<ol>\n<li>虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍然需要以平均查找长度作为衡量散列表的查找效率的度量。</li>\n<li>散列表的<strong>查找效率</strong>取决于三个因素：<strong>散列函数</strong>、<strong>处理冲突的方法</strong>和<strong>装填因子</strong>（见下）。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"掌握顺序查找法和折半查找法，并理解二者之间的异同点\"><a href=\"#掌握顺序查找法和折半查找法，并理解二者之间的异同点\" class=\"headerlink\" title=\"掌握顺序查找法和折半查找法，并理解二者之间的异同点\"></a>掌握顺序查找法和折半查找法，并理解二者之间的异同点</h3><ul>\n<li>顺序查找适用于任何情况，但效率较低，特别是对于大量数据时。</li>\n<li>折半查找效率较高，但前提是数据必须有序。</li>\n</ul>\n<h3 id=\"掌握散列技术（包括）\"><a href=\"#掌握散列技术（包括）\" class=\"headerlink\" title=\"掌握散列技术（包括）\"></a>掌握散列技术（包括）</h3><h4 id=\"散列函数（哈希函数）\"><a href=\"#散列函数（哈希函数）\" class=\"headerlink\" title=\"散列函数（哈希函数）\"></a>散列函数（哈希函数）</h4><ul>\n<li>一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr（这里的地址可以是数组下标、索引或内存地址等）。</li>\n<li><p>散列函数可能会把两个或两个以上的关键字映射到同一地址，称这种情况为<strong>冲突</strong>，这些发成冲突的不同关键字称为<strong>同义词</strong>。</p>\n<ol>\n<li>一方面，设计得好的散列函数应尽量减少这样的冲突；</li>\n<li>另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。</li>\n</ol>\n</li>\n<li><p><strong>在构造散列函数时</strong>，必须<strong>注意</strong>以下几点：</p>\n</li>\n</ul>\n<ol>\n<li>散列函数的定义域必须包含全部关键字，而值域的范围则依赖于散列表的大小。</li>\n<li>散列函数计算出的地址应尽可能均匀地分布在整个地址空间，尽可能地减少冲突。</li>\n<li>散列函数应尽量简单，能在较短的时间内计算出一个关键字对应的散列地址。</li>\n</ol>\n<ul>\n<li><strong>常见的散列函数</strong><ol>\n<li><strong>直接定址法</strong><ul>\n<li>直接取关键字的某个<strong>线性函数值</strong>（线性函数：f(x)=ax+b）为散列地址，散列函数为H(key)=key或H(key)=a×key+b.（a和b是常数）</li>\n<li>这种方法计算很简单，且不会产生冲突。它适合关键字的分布基本连续的情况；若关键字分布不连续，空位较多，则会造成存储空间的浪费。</li>\n</ul>\n</li>\n<li><strong>除留余数法</strong><ul>\n<li>这是一种最简单、最常用的方法，假定散列列表表长为m，取一个不大于m但最接近或等于m的质数p。散列函数为H(key)=key%p.</li>\n<li>除留余数法的关键是选好p，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任意一个地址，从而尽可能减少冲突的可能性。</li>\n</ul>\n</li>\n<li><strong>数字分析法</strong><ul>\n<li>设关键字r是进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时应<strong>选取数码分布较为均匀的若干位作为散列地址</strong>。</li>\n<li>这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。<blockquote>\n<p><strong>为什么选择分布较为均匀的位？</strong></p>\n<ol>\n<li><strong>均匀分布减少冲突：</strong>数码均匀分布意味着每个可能的散列地址都有相似的数字频率，这样每个地址的负载相对均匀，避免了某些地址被过多数字占用，减少了哈希冲突。</li>\n<li><strong>提高散列效率：</strong>通过选取均匀分布的位，可以使得散列算法对输入数据的敏感度更高，避免了一些特定位置的数字偏差影响整个散列过程。这使得数据能够更广泛地分布到散列表中，提高查询和插入效率。</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><strong>平方取中法</strong><ul>\n<li>取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。</li>\n<li>这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，<strong>适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数</strong>。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"散列表（哈希表）\"><a href=\"#散列表（哈希表）\" class=\"headerlink\" title=\"散列表（哈希表）\"></a>散列表（哈希表）</h4><ul>\n<li>根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。</li>\n<li>理想情况下，对散列表进行查找的时间复杂度为O(1)，即与表中元素的个数无关。</li>\n</ul>\n<h4 id=\"散列冲突的发生及其解决方法\"><a href=\"#散列冲突的发生及其解决方法\" class=\"headerlink\" title=\"散列冲突的发生及其解决方法\"></a>散列冲突的发生及其解决方法</h4><ol>\n<li><strong>开放定址法</strong></li>\n</ol>\n<ul>\n<li>所谓开放定址法，是指表中可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo>=</mo><mo stretchy=\"false\">(</mo><mi>H</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo>+</mo><msub><mi>d</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H_i=(H(key)+d_i)%m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n<li>式中，H(key)为散列函数；i=1,2,…,k(k≤m-1)；m表示散列表表长；di为增量序列。</li>\n<li><p>取定某一增量序列后，对应的处理方法就是确定的。通常有以下4种取法：<br>①<strong>线性探测法</strong>，又称<strong>线性探测再散列法</strong>。</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">d_i=1, 2, …, m-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>。它的特点是：冲突发生时，顺序查看表中下一个单元（探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。</li>\n<li>线性探测法可能使第i个散列地址的同义词存入第i+1个散列地址，这样本应存入第i+1个散列地址的元素就争夺第i+2个散列地址的元素的地址……从而造成大量元素在相邻的散列地址上<strong>聚集（或堆积）</strong>起来，大大降低了查找效率。</li>\n</ul>\n<p>②<strong>平方探测法</strong>，又称<strong>二次探测法</strong>。</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator=\"true\">,</mo><mo>−</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator=\"true\">,</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator=\"true\">,</mo><mo>−</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msup><mi>k</mi><mn>2</mn></msup><mo separator=\"true\">,</mo><mo>−</mo><msup><mi>k</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">d_i=1^2, -1^2, 2^2, -2^2, \\cdots, k^2, -k^2 </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>，其中k≤m/2，散列表长度m必须是一个可以表示成4k+3的素数。</li>\n<li>平方探测法是一种处理冲突的较好方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。</li>\n</ul>\n<p>③<strong>双散列法</strong>。</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mi>i</mi><mo>×</mo><mi>H</mi><mi>a</mi><mi>s</mi><msub><mi>h</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">d_i=i×Hash_2(key)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">s</span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">)</span></span></span></span>。需要使用两个散列函数，当通过第一个散列函数H(key)得到的地址发生冲突时，则利用第二个散列函数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>a</mi><mi>s</mi><msub><mi>h</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Hash_2(key)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">s</span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">)</span></span></span></span>计算该关键字的地址增量。具体散列函数：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo>=</mo><mo stretchy=\"false\">(</mo><mi>H</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>i</mi><mo>×</mo><mi>H</mi><mi>a</mi><mi>s</mi><msub><mi>h</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H_i=(H(key)+i×Hash_2(key))%m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">s</span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">))</span></span></span></span>。</li>\n<li>初始探测位置<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>=</mo><mi>H</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H_0=H(key)%m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">)</span></span></span></span>。i时冲突的次数，初始为0。</li>\n</ul>\n<p>④<strong>伪随机序列法</strong>。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mtext>伪随机数序列</mtext></mrow><annotation encoding=\"application/x-tex\">d_i=\\text{伪随机数序列}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">伪随机数序列</span></span></span></span></span>。</p>\n</li>\n</ul>\n<blockquote>\n<p>采用开放定址法时，不能随便物理删除表中已有元素，否则会截断其他同义词元素的查找路径。因此，要删除一个元素时，可以做一个删除标记，进行逻辑删除。<br>但这样做的副作用是：执行多次删除后，表面上看起来散列表很满，实际上有许多位置未利用。</p>\n</blockquote>\n<ol>\n<li><strong>拉链法（链接法，chaining）</strong></li>\n</ol>\n<ul>\n<li>为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。</li>\n<li>假设散列地址为i的同义词链表的头指针存放在散列表的第i个单元中，因而查找、插入和删除操作主要在同义词链中进行。<strong>拉链法适用于经常进行插入和删除的情况。</strong><br><img src=\"/articles/9eb01842/拉链法.jpg\" width=70% /></li>\n</ul>\n<h4 id=\"负载因子（装填因子）\"><a href=\"#负载因子（装填因子）\" class=\"headerlink\" title=\"负载因子（装填因子）\"></a>负载因子（装填因子）</h4><ul>\n<li>散列表的装填因子一般记为α，定义为一个表的装满程度，即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><mfrac><mtext>表中记录数n</mtext><mtext>散列表长度m</mtext></mfrac></mrow><annotation encoding=\"application/x-tex\">α=\\frac{\\text{表中记录数n}}{\\text{散列表长度m}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2173em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8723em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord cjk_fallback mtight\">散列表长度</span><span class=\"mord mtight\">m</span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord cjk_fallback mtight\">表中记录数</span><span class=\"mord mtight\">n</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></li>\n<li>散列表的<strong>平均查找长度</strong>依赖于散列表的<strong>装填因子α</strong>，而不直接依赖于n或m。</li>\n<li>直观地看，<strong>α越大</strong>，表示装填的记录越“满”，<strong>发生冲突的可能性越大</strong>；反之，发生冲突的可能性越小。</li>\n</ul>\n<h3 id=\"理解不同查找技术的优缺点\"><a href=\"#理解不同查找技术的优缺点\" class=\"headerlink\" title=\"理解不同查找技术的优缺点\"></a>理解不同查找技术的优缺点</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>查找技术</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>顺序查找</strong></td>\n<td>简单实现，适用于无序数据，空间需求少</td>\n<td>时间复杂度高，效率低</td>\n<td>数据量小，数据无序时</td>\n</tr>\n<tr>\n<td><strong>二分查找</strong></td>\n<td>查找效率高（O(log n)），适用于有序数据</td>\n<td>数据需要事先排序，复杂度较高</td>\n<td>数据已排序，查找效率要求较高</td>\n</tr>\n<tr>\n<td><strong>哈希查找</strong></td>\n<td>查找速度快（O(1)），适用于大规模数据</td>\n<td>哈希冲突，额外空间需求，不支持有序查找</td>\n<td>需要高效查找的场景，如缓存、字典等</td>\n</tr>\n<tr>\n<td><strong>平衡二叉树查找</strong></td>\n<td>查找、插入、删除效率高（O(log n)）</td>\n<td>实现复杂，空间开销较大</td>\n<td>动态数据集，需要有序数据</td>\n</tr>\n<tr>\n<td><strong>跳表查找</strong></td>\n<td>查找效率高，插入删除简单，支持有序查找</td>\n<td>空间开销大，较为复杂的实现</td>\n<td>动态数据集，支持范围查询和排序的场景</td>\n</tr>\n<tr>\n<td><strong>B树/B+树查找</strong></td>\n<td>高效磁盘查找，支持范围查询</td>\n<td>实现复杂，空间开销大</td>\n<td>数据库、文件系统等大数据量存储和查询场景</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"八、排序\"><a href=\"#八、排序\" class=\"headerlink\" title=\"八、排序\"></a>八、排序</h2><h3 id=\"排序的定义（包括）\"><a href=\"#排序的定义（包括）\" class=\"headerlink\" title=\"排序的定义（包括）\"></a>排序的定义（包括）</h3><p><img src=\"/articles/9eb01842/排序知识框架.jpg\" width=50% height=70% /></p>\n<ul>\n<li><strong>排序：</strong>就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。</li>\n<li><strong>输入：</strong>n个记录<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_1, R_2, \\cdots, R_n </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，对应的关键字为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>k</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>k</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">k_1, k_2, \\cdots, k_n </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。</li>\n<li><strong>输出：</strong>输入序列的一个重排<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>R</mi><mn>1</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><mo separator=\"true\">,</mo><msubsup><mi>R</mi><mn>2</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msubsup><mi>R</mi><mi>n</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup></mrow><annotation encoding=\"application/x-tex\">R_1&#x27;, R_2&#x27;, \\cdots, R_n&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4519em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4519em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.453em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span>，使得<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>k</mi><mn>1</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><mo>≤</mo><msubsup><mi>k</mi><mn>2</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><mo>≤</mo><mo>⋯</mo><mo>≤</mo><msubsup><mi>k</mi><mi>n</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup></mrow><annotation encoding=\"application/x-tex\">k_1&#x27; \\leq k_2&#x27; \\leq \\cdots \\leq k_n&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4519em;margin-left:-0.0315em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4519em;margin-left:-0.0315em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9989em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.453em;margin-left:-0.0315em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span> （其中“≤”可以换成其他的比较大小的符号）。</li>\n</ul>\n<h4 id=\"内排序\"><a href=\"#内排序\" class=\"headerlink\" title=\"内排序\"></a>内排序</h4><ul>\n<li>是指在排序期间元素全部存放在内存中的排序。</li>\n<li>一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。基数排序不基于比较操作。</li>\n</ul>\n<h4 id=\"外排序\"><a href=\"#外排序\" class=\"headerlink\" title=\"外排序\"></a>外排序</h4><ul>\n<li>是指在排序期间元素无法全部同时存放内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的顺序。</li>\n</ul>\n<h4 id=\"内排序和外排序的区别\"><a href=\"#内排序和外排序的区别\" class=\"headerlink\" title=\"内排序和外排序的区别\"></a>内排序和外排序的区别</h4><ol>\n<li>在排序过程中，数据元素是否完全存放在内存中；</li>\n<li></li>\n</ol>\n<h4 id=\"排序的稳定性\"><a href=\"#排序的稳定性\" class=\"headerlink\" title=\"排序的稳定性\"></a>排序的稳定性</h4><ul>\n<li>若待排序表中有两个元素<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mtext>和</mtext><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_i\\text{和}R_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">和</span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>，其对应的关键字相同，即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mi>e</mi><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mi>e</mi><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">key_i=key_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">e</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">e</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>，且在排序前<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mtext>在</mtext><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_i\\text{在}R_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">在</span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>的前面，若使用某一排序算法排序后，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>仍然在<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>的前面，则称这个排序算法是<strong>稳定的</strong>，否则称这个排序算法是<strong>不稳定的</strong>。</li>\n</ul>\n<h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><ul>\n<li>假设前L[1…i-1]有序，后L[i+1…n]无序。（初始L[1]可以视为一个已排好序的子序列）</li>\n</ul>\n<ol>\n<li>查找出L(i)在L[1…i-1]中的插入位置k。</li>\n<li>将L[k…i-1]中的所有元素依次后移一个位置。</li>\n<li>将L(i)复制到L(k)。</li>\n</ol>\n<ul>\n<li>空间复杂度：O(1)，时间复杂度：最好O(n)，最坏<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，平均总比较次数和总移动次数均约为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><msup><mi>n</mi><mn>2</mn></msup><mn>4</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n^2}{4}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.3629em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0179em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>，因此平均<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>稳定性：稳定。</li>\n<li>适用性：顺序存储和链式存储的线性表，采用链式存储时无须移动元素。</li>\n</ul>\n<h3 id=\"折半插入排序（考点没写）\"><a href=\"#折半插入排序（考点没写）\" class=\"headerlink\" title=\"折半插入排序（考点没写）\"></a>折半插入排序（考点没写）</h3><ul>\n<li>在直接插入排序的基础上，将寻找插入位置k的方式改成折半查找，移动部分不变。</li>\n<li>时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>。对于数据量不是很大的顺序表，折半排序往往表现出很好的性能。</li>\n<li>稳定。</li>\n<li>仅使用于顺序存储的线性表。</li>\n</ul>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li>空间：O(1)</li>\n<li>时间：最好情况（第一遍flag判定有序，移动0，比较一轮）O(n)；最坏情况（逆序，n-1轮）比较次数=n(n-1)/2，移动次数=3n(n-1)/2，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>；平均<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>稳定。</li>\n<li>适用于顺序存储和链式存储的线性表。</li>\n</ul>\n<h3 id=\"简单选择排序\"><a href=\"#简单选择排序\" class=\"headerlink\" title=\"简单选择排序\"></a>简单选择排序</h3><ul>\n<li>空间：O(1)</li>\n<li>时间：移动次数不会超过3(n-1)，最好情况0，比较次数始终是n(n-1)/2，时间复杂度始终是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>不稳定。</li>\n<li>适用于顺序存储和链式存储的线性表，以及关键字较少的情况。</li>\n</ul>\n<h3 id=\"Shell排序\"><a href=\"#Shell排序\" class=\"headerlink\" title=\"Shell排序\"></a>Shell排序</h3><ul>\n<li>是对直接插入排序的改进，又称<strong>缩小增量排序</strong>。</li>\n<li>过程：<ol>\n<li>先取一个小于n的增量d1，把表中的全部记录分成d1组，<strong>所有距离为d1的倍数的记录放在同一组</strong>，在各组内进行直接插入排序；</li>\n<li>取第二个增量d2 &lt; d1，重复1；</li>\n<li>直到所取到的dt=1，再进行直接插入排序。由于此时已经具有较好的局部有序性，因此可以很快得到最终结果。（直接插入排序适用于基本有序和数据量不大的排序表）</li>\n</ol>\n</li>\n<li>到目前为止，尚未求得一个最好的增量序列。</li>\n</ul>\n<p><img src=\"/articles/9eb01842/希尔排序.jpg\" width=80% height=70% /></p>\n<ul>\n<li>空间O(1)</li>\n<li>时间：因为希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难。当n在某个特定范围时，希尔排序的时间复杂度约为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>1</mn></msup><mi mathvariant=\"normal\">.</mi><mn>3</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^1.3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mord\">.3</span><span class=\"mclose\">)</span></span></span></span>。在最坏情况下希尔排序的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>不稳定。（相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序）</li>\n<li>适用于顺序存储的线性表。</li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><p>① <strong>初始化</strong></p>\n<ol>\n<li>对以第⌊n/2⌋个结点（完全二叉树最后一个结点的双亲）为根的子树筛选，使该子树成为堆。</li>\n<li>向前依次对各结点（⌊n/2⌋-1~1）为根的子树进行筛选，看该结点值是否大于其左右结点的值，若不大于，则将左右子结点的较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。</li>\n<li>反复利用上述调整堆的方法建堆，直到根结点。</li>\n</ol>\n<p><img src=\"/articles/9eb01842/堆排序.jpg\" width=80% height=70% /></p>\n<p>② <strong>输出堆顶元素后调整堆</strong></p>\n<ol>\n<li>输出堆顶元素后，将堆的最后一个元素与堆顶元素交换，此时堆的性质备破坏，需要向下进行筛选。</li>\n</ol>\n<p><img src=\"/articles/9eb01842/堆排序_2.jpg\" width=80% height=70% /></p>\n<p>③<strong>再输出堆顶元素，如此重复，直到堆中只剩一个元素为止。</strong></p>\n<ul>\n<li>堆排序适合关键字较多的情况。例如，在1亿个数中选出<strong>前100个最大值</strong>。首先适用一个大小为100的数组，读入前100个数，建立小顶堆，而后依次读入余下的数，若小于堆顶则舍弃，否则用该数取代堆顶并重新调整堆，待数据读取完毕，堆中100个数为所求。</li>\n<li>空间O(1)</li>\n<li>时间：建堆O(n)，每次调整O(h)，最好、最坏、平均都是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlog_2n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>不稳定。</li>\n<li>仅适用于顺序存储的线性表。</li>\n</ul>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><h3 id=\"时空复杂度和稳定性\"><a href=\"#时空复杂度和稳定性\" class=\"headerlink\" title=\"时空复杂度和稳定性\"></a>时空复杂度和稳定性</h3><blockquote>\n<p>对直接插入排序、冒泡排序、简单选择排序、Shell排序、快速排序、堆排序、归并排序、基数排序这些算法，掌握其在时间复杂度、空间复杂度以及是否稳定等方面的特点</p>\n</blockquote>\n<h3 id=\"K路归并排序\"><a href=\"#K路归并排序\" class=\"headerlink\" title=\"K路归并排序\"></a>K路归并排序</h3><h4 id=\"k路归并排序的外排序算法\"><a href=\"#k路归并排序的外排序算法\" class=\"headerlink\" title=\"k路归并排序的外排序算法\"></a>k路归并排序的外排序算法</h4><h3 id=\"选择合适排序算法\"><a href=\"#选择合适排序算法\" class=\"headerlink\" title=\"选择合适排序算法\"></a>选择合适排序算法</h3><blockquote>\n<p>具有在不同的应用需求下，能够依据各种排序算法的特点选择合适排序算法的能力</p>\n</blockquote>\n<h2 id=\"九、矩阵和串\"><a href=\"#九、矩阵和串\" class=\"headerlink\" title=\"九、矩阵和串\"></a>九、矩阵和串</h2><h3 id=\"矩阵和串的定义\"><a href=\"#矩阵和串的定义\" class=\"headerlink\" title=\"矩阵和串的定义\"></a>矩阵和串的定义</h3><blockquote>\n<p>数组定义-王道p104</p>\n</blockquote>\n<p><strong>矩阵：</strong>矩阵是一个由 m 行 n 列元素组成的二维数组，通常表示为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{m×n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8917em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">×</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span>，其中 m 是矩阵的行数，n 是矩阵的列数。</p>\n<h3 id=\"特殊矩阵的压缩存储\"><a href=\"#特殊矩阵的压缩存储\" class=\"headerlink\" title=\"特殊矩阵的压缩存储\"></a>特殊矩阵的压缩存储</h3><h3 id=\"稀疏矩阵的三元组表示法以及相应的操作\"><a href=\"#稀疏矩阵的三元组表示法以及相应的操作\" class=\"headerlink\" title=\"稀疏矩阵的三元组表示法以及相应的操作\"></a>稀疏矩阵的三元组表示法以及相应的操作</h3><h3 id=\"多维数组和一维数组的映射\"><a href=\"#多维数组和一维数组的映射\" class=\"headerlink\" title=\"多维数组和一维数组的映射\"></a>多维数组和一维数组的映射</h3><h3 id=\"串的模式匹配\"><a href=\"#串的模式匹配\" class=\"headerlink\" title=\"串的模式匹配\"></a>串的模式匹配</h3><h4 id=\"Brute-Force\"><a href=\"#Brute-Force\" class=\"headerlink\" title=\"Brute-Force\"></a>Brute-Force</h4><h4 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h4>","categories":[],"tags":[]}