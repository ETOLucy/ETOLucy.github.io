{"title":"PPT-考研操作系统","slug":"PPT-考研操作系统","date":"2025-03-08T06:52:46.000Z","updated":"2025-03-08T13:55:03.212Z","comments":true,"path":"api/articles/PPT-考研操作系统.json","excerpt":null,"covers":["/articles/c94444f9/模块化OS结构.png","/articles/c94444f9/C-S模式.png","/articles/c94444f9/并发执行的前趋图.png","/articles/c94444f9/进程的三种基本状态及其转换.png","/articles/c94444f9/具有挂起状态的进程状态图.png"],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"第一章-操作系统引论\"><a href=\"#第一章-操作系统引论\" class=\"headerlink\" title=\"第一章  操作系统引论\"></a>第一章  操作系统引论</h1><h2 id=\"操作系统的目标和作用\"><a href=\"#操作系统的目标和作用\" class=\"headerlink\" title=\"操作系统的目标和作用\"></a>操作系统的目标和作用</h2><h3 id=\"OS的作用\"><a href=\"#OS的作用\" class=\"headerlink\" title=\"OS的作用\"></a>OS的作用</h3><ol>\n<li><strong>OS是用户与计算机硬件系统之间的接口</strong></li>\n<li><strong>OS是计算机系统资源的管理者</strong><blockquote>\n<p>在一个计算机系统中，通常都含有各种各样的硬件和软件资源。归纳起来可将资源分为四类：**处理器、存储器、 I&#x2F;O设备以及信息(数据和程序)**。相应地，OS的主要功能也正是针对这四类资源进行有效的管理，即：处理机管理， 用于分配和控制处理机；存储器管理，主要负责内存的分配与回收；I&#x2F;O设备管理，负责I&#x2F;O设备的分配与操纵；文件管理，负责文件的存取、共享和保护。可见，OS确是计算机系统资源的管理者。事实上，当今世界上广为流行的一个关于OS作用的观点，正是把OS作为计算机系统的资源管理者。</p>\n</blockquote>\n</li>\n<li><strong>OS用作扩充机器</strong></li>\n</ol>\n<h3 id=\"系统调用：\"><a href=\"#系统调用：\" class=\"headerlink\" title=\"系统调用：\"></a><strong>系统调用：</strong></h3><ul>\n<li>操作系统将计算机的资源（如CPU、内存、硬盘等）划分为两个空间：用户空间和内核空间。用户程序运行在用户空间，而操作系统的核心部分（内核）运行在内核空间。为了安全和稳定，用户程序不能直接访问内核空间，必须通过系统调用来请求内核服务。</li>\n</ul>\n<h2 id=\"操作系统的发展过程\"><a href=\"#操作系统的发展过程\" class=\"headerlink\" title=\"操作系统的发展过程\"></a>操作系统的发展过程</h2><h3 id=\"无操作系统的计算机系统\"><a href=\"#无操作系统的计算机系统\" class=\"headerlink\" title=\"无操作系统的计算机系统\"></a><strong>无操作系统</strong>的计算机系统</h3><ol>\n<li>人工操作方式（穿孔纸带）</li>\n</ol>\n<ul>\n<li>(1) 用户独占全机。(2) CPU等待人工操作。</li>\n</ul>\n<ol start=\"2\">\n<li>脱机输入&#x2F;输出方式</li>\n</ol>\n<ul>\n<li>(1) 减少了CPU的空闲时间。(2) 提高I&#x2F;O速度。</li>\n</ul>\n<h3 id=\"单道批处理系统\"><a href=\"#单道批处理系统\" class=\"headerlink\" title=\"单道批处理系统\"></a>单道批处理系统</h3><ul>\n<li>(1) 自动性。(2) 顺序性。(3) 单道性。</li>\n</ul>\n<h3 id=\"多道批处理系统\"><a href=\"#多道批处理系统\" class=\"headerlink\" title=\"多道批处理系统\"></a>多道批处理系统</h3><ul>\n<li>(1) 提高CPU的利用率。(2) 可提高 [内存和I&#x2F;O设备] 利用率。(3) 增加系统吞吐量。<blockquote>\n<p><strong>CPU利用率</strong>和<strong>系统吞吐量</strong>的关系<br>高CPU利用率并不一定带来高吞吐量。例如，如果CPU一直在处理低效的任务，CPU利用率可能很高，但吞吐量却很低。<br>高吞吐量通常需要较高的CPU利用率，但也受到其他系统资源的限制。</p>\n</blockquote>\n</li>\n<li>(1) 多道性。(2) 无序性。(3) 调度性。</li>\n<li>(1)资源利用率高。(2) 系统吞吐量大。(3) 平均周转时间长。(4) 无交互能力。 </li>\n<li>需要解决：(1) 处理机管理问题。(2) 内存管理问题。(3) I&#x2F;O设备管理问题。(4) 文件管理问题。(5) 作业管理问题。</li>\n</ul>\n<h3 id=\"分时系统\"><a href=\"#分时系统\" class=\"headerlink\" title=\"分时系统\"></a>分时系统</h3><ul>\n<li>计算机将CPU时间分成许多时间片，然后轮流分配给各个用户，由于切换速度很快，用户感觉就像独占计算机一样。</li>\n<li>(1) 多路性。(2) 独立性。(3) 及时性。(4) 交互性。</li>\n</ul>\n<h3 id=\"实时系统\"><a href=\"#实时系统\" class=\"headerlink\" title=\"实时系统\"></a>实时系统</h3><ul>\n<li>所谓“实时”，是表示“及时”，而实时系统(Real-Time System)是指系统能及时(或即时)响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</li>\n</ul>\n<p><strong>周期性实时任务</strong></p>\n<ul>\n<li><strong>定义：</strong> 任务以固定的时间间隔重复执行。</li>\n<li><strong>例子：</strong><ul>\n<li><strong>汽车防抱死系统（ABS）：</strong> 定期检测车轮速度，调整制动压力。</li>\n<li><strong>工业自动化控制：</strong> 定期采样传感器数据，控制执行器。</li>\n<li><strong>多媒体播放：</strong> 定期刷新屏幕，播放音频&#x2F;视频帧。</li>\n<li><strong>雷达系统：</strong> 定期扫描指定区域。</li>\n</ul>\n</li>\n</ul>\n<p><strong>非周期性实时任务</strong></p>\n<ul>\n<li><strong>定义：</strong> 任务的执行时间不固定，由外部事件触发。</li>\n<li><strong>例子：</strong><ul>\n<li><strong>飞机紧急制动系统：</strong> 在检测到紧急情况时立即启动。</li>\n<li><strong>医疗监护仪：</strong> 在检测到病人异常生理指标时发出警报。</li>\n<li><strong>网络数据包处理：</strong> 在接收到网络数据包时进行处理。</li>\n<li><strong>用户点击鼠标：</strong> 在用户点击鼠标时进行响应。</li>\n</ul>\n</li>\n</ul>\n<p><strong>硬实时任务</strong></p>\n<ul>\n<li><strong>定义：</strong> 任务必须在严格的时间限制内完成，否则会导致灾难性后果。</li>\n<li><strong>例子：</strong><ul>\n<li><strong>飞行控制系统：</strong> 任何延迟都可能导致飞机失控。</li>\n<li><strong>核电站控制系统：</strong> 任何延迟都可能导致核泄漏。</li>\n<li><strong>导弹制导系统：</strong> 任何延迟都可能导致目标丢失。</li>\n<li><strong>汽车安全气囊系统：</strong> 在碰撞发生后，必须在极短的时间内展开。</li>\n</ul>\n</li>\n</ul>\n<p><strong>软实时任务</strong></p>\n<ul>\n<li><strong>定义：</strong> 任务尽可能在时间限制内完成，但偶尔的延迟是可以接受的。</li>\n<li><strong>例子：</strong><ul>\n<li><strong>多媒体播放：</strong> 偶尔的丢帧或卡顿不会导致严重后果。</li>\n<li><strong>网络游戏：</strong> 偶尔的网络延迟会影响游戏体验，但不会导致游戏崩溃。</li>\n<li><strong>视频会议：</strong> 偶尔的音频&#x2F;视频延迟是可以接受的。</li>\n<li><strong>实时股票行情显示：</strong> 偶尔的延迟是可以接受的。</li>\n</ul>\n</li>\n</ul>\n<p><strong>总结</strong></p>\n<ul>\n<li>周期性和非周期性是根据任务的执行频率来划分的。</li>\n<li>硬实时和软实时是根据任务对时间限制的严格程度来划分的。</li>\n<li>实际应用中，一个任务可能同时具有多种属性，例如，汽车ABS系统既是周期性任务，又是硬实时任务。</li>\n</ul>\n<h2 id=\"操作系统的基本特性\"><a href=\"#操作系统的基本特性\" class=\"headerlink\" title=\"操作系统的基本特性\"></a>操作系统的基本特性</h2><h3 id=\"并发-Concurrency\"><a href=\"#并发-Concurrency\" class=\"headerlink\" title=\"并发 (Concurrency)\"></a>并发 (Concurrency)</h3><ul>\n<li><strong>定义:</strong> 指两个或多个事件在同一时间间隔内发生。</li>\n</ul>\n<h3 id=\"共享-Sharing\"><a href=\"#共享-Sharing\" class=\"headerlink\" title=\"共享 (Sharing)\"></a>共享 (Sharing)</h3><ul>\n<li><strong>定义:</strong> 指系统中的资源可以被多个程序或用户共同使用。</li>\n<li><strong>在操作系统中:</strong> 资源可以是硬件（如CPU、内存、磁盘）或软件（如文件、数据）。</li>\n<li>(1) 互斥共享方式 (2) 同时访问方式</li>\n</ul>\n<h3 id=\"虚拟-Virtualization\"><a href=\"#虚拟-Virtualization\" class=\"headerlink\" title=\"虚拟 (Virtualization)\"></a>虚拟 (Virtualization)</h3><ul>\n<li><strong>定义:</strong> 指通过技术手段将一个物理实体转化为多个逻辑实体，或者将多个物理实体转化为一个逻辑实体。</li>\n<li><strong>在操作系统中:</strong><ul>\n<li>虚拟内存：将物理内存扩展为更大的逻辑地址空间。</li>\n<li>虚拟CPU：通过时间片轮转，使每个程序都感觉拥有独立的CPU。</li>\n</ul>\n</li>\n<li><strong>关键点:</strong> 强调的是资源的逻辑抽象，这提高了资源的灵活性和效率。</li>\n</ul>\n<h3 id=\"异步-Asynchrony\"><a href=\"#异步-Asynchrony\" class=\"headerlink\" title=\"异步 (Asynchrony)\"></a>异步 (Asynchrony)</h3><ul>\n<li>由于资源等因素的限制，使进程的执行通常都不是“一气呵成”，而是以“停停走走”的方式运行。 </li>\n<li>进程是以人们不可预知的速度向前推进，此即进程的异步性。</li>\n<li>尽管如此，但只要运行环境相同，作业经多次运行，都会获得完全相同的结果。因此，异步运行方式是允许的，是操作系统的一个重要特征。</li>\n</ul>\n<p>这四个概念是操作系统中非常重要的基本特征，它们共同构成了现代操作系统的基础。</p>\n<h2 id=\"操作系统的主要功能\"><a href=\"#操作系统的主要功能\" class=\"headerlink\" title=\"操作系统的主要功能\"></a>操作系统的主要功能</h2><h3 id=\"处理机管理功能\"><a href=\"#处理机管理功能\" class=\"headerlink\" title=\"处理机管理功能\"></a>处理机管理功能</h3><h4 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h4><ul>\n<li>主要功能是为作业<strong>创建进程</strong>、<strong>撤消已结束的进程</strong>，以及<strong>控制进程在运行过程中的状态转换</strong>。</li>\n</ul>\n<h4 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h4><ul>\n<li>进程同步的主要任务是为多个进程(含线程)的运行进行协调。</li>\n<li>有两种协调方式： <ol>\n<li>进程互斥方式， 这是指诸进程(线程)在对临界资源进行访问时， 应采用互斥方式； </li>\n<li>进程同步方式，指在相互合作去完成共同任务的诸进程(线程)间，由同步机制对它们的执行次序加以协调。</li>\n</ol>\n</li>\n<li>为了实现进程同步，系统中必须设置进程同步机制。最简单的用于实现进程互斥的机制，是为每一个<strong>临界资源</strong>配置一把<strong>锁W</strong>，当锁打开时，进程(线程)可以对该临界资源进行访问；而当锁关上时，则禁止进程(线程)访问该临界资源。</li>\n</ul>\n<h4 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h4><ul>\n<li>在多道程序环境下，为了加速应用程序的运行，应在系统中建立多个进程，并且再为一个进程建立若干个线程，由这些进程(线程)相互合作去完成一个共同的任务。而在这些进程(线程)之间，又往往需要交换信息。</li>\n<li>当相互合作的进程(线程)处于同一计算机系统时，通常在它们之前是采用直接通信方式，即由源进程利用发送命令直接将消息(message)挂到目标进程的消息队列上，以后由目标进程利用接收命令从其消息队列中取出消息。</li>\n</ul>\n<h4 id=\"调度\"><a href=\"#调度\" class=\"headerlink\" title=\"调度\"></a>调度</h4><ul>\n<li>在后备队列上等待的每个作业，通常都要经过调度才能执行。在传统的操作系统中，包括<strong>作业调度</strong>和<strong>进程调度</strong>两步。</li>\n<li><strong>作业调度</strong>的基本任务，是从后备队列中按照一定的算法，选择出若干个作业，为它们分配其必需的资源(首先是分配内存)。 在将它们调入内存后，便分别为它们建立进程，使它们都成为可能获得处理机的就绪进程，并按照一定的算法将它们插入就绪队列。</li>\n<li>而<strong>进程调度</strong>的任务，则是从进程的就绪队列中选出一新进程，把处理机分配给它，并为它设置运行现场， 使进程投入执行。</li>\n<li>值得提出的是，在<strong>多线程OS</strong>中，通常是把<strong>线程</strong>作为独立运行和分配处理机的<strong>基本单位</strong>，为此，须把就绪线程排成一个队列，每次调度时，是从就绪线程队列中选出一个线程，把处理机分配给它。</li>\n</ul>\n<h3 id=\"存储器管理功能\"><a href=\"#存储器管理功能\" class=\"headerlink\" title=\"存储器管理功能\"></a>存储器管理功能</h3><h4 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h4><ul>\n<li>分配方式：<ol>\n<li>静态分配</li>\n<li>动态分配</li>\n</ol>\n</li>\n<li>为了实现内存分配，在内存分配的机制中应具有这样的结构和功能：<ol>\n<li>内存分配数据结构，该结构用于记录内存空间的使用情况，作为内存分配的依据；</li>\n<li>内存分配功能，系统按照一定的内存分配算法，为用户程序分配内存空间；</li>\n<li>内存回收功能，系统对于用户不再需要的内存，通过用户的释放请求，去完成系统的回收功能。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"内存保护\"><a href=\"#内存保护\" class=\"headerlink\" title=\"内存保护\"></a>内存保护</h4><ul>\n<li><strong>主要任务</strong>是确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰。</li>\n<li>一种比较简单的<strong>内存保护机制</strong>，是设置<strong>两个界限寄存器</strong>，分别用于存放正在执行程序的上界和下界。</li>\n<li>系统须对每条指令所要访问的地址进行检查，如果发生越界，便发出越界中断请求，以停止该程序的执行。</li>\n<li>如果这种检查完全用软件实现，则每执行一条指令，便须增加若干条指令去进行越界检查，这将显著降低程序的运行速度。<strong>因此，越界检查都由硬件实现。</strong>当然，对发生越界后的处理，<strong>还须与软件配合来完成。</strong></li>\n</ul>\n<h4 id=\"地址映射\"><a href=\"#地址映射\" class=\"headerlink\" title=\"地址映射\"></a>地址映射</h4><ul>\n<li>地址映射是逻辑地址到物理地址的映射。</li>\n<li>为使程序能正确运行，存储器管理必须提供地址映射功能，以将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。该功能应在硬件的支持下完成。</li>\n</ul>\n<h4 id=\"内存扩充\"><a href=\"#内存扩充\" class=\"headerlink\" title=\"内存扩充\"></a>内存扩充</h4><ul>\n<li>借助<strong>虚拟存储技术</strong>，<strong>从逻辑上</strong>去扩充内存容量，使用户所感觉到的内存容量比实际内存容量大得多；或者是让更多的用户程序能并发运行。</li>\n<li>用于实现下述各功能：<br>(1) 请求调入功能。<br>(2) 置换功能。</li>\n</ul>\n<p><strong>1. 请求调入功能</strong></p>\n<ul>\n<li><strong>概念：</strong><ul>\n<li>当程序运行时，并非所有代码和数据都需要立即加载到物理内存中。</li>\n<li>请求调入功能允许操作系统只将当前需要的程序部分（例如，代码页或数据页）加载到内存中。</li>\n<li>当程序尝试访问不在内存中的部分时，会产生一个“缺页中断”，操作系统会响应这个中断，并将所需的部分从磁盘（或其他存储介质）加载到内存中。</li>\n</ul>\n</li>\n<li><strong>作用：</strong><ul>\n<li>提高内存利用率：只加载必要的部分，减少了内存的浪费。</li>\n<li>支持更大的程序：允许程序使用比物理内存更大的地址空间。</li>\n</ul>\n</li>\n</ul>\n<p><strong>2. 置换功能</strong></p>\n<ul>\n<li><strong>概念：</strong><ul>\n<li>当物理内存已满，而程序又需要加载新的部分时，操作系统必须腾出一些空间。</li>\n<li>置换功能负责选择哪些内存中的部分应该被移出到磁盘（或其他存储介质），以便为新的部分腾出空间。</li>\n<li><strong>置换算法（例如，LRU、FIFO）</strong>用于决定哪些部分应该被置换。</li>\n</ul>\n</li>\n<li><strong>作用：</strong><ul>\n<li>管理有限的物理内存：确保在内存不足时，系统能够继续运行。</li>\n<li>优化内存使用：通过合理的置换算法，尽量减少频繁的磁盘I&#x2F;O操作。</li>\n</ul>\n</li>\n</ul>\n<p><strong>总结</strong></p>\n<ul>\n<li>请求调入和置换是虚拟内存技术的关键组成部分。</li>\n<li>它们共同工作，使得程序可以使用比实际物理内存更大的地址空间，并提高了内存的利用率。</li>\n<li>虚拟内存是现代操作系统中至关重要的技术。</li>\n</ul>\n<h3 id=\"设备管理功能\"><a href=\"#设备管理功能\" class=\"headerlink\" title=\"设备管理功能\"></a>设备管理功能</h3><h4 id=\"缓冲管理\"><a href=\"#缓冲管理\" class=\"headerlink\" title=\"缓冲管理\"></a>缓冲管理</h4><ul>\n<li>如果在I&#x2F;O设备和CPU之间引入缓冲，则<strong>可有效地缓和CPU（高速）和I&#x2F;O设备速度（低速）不匹配的矛盾</strong>，提高CPU的利用率，进而提高系统吞吐量。 </li>\n<li>因此，<strong>在现代计算机系统中，</strong>都毫无例外地在内存中设置了缓冲区，而且还可通过增加缓冲区容量的方法，来改善系统的性能。</li>\n<li>最常见的缓冲区机制有单缓冲机制、能实现双向同时传送数据的双缓冲机制，以及能供多个设备同时使用的公用缓冲池机制。</li>\n</ul>\n<h4 id=\"设备分配\"><a href=\"#设备分配\" class=\"headerlink\" title=\"设备分配\"></a>设备分配</h4><ul>\n<li>根据用户进程的I&#x2F;O请求、系统的现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。</li>\n<li>如果在I&#x2F;O设备和CPU之间，还存在着设备控制器和I&#x2F;O通道时，还须为分配出去的设备分配相应的控制器和通道。</li>\n<li>系统中应设置设备控制表、控制器控制表等数据结构，用于记录设备及控制器的标识符和状态。据这些表格可以了解指定设备当前是否可用，是否忙碌，以供进行设备分配时参考。</li>\n<li>在进行设备分配时，应针对不同的设备类型而采用不同的设备分配方式。对于独占设备(临界资源)的分配，还应考虑到该设备被分配出去后，系统是否安全。设备使用完后，还应立即由系统回收。</li>\n</ul>\n<h4 id=\"设备处理\"><a href=\"#设备处理\" class=\"headerlink\" title=\"设备处理\"></a>设备处理</h4><ul>\n<li><strong>设备处理程序</strong>又称为<strong>设备驱动程序</strong>。</li>\n<li>其<strong>基本任务</strong>是用于实现CPU和设备控制器之间的通信，即由CPU向设备控制器发出I&#x2F;O命令，要求它完成指定的I&#x2F;O操作；反之由CPU接收从控制器发来的中断请求，并给予迅速的响应和相应的处理。</li>\n<li>处理过程是：<ol>\n<li>设备处理程序首先检查I&#x2F;O请求的合法性，了解设备状态是否是空闲的，了解有关的传递参数及设置设备的工作方式。</li>\n<li>然后，便向设备控制器发出I&#x2F;O命令，启动I&#x2F;O设备去完成指定的I&#x2F;O操作。</li>\n</ol>\n</li>\n<li>设备驱动程序还应能及时响应由控制器发来的中断请求，并根据该中断请求的类型，调用相应的中断处理程序进行处理。对于设置了通道的计算机系统， 设备处理程序还应能根据用户的I&#x2F;O请求，自动地构成通道程序。</li>\n</ul>\n<h4 id=\"虚拟设备\"><a href=\"#虚拟设备\" class=\"headerlink\" title=\"虚拟设备\"></a>虚拟设备</h4><blockquote>\n<p>（没介绍）</p>\n</blockquote>\n<h3 id=\"文件管理功能\"><a href=\"#文件管理功能\" class=\"headerlink\" title=\"文件管理功能\"></a>文件管理功能</h3><h4 id=\"文件存储空间的管理\"><a href=\"#文件存储空间的管理\" class=\"headerlink\" title=\"文件存储空间的管理\"></a>文件存储空间的管理</h4><ul>\n<li>为每个文件分配必要的外存空间，提高外存的利用率，并能有助于提高文件系统的运行速度。</li>\n<li>为此，系统<ol>\n<li>应设置相应的数据结构，用于记录文件存储空间的使用情况，以供分配存储空间时参考；</li>\n<li>还应具有对存储空间进行分配和回收的功能。</li>\n</ol>\n</li>\n<li>为了提高存储空间的利用率，对存储空间的分配，通常是采用离散分配方式，以减少外存零头，并以盘块为基本分配单位。盘块的大小通常为512 B~8 KB。</li>\n</ul>\n<h4 id=\"目录管理\"><a href=\"#目录管理\" class=\"headerlink\" title=\"目录管理\"></a>目录管理</h4><ul>\n<li>为了使用户能方便地在外存上找到自己所需的文件，通常由系统为每个文件建立一个目录项。</li>\n<li>目录项包括文件名、文件属性、文件在磁盘上的物理位置等。由若干个目录项又可构成一个目录文件。</li>\n<li>目录管理的<strong>主要任务</strong>， 是为每个文件建立其目录项，并对众多的目录项加以有效的组织，以实现方便的按名存取。即用户只须提供文件名，即可对该文件进行存取。其次，目录管理还应能实现文件共享，这样，只须在外存上保留一份该共享文件的副本。此外，还应能提供快速的目录查询手段，以提高对文件的检索速度。</li>\n</ul>\n<h4 id=\"文件的读-写管理和保护\"><a href=\"#文件的读-写管理和保护\" class=\"headerlink\" title=\"文件的读&#x2F;写管理和保护\"></a>文件的读&#x2F;写管理和保护</h4><ol>\n<li><strong>文件的读&#x2F;写管理。</strong>该功能是根据用户的请求，从外存中读取数据；或将数据写入外存。在进行文件读(写)时，系统先根据用户给出的文件名，去检索文件目录，从中获得文件在外存中的位置。然后，利用文件读(写)指针，对文件进行读(写)。一旦读(写)完成，便修改读(写)指针，为下一次读(写)做好准备。由于读和写操作不会同时进行，故可合用一个读&#x2F;写指针。</li>\n<li><strong>文件保护。</strong>① 防止未经核准的用户存取文件； ② 防止冒名顶替存取文件； ③ 防止以不正确的方式使用文件。</li>\n</ol>\n<h4 id=\"用户接口\"><a href=\"#用户接口\" class=\"headerlink\" title=\"用户接口\"></a>用户接口</h4><ol>\n<li>命令接口<br>  (1) 联机用户接口（终端或控制台）<br>  (2) 脱机用户接口（也称批处理用户接口）</li>\n<li>程序接口</li>\n</ol>\n<ul>\n<li>由一组系统调用组成，每一个系统调用都是一个能完成特定功能的子程序，每当应用程序要求OS提供某种服务(功能)时，便调用具有相应功能的系统调用。</li>\n</ul>\n<ol start=\"3\">\n<li>图形接口</li>\n</ol>\n<ul>\n<li>用户虽然可以通过联机用户接口来取得OS的服务，但这时要求用户能熟记各种命令的名字和格式，并严格按照规定的格式输入命令，这既不方便又花时间，于是，图形用户接口便应运而生。</li>\n<li>图形用户接口采用了图形化的操作界面， 用非常容易识别的各种图标(icon)来将系统的各项功能、各种应用程序和文件，直观、逼真地表示出来。用户可用鼠标或通过菜单和对话框，来完成对应用程序和文件的操作。</li>\n<li>此时用户已完全不必像使用命令接口那样去记住命令名及格式，从而把用户从繁琐且单调的操作中解脱出来。</li>\n</ul>\n<h2 id=\"操作系统的结构设计\"><a href=\"#操作系统的结构设计\" class=\"headerlink\" title=\"操作系统的结构设计\"></a>操作系统的结构设计</h2><h3 id=\"软件工程的基本概念\"><a href=\"#软件工程的基本概念\" class=\"headerlink\" title=\"软件工程的基本概念\"></a>软件工程的基本概念</h3><h4 id=\"软件的含义\"><a href=\"#软件的含义\" class=\"headerlink\" title=\"软件的含义\"></a>软件的含义</h4><ul>\n<li>所谓软件，是指<strong>当计算机运行时，能提供所要求的【功能和性能】的【指令和程序】的集合，该程序能够正确地处理信息的数据结构</strong>；作为规范软件，还应具有描述程序功能需求以及程序如何操作使用的文档。</li>\n<li>如果说，硬件是物理部件，那么，软件则是一种逻辑部件，它具有与硬件完全不同的特点。</li>\n</ul>\n<h4 id=\"软件工程的含义\"><a href=\"#软件工程的含义\" class=\"headerlink\" title=\"软件工程的含义\"></a>软件工程的含义</h4><ul>\n<li>软件工程是指运用【系统的、规范的和可定量】的方法，来【开发、运行和维护软件】；或者说，是采用工程的概念、原理、技术和方法，来开发与维护软件，其目的是为了解决在软件开发中所出现的编程随意、软件质量不可保证以及维护困难等问题。</li>\n</ul>\n<h3 id=\"传统的操作系统结构\"><a href=\"#传统的操作系统结构\" class=\"headerlink\" title=\"传统的操作系统结构\"></a>传统的操作系统结构</h3><ul>\n<li>操作系统是一个十分复杂的大型软件。为了控制该软件的复杂性，在开发OS时，先后引入了分解、模块化、 抽象和隐蔽等方法。开发方法的不断发展，促进了OS结构的更新换代。这里，我们把第一代至第三代的OS结构， 称为传统的OS结构，而把微内核的OS结构称为现代OS结构。</li>\n</ul>\n<h4 id=\"无结构操作系统\"><a href=\"#无结构操作系统\" class=\"headerlink\" title=\"无结构操作系统\"></a>无结构操作系统</h4><h4 id=\"模块化OS结构\"><a href=\"#模块化OS结构\" class=\"headerlink\" title=\"模块化OS结构\"></a>模块化OS结构</h4><ul>\n<li><p>每个模块具有某方面的管理功能，如进程管理模块、存储器管理模块、I&#x2F;O设备管理模块和文件管理模块等，并规定好各模块间的接口， 使各模块之间能通过该接口实现交互，然后再进一步将各模块细分为若干个具有一定管理功能的子模块，如把进程管理模块又分为进程控制、 进程同步、 进程通信和进程调度等子模块， 同样也要规定各子模块之间的接口。若子模块较大时，再进一步将它细分。</p>\n<img src=\"/articles/c94444f9/模块化OS结构.png\" width=70% height=70% />\n</li>\n<li><p>优点：</p>\n<ol>\n<li>提高了OS设计的正确性、可理解性和可维护性。 </li>\n<li>增强了OS的可适应性。 </li>\n<li>加速了OS的开发过程。</li>\n</ol>\n</li>\n<li><p>缺点：</p>\n<ol>\n<li>在开始设计OS时，对模块的划分及对接口的规定并不精确，而且还可能存在错误，因而很难保证按此规定所设计出的模块会完全正确，这将使在把这些模块装配成OS时发生困难；</li>\n<li>其次，从功能观点来划分模块时，未能将共享资源和独占资源加以区别；</li>\n<li>由于管理上的差异，又会使模块间存在着复杂的依赖关系使OS结构变得不清晰。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"分层式OS结构\"><a href=\"#分层式OS结构\" class=\"headerlink\" title=\"分层式OS结构\"></a>分层式OS结构</h4><ul>\n<li>分层式结构设计的基本原则是：每一层都仅使用其底层所提供的功能和服务，这样可使系统的调试和验证都变得容易。</li>\n<li>层次的设置：<ol>\n<li><p><strong>程序嵌套。</strong>通常OS的每个功能的实现，并非是只用一个程序便能完成的，而是要经由若干个软件层才有可能完成。因此在划分OS层次时，首先要考虑在实现OS 的每个功能时所形成的程序嵌套。例如，作业调度模块须调用进程控制模块；在为某作业创建一进程时，进程控制模块又须调用内存管理模块为新进程分配内存空间，可见，进程控制模块应在内存管理模块之上； 而作业调度模块又应在更高层。</p>\n</li>\n<li><p><strong>运行频率。</strong>在分层结构中，各层次软件的运行速度是不同的，因为A1层软件能直接在物理机器上运行，故它有最高的运行速度。随着层次的增高，其相应软件的运行速度就随之下降，因而An层软件的运行速度最低。为了提高OS的运行效率，应该将那些经常活跃的模块放在最接近硬件的A1层，如时钟管理、进程调度，通常都放在A1层。</p>\n</li>\n<li><p>公用模块。应把供多种资源管理程序调用的公用模块，设置在最低层，不然，会使比它低的层次模块由于无法调用它而须另外配置相应功能的模块。例如，用于对<strong>信号量</strong>进行操作<strong>的</strong>原语Signal和Wait。</p>\n<blockquote>\n<p>这里提到<strong>信号量（Semaphore）</strong>是因为它是操作系统中用于进程同步与互斥的重要机制。信号量操作（如 Signal 和 Wait）通常是多个资源管理模块都会用到的基本功能，因此应放置在系统的底层，作为公用模块提供服务。这样可以避免不同模块重复实现相同的功能，提高系统的结构合理性和资源利用效率。</p>\n</blockquote>\n</li>\n<li><p>用户接口。为方便用户(程序)，OS向用户提供了“用户与OS的接口”，如命令接口、程序接口以及图形用户接口。这些接口应设置在OS的最高层，直接提供给用户使用。</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"微内核OS结构\"><a href=\"#微内核OS结构\" class=\"headerlink\" title=\"微内核OS结构\"></a>微内核OS结构</h3><h4 id=\"客户-服务器模式-Client-Server-Model\"><a href=\"#客户-服务器模式-Client-Server-Model\" class=\"headerlink\" title=\"客户&#x2F;服务器模式(Client-Server Model)\"></a>客户&#x2F;服务器模式(Client-Server Model)</h4><ul>\n<li>为了提高OS的灵活性和可扩充性而将OS划分为两部分，一部分是<strong>用于提供各种服务的一组服务器(进程)<strong>，如用于提供进程管理的进程服务器、提供存储器管理的存储器服务器和提供文件管理的文件服务器等，所有这些服务器(进程)都运行在用户态。当有一</strong>用户进程(现在称为客户进程)<strong>要求读文件的一个盘块时，该进程便向文件服务器(进程)发出一个请求；当服务器完成了该客户的请求后，便给该客户回送一个响应。操作系统的另一部分是</strong>内核</strong>，<strong>用来处理客户和服务器之间的通信</strong>， 即由内核来接收客户的请求，再将该请求送至相应的服务器；同时它也接收服务器的应答，并将此应答回送给请求客户。此外，在内核中还应具有其它一些机构，用于实现与硬件紧密相关的和一些较基本的功能。<blockquote>\n<p>平时我们提到 <strong>“服务器”</strong> 往往指的是云端或远程计算机提供的服务。但<strong>在操作系统（OS）内部，“服务器”指的是运行在用户态的系统进程，专门提供某些操作系统功能的服务。</strong></p>\n</blockquote>\n</li>\n</ul>\n<img src=\"/articles/c94444f9/C-S模式.png\" width=\"70%\" height=\"70%\" />\n<p style=\"text-align: center;\">单机环境下的客户/服务器模式</p>\n\n<ul>\n<li>优点：<ol>\n<li>提高了系统的灵活性和可扩充性。 </li>\n<li>提高了OS的可靠性。 </li>\n<li>可运行于分布式系统中。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"面向对象的程序设计技术-Object-Orientated-Programming\"><a href=\"#面向对象的程序设计技术-Object-Orientated-Programming\" class=\"headerlink\" title=\"面向对象的程序设计技术(Object-Orientated Programming)\"></a>面向对象的程序设计技术(Object-Orientated Programming)</h4><ul>\n<li><strong>面向对象技术的基本概念</strong><br>面向对象技术是20世纪80年代初提出并很快流行起来的。该技术是基于“抽象”和“隐蔽”原则来控制大型软件的复杂度的。所谓对象，是指在现实世界中具有相同属性、服从相同规则的一系列事物的抽象，而把其中的具体事物称为对象的实例。OS中的各类实体如进程、线程、消息、存储器等，都使用了对象这一概念，相应地，便有进程对象线程对象、 存储器对象等。 </li>\n<li><strong>优点</strong><ol>\n<li><strong>可修改性和可扩充性。</strong>由于隐蔽了表示实体的数据和操作，因而可以改变对象的表示而不会影响其它部分， 从而可以方便地改变老的对象和增加新的对象。</li>\n<li><strong>继承性。</strong>继承性是面向对象技术所具有的重要特性。继承性是指子对象可以继承父对象的属性，这样，在创建一个新的对象时， 便可减少大量的时空开销。</li>\n<li><strong>正确性和可靠性。</strong>由于对象是构成操作系统的基本单元，可以独立地对它进行测试，这样，比较易于保证其正确性和可靠性，从而比较容易保证整个系统的正确性和可靠性。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"微内核技术\"><a href=\"#微内核技术\" class=\"headerlink\" title=\"微内核技术\"></a>微内核技术</h4><ul>\n<li>所谓微内核技术，是指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS(程序)不同， 它更小更精炼，它不仅运行在核心态，而且开机后常驻内存， 它不会因内存紧张而被换出内存。微内核并非是一个完整的OS， 而只是为构建通用OS提供一个重要基础。由于在微内核OS结构中，通常都采用了客户&#x2F;服务器模式，因此OS的大部分功能和服务，都是由若干服务器来提供的， 如文件服务器、作业服务器和网络服务器等。</li>\n<li>微内核所提供的功能，通常都是一些最基本的功能，如进程管理、存储器管理、进程间通信、低级I&#x2F;O功能。</li>\n</ul>\n<h1 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h1><h2 id=\"进程的基本概念\"><a href=\"#进程的基本概念\" class=\"headerlink\" title=\"进程的基本概念\"></a>进程的基本概念</h2><h3 id=\"程序顺序执行时的特征\"><a href=\"#程序顺序执行时的特征\" class=\"headerlink\" title=\"程序顺序执行时的特征\"></a>程序顺序执行时的特征</h3><ol>\n<li>顺序性</li>\n<li>封闭性</li>\n<li>可再现性</li>\n</ol>\n<h3 id=\"前趋图\"><a href=\"#前趋图\" class=\"headerlink\" title=\"前趋图\"></a>前趋图</h3><ul>\n<li>前趋图(Precedence Graph)是一个<strong>有向无循环图</strong>，记为<strong>DAG</strong>(Directed Acyclic Graph)，用于描述进程之间执行的前后关系。</li>\n<li>在前趋图中，把<strong>没有前趋</strong>的结点称为<strong>初始结点</strong>(Initial Node)，把<strong>没有后继</strong>的结点称为<strong>终止结点</strong>(Final Node)。<img src=\"/articles/c94444f9/并发执行的前趋图.png\" width=70% height=70% /></li>\n</ul>\n<h3 id=\"程序并发执行时的特征\"><a href=\"#程序并发执行时的特征\" class=\"headerlink\" title=\"程序并发执行时的特征\"></a>程序并发执行时的特征</h3><ol>\n<li>间断性</li>\n<li>失去封闭性 </li>\n<li>不可再现性</li>\n</ol>\n<h3 id=\"进程的特征与状态\"><a href=\"#进程的特征与状态\" class=\"headerlink\" title=\"进程的特征与状态\"></a>进程的特征与状态</h3><h4 id=\"进程的特征\"><a href=\"#进程的特征\" class=\"headerlink\" title=\"进程的特征\"></a>进程的特征</h4><ol>\n<li>结构特征</li>\n<li>动态性</li>\n<li>并发性</li>\n<li>独立性</li>\n<li>异步性</li>\n</ol>\n<h4 id=\"较典型的进程的定义有：\"><a href=\"#较典型的进程的定义有：\" class=\"headerlink\" title=\"较典型的进程的定义有：\"></a>较典型的进程的定义有：</h4><ol>\n<li>进程是程序的一次执行。</li>\n<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li>\n<li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li>\n<li>在引入了进程实体的概念后，我们可以把传统OS中的进程定义为：<strong>“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位”</strong>。</li>\n</ol>\n<h4 id=\"进程的三种基本状态\"><a href=\"#进程的三种基本状态\" class=\"headerlink\" title=\"进程的三种基本状态\"></a>进程的三种<strong>基本</strong>状态</h4><ol>\n<li>就绪(Ready)状态 </li>\n<li>执行状态</li>\n<li>阻塞状态</li>\n</ol>\n<img src=\"/articles/c94444f9/进程的三种基本状态及其转换.png\" width=40% height=70% />\n\n<h4 id=\"挂起状态\"><a href=\"#挂起状态\" class=\"headerlink\" title=\"挂起状态\"></a>挂起状态</h4><ul>\n<li>引入挂起状态的原因 <ol>\n<li>终端用户的请求。 </li>\n<li>父进程请求。 </li>\n<li>负荷调节的需要。 </li>\n<li>操作系统的需要。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"进程状态的转换\"><a href=\"#进程状态的转换\" class=\"headerlink\" title=\"进程状态的转换\"></a><strong>进程状态的转换</strong></h4><p>在操作系统中，进程可能会经历多个状态，包括：</p>\n<ul>\n<li><strong>运行（Running）</strong>：进程正在 CPU 上执行。</li>\n<li><strong>就绪（Ready）</strong>：进程已获得所有必要资源，等待 CPU 调度执行。<ul>\n<li><strong>活动就绪（Active Ready）</strong>：进程保留在内存中，随时可以被 CPU 调度。</li>\n<li><strong>静止就绪（Suspended Ready）</strong>：进程被挂起，暂时存放在外存中，需调回内存后才能被调度执行。</li>\n</ul>\n</li>\n<li><strong>阻塞（Blocked）</strong>：进程正在等待某个事件（如 I&#x2F;O 结束）。<ul>\n<li><strong>活动阻塞（Active Blocked）</strong>：进程在内存中等待事件。</li>\n<li><strong>静止阻塞（Suspended Blocked）</strong>：进程被挂起，存放在外存，且仍在等待事件发生。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"进程状态的转换-1\"><a href=\"#进程状态的转换-1\" class=\"headerlink\" title=\"进程状态的转换\"></a>进程状态的转换</h4><ol>\n<li>活动就绪→静止就绪。<blockquote>\n<p>由于系统资源管理（如内存不足），某个就绪进程可能会被挂起并移至外存。</p>\n</blockquote>\n</li>\n<li>活动阻塞→静止阻塞。 <blockquote>\n<p>系统需要腾出内存，某个正在等待 I&#x2F;O 或其他事件的阻塞进程被挂起并移至外存。</p>\n</blockquote>\n</li>\n<li>静止就绪→活动就绪。<blockquote>\n<p>当系统资源充足（如内存可用）时，进程从外存调入内存，回到“活动就绪”状态，等待 CPU 调度。 </p>\n</blockquote>\n</li>\n<li>静止阻塞→活动阻塞。 <blockquote>\n<p>进程从外存恢复到内存，但仍然在等待事件完成。</p>\n</blockquote>\n</li>\n</ol>\n<img src=\"/articles/c94444f9/具有挂起状态的进程状态图.png\" width=40% height=70% />\n\n<h4 id=\"进程控制块（PCB，Process-Control-Block）\"><a href=\"#进程控制块（PCB，Process-Control-Block）\" class=\"headerlink\" title=\"进程控制块（PCB，Process Control Block）\"></a>进程控制块（PCB，Process Control Block）</h4><ul>\n<li><p>进程控制块的<strong>作用</strong>：</p>\n<ul>\n<li>是使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。</li>\n</ul>\n</li>\n<li><p>进程控制块中的<strong>信息</strong>：</p>\n<ol>\n<li>进程标识符（两种）</li>\n</ol>\n<ol>\n<li><p>内部标识符。</p>\n<blockquote>\n<p>在所有的操作系统中，都为每一个进程赋予一个惟一的数字标识符，<strong>它通常是一个进程的序号</strong>。<br><strong>设置内部标识符主要是为了方便系统使用。</strong></p>\n</blockquote>\n</li>\n<li><p>外部标识符。</p>\n<blockquote>\n<p>它由创建者提供，通常是由字母、数字组成，往往是由用户(进程)<strong>在访问该进程时</strong>使用。<br>为了描述进程的家族关系，还应设置父进程标识及子进程标识。<br>此外，还可设置用户标识，以指示拥有该进程的用户。</p>\n</blockquote>\n</li>\n</ol>\n<ol start=\"2\">\n<li>处理机状态<blockquote>\n<p>处理机状态信息主要是由处理机的<strong>各种寄存器</strong>中的内容组成的。</p>\n</blockquote>\n</li>\n</ol>\n<ol>\n<li>通用寄存器，又称为用户可视寄存器，它们是用户程序可以访问的，用于暂存信息，在大多数处理机中，有 8~32 个通用寄存器，在RISC结构的计算机中可超过 100 个；</li>\n<li>指令计数器，其中存放了要访问的下一条指令的地址；</li>\n<li>程序状态字PSW，其中含有状态信息，如条件码、执行方式、中断屏蔽标志等；</li>\n<li>用户栈指针，指每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶。</li>\n</ol>\n<ol start=\"3\">\n<li>进程调度信息<blockquote>\n<p>在PCB中还存放一些与进程调度和进程对换有关的信息，包括：</p>\n</blockquote>\n</li>\n</ol>\n<ol>\n<li>进程状态，指明进程的当前状态，作为进程调度和对换时的依据；</li>\n<li>进程优先级，用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机；</li>\n<li>进程调度所需的其它信息，它们与所采用的进程调度算法有关，比如，进程已等待CPU的时间总和、进程已执行的时间总和等；</li>\n<li>事件，是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。</li>\n</ol>\n<ol start=\"4\">\n<li>进程控制信息<blockquote>\n<p>进程控制信息包括：</p>\n</blockquote>\n</li>\n</ol>\n<ol>\n<li>程序和数据的地址，是指进程的程序和数据所在的内存或外存地(首)址，以便再调度到该进程执行时，能从PCB中找到其程序和数据；</li>\n<li>进程同步和通信机制，指实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等，它们可能全部或部分地放在PCB中；</li>\n<li>资源清单，是一张列出了除CPU以外的、进程所需的全部资源及已经分配到该进程的资源的清单；</li>\n<li>链接指针，它给出了本进程(PCB)所在队列中的下一个进程的PCB的首地址。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"进程控制-1\"><a href=\"#进程控制-1\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h2><h2 id=\"进程同步-1\"><a href=\"#进程同步-1\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h2><h2 id=\"经典进程的同步问题\"><a href=\"#经典进程的同步问题\" class=\"headerlink\" title=\"经典进程的同步问题\"></a>经典进程的同步问题</h2><h2 id=\"管程机制\"><a href=\"#管程机制\" class=\"headerlink\" title=\"管程机制\"></a>管程机制</h2><h2 id=\"进程通信-1\"><a href=\"#进程通信-1\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h2><h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2>","more":"<h1 id=\"第一章-操作系统引论\"><a href=\"#第一章-操作系统引论\" class=\"headerlink\" title=\"第一章  操作系统引论\"></a>第一章  操作系统引论</h1><h2 id=\"操作系统的目标和作用\"><a href=\"#操作系统的目标和作用\" class=\"headerlink\" title=\"操作系统的目标和作用\"></a>操作系统的目标和作用</h2><h3 id=\"OS的作用\"><a href=\"#OS的作用\" class=\"headerlink\" title=\"OS的作用\"></a>OS的作用</h3><ol>\n<li><strong>OS是用户与计算机硬件系统之间的接口</strong></li>\n<li><strong>OS是计算机系统资源的管理者</strong><blockquote>\n<p>在一个计算机系统中，通常都含有各种各样的硬件和软件资源。归纳起来可将资源分为四类：**处理器、存储器、 I&#x2F;O设备以及信息(数据和程序)**。相应地，OS的主要功能也正是针对这四类资源进行有效的管理，即：处理机管理， 用于分配和控制处理机；存储器管理，主要负责内存的分配与回收；I&#x2F;O设备管理，负责I&#x2F;O设备的分配与操纵；文件管理，负责文件的存取、共享和保护。可见，OS确是计算机系统资源的管理者。事实上，当今世界上广为流行的一个关于OS作用的观点，正是把OS作为计算机系统的资源管理者。</p>\n</blockquote>\n</li>\n<li><strong>OS用作扩充机器</strong></li>\n</ol>\n<h3 id=\"系统调用：\"><a href=\"#系统调用：\" class=\"headerlink\" title=\"系统调用：\"></a><strong>系统调用：</strong></h3><ul>\n<li>操作系统将计算机的资源（如CPU、内存、硬盘等）划分为两个空间：用户空间和内核空间。用户程序运行在用户空间，而操作系统的核心部分（内核）运行在内核空间。为了安全和稳定，用户程序不能直接访问内核空间，必须通过系统调用来请求内核服务。</li>\n</ul>\n<h2 id=\"操作系统的发展过程\"><a href=\"#操作系统的发展过程\" class=\"headerlink\" title=\"操作系统的发展过程\"></a>操作系统的发展过程</h2><h3 id=\"无操作系统的计算机系统\"><a href=\"#无操作系统的计算机系统\" class=\"headerlink\" title=\"无操作系统的计算机系统\"></a><strong>无操作系统</strong>的计算机系统</h3><ol>\n<li>人工操作方式（穿孔纸带）</li>\n</ol>\n<ul>\n<li>(1) 用户独占全机。(2) CPU等待人工操作。</li>\n</ul>\n<ol start=\"2\">\n<li>脱机输入&#x2F;输出方式</li>\n</ol>\n<ul>\n<li>(1) 减少了CPU的空闲时间。(2) 提高I&#x2F;O速度。</li>\n</ul>\n<h3 id=\"单道批处理系统\"><a href=\"#单道批处理系统\" class=\"headerlink\" title=\"单道批处理系统\"></a>单道批处理系统</h3><ul>\n<li>(1) 自动性。(2) 顺序性。(3) 单道性。</li>\n</ul>\n<h3 id=\"多道批处理系统\"><a href=\"#多道批处理系统\" class=\"headerlink\" title=\"多道批处理系统\"></a>多道批处理系统</h3><ul>\n<li>(1) 提高CPU的利用率。(2) 可提高 [内存和I&#x2F;O设备] 利用率。(3) 增加系统吞吐量。<blockquote>\n<p><strong>CPU利用率</strong>和<strong>系统吞吐量</strong>的关系<br>高CPU利用率并不一定带来高吞吐量。例如，如果CPU一直在处理低效的任务，CPU利用率可能很高，但吞吐量却很低。<br>高吞吐量通常需要较高的CPU利用率，但也受到其他系统资源的限制。</p>\n</blockquote>\n</li>\n<li>(1) 多道性。(2) 无序性。(3) 调度性。</li>\n<li>(1)资源利用率高。(2) 系统吞吐量大。(3) 平均周转时间长。(4) 无交互能力。 </li>\n<li>需要解决：(1) 处理机管理问题。(2) 内存管理问题。(3) I&#x2F;O设备管理问题。(4) 文件管理问题。(5) 作业管理问题。</li>\n</ul>\n<h3 id=\"分时系统\"><a href=\"#分时系统\" class=\"headerlink\" title=\"分时系统\"></a>分时系统</h3><ul>\n<li>计算机将CPU时间分成许多时间片，然后轮流分配给各个用户，由于切换速度很快，用户感觉就像独占计算机一样。</li>\n<li>(1) 多路性。(2) 独立性。(3) 及时性。(4) 交互性。</li>\n</ul>\n<h3 id=\"实时系统\"><a href=\"#实时系统\" class=\"headerlink\" title=\"实时系统\"></a>实时系统</h3><ul>\n<li>所谓“实时”，是表示“及时”，而实时系统(Real-Time System)是指系统能及时(或即时)响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</li>\n</ul>\n<p><strong>周期性实时任务</strong></p>\n<ul>\n<li><strong>定义：</strong> 任务以固定的时间间隔重复执行。</li>\n<li><strong>例子：</strong><ul>\n<li><strong>汽车防抱死系统（ABS）：</strong> 定期检测车轮速度，调整制动压力。</li>\n<li><strong>工业自动化控制：</strong> 定期采样传感器数据，控制执行器。</li>\n<li><strong>多媒体播放：</strong> 定期刷新屏幕，播放音频&#x2F;视频帧。</li>\n<li><strong>雷达系统：</strong> 定期扫描指定区域。</li>\n</ul>\n</li>\n</ul>\n<p><strong>非周期性实时任务</strong></p>\n<ul>\n<li><strong>定义：</strong> 任务的执行时间不固定，由外部事件触发。</li>\n<li><strong>例子：</strong><ul>\n<li><strong>飞机紧急制动系统：</strong> 在检测到紧急情况时立即启动。</li>\n<li><strong>医疗监护仪：</strong> 在检测到病人异常生理指标时发出警报。</li>\n<li><strong>网络数据包处理：</strong> 在接收到网络数据包时进行处理。</li>\n<li><strong>用户点击鼠标：</strong> 在用户点击鼠标时进行响应。</li>\n</ul>\n</li>\n</ul>\n<p><strong>硬实时任务</strong></p>\n<ul>\n<li><strong>定义：</strong> 任务必须在严格的时间限制内完成，否则会导致灾难性后果。</li>\n<li><strong>例子：</strong><ul>\n<li><strong>飞行控制系统：</strong> 任何延迟都可能导致飞机失控。</li>\n<li><strong>核电站控制系统：</strong> 任何延迟都可能导致核泄漏。</li>\n<li><strong>导弹制导系统：</strong> 任何延迟都可能导致目标丢失。</li>\n<li><strong>汽车安全气囊系统：</strong> 在碰撞发生后，必须在极短的时间内展开。</li>\n</ul>\n</li>\n</ul>\n<p><strong>软实时任务</strong></p>\n<ul>\n<li><strong>定义：</strong> 任务尽可能在时间限制内完成，但偶尔的延迟是可以接受的。</li>\n<li><strong>例子：</strong><ul>\n<li><strong>多媒体播放：</strong> 偶尔的丢帧或卡顿不会导致严重后果。</li>\n<li><strong>网络游戏：</strong> 偶尔的网络延迟会影响游戏体验，但不会导致游戏崩溃。</li>\n<li><strong>视频会议：</strong> 偶尔的音频&#x2F;视频延迟是可以接受的。</li>\n<li><strong>实时股票行情显示：</strong> 偶尔的延迟是可以接受的。</li>\n</ul>\n</li>\n</ul>\n<p><strong>总结</strong></p>\n<ul>\n<li>周期性和非周期性是根据任务的执行频率来划分的。</li>\n<li>硬实时和软实时是根据任务对时间限制的严格程度来划分的。</li>\n<li>实际应用中，一个任务可能同时具有多种属性，例如，汽车ABS系统既是周期性任务，又是硬实时任务。</li>\n</ul>\n<h2 id=\"操作系统的基本特性\"><a href=\"#操作系统的基本特性\" class=\"headerlink\" title=\"操作系统的基本特性\"></a>操作系统的基本特性</h2><h3 id=\"并发-Concurrency\"><a href=\"#并发-Concurrency\" class=\"headerlink\" title=\"并发 (Concurrency)\"></a>并发 (Concurrency)</h3><ul>\n<li><strong>定义:</strong> 指两个或多个事件在同一时间间隔内发生。</li>\n</ul>\n<h3 id=\"共享-Sharing\"><a href=\"#共享-Sharing\" class=\"headerlink\" title=\"共享 (Sharing)\"></a>共享 (Sharing)</h3><ul>\n<li><strong>定义:</strong> 指系统中的资源可以被多个程序或用户共同使用。</li>\n<li><strong>在操作系统中:</strong> 资源可以是硬件（如CPU、内存、磁盘）或软件（如文件、数据）。</li>\n<li>(1) 互斥共享方式 (2) 同时访问方式</li>\n</ul>\n<h3 id=\"虚拟-Virtualization\"><a href=\"#虚拟-Virtualization\" class=\"headerlink\" title=\"虚拟 (Virtualization)\"></a>虚拟 (Virtualization)</h3><ul>\n<li><strong>定义:</strong> 指通过技术手段将一个物理实体转化为多个逻辑实体，或者将多个物理实体转化为一个逻辑实体。</li>\n<li><strong>在操作系统中:</strong><ul>\n<li>虚拟内存：将物理内存扩展为更大的逻辑地址空间。</li>\n<li>虚拟CPU：通过时间片轮转，使每个程序都感觉拥有独立的CPU。</li>\n</ul>\n</li>\n<li><strong>关键点:</strong> 强调的是资源的逻辑抽象，这提高了资源的灵活性和效率。</li>\n</ul>\n<h3 id=\"异步-Asynchrony\"><a href=\"#异步-Asynchrony\" class=\"headerlink\" title=\"异步 (Asynchrony)\"></a>异步 (Asynchrony)</h3><ul>\n<li>由于资源等因素的限制，使进程的执行通常都不是“一气呵成”，而是以“停停走走”的方式运行。 </li>\n<li>进程是以人们不可预知的速度向前推进，此即进程的异步性。</li>\n<li>尽管如此，但只要运行环境相同，作业经多次运行，都会获得完全相同的结果。因此，异步运行方式是允许的，是操作系统的一个重要特征。</li>\n</ul>\n<p>这四个概念是操作系统中非常重要的基本特征，它们共同构成了现代操作系统的基础。</p>\n<h2 id=\"操作系统的主要功能\"><a href=\"#操作系统的主要功能\" class=\"headerlink\" title=\"操作系统的主要功能\"></a>操作系统的主要功能</h2><h3 id=\"处理机管理功能\"><a href=\"#处理机管理功能\" class=\"headerlink\" title=\"处理机管理功能\"></a>处理机管理功能</h3><h4 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h4><ul>\n<li>主要功能是为作业<strong>创建进程</strong>、<strong>撤消已结束的进程</strong>，以及<strong>控制进程在运行过程中的状态转换</strong>。</li>\n</ul>\n<h4 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h4><ul>\n<li>进程同步的主要任务是为多个进程(含线程)的运行进行协调。</li>\n<li>有两种协调方式： <ol>\n<li>进程互斥方式， 这是指诸进程(线程)在对临界资源进行访问时， 应采用互斥方式； </li>\n<li>进程同步方式，指在相互合作去完成共同任务的诸进程(线程)间，由同步机制对它们的执行次序加以协调。</li>\n</ol>\n</li>\n<li>为了实现进程同步，系统中必须设置进程同步机制。最简单的用于实现进程互斥的机制，是为每一个<strong>临界资源</strong>配置一把<strong>锁W</strong>，当锁打开时，进程(线程)可以对该临界资源进行访问；而当锁关上时，则禁止进程(线程)访问该临界资源。</li>\n</ul>\n<h4 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h4><ul>\n<li>在多道程序环境下，为了加速应用程序的运行，应在系统中建立多个进程，并且再为一个进程建立若干个线程，由这些进程(线程)相互合作去完成一个共同的任务。而在这些进程(线程)之间，又往往需要交换信息。</li>\n<li>当相互合作的进程(线程)处于同一计算机系统时，通常在它们之前是采用直接通信方式，即由源进程利用发送命令直接将消息(message)挂到目标进程的消息队列上，以后由目标进程利用接收命令从其消息队列中取出消息。</li>\n</ul>\n<h4 id=\"调度\"><a href=\"#调度\" class=\"headerlink\" title=\"调度\"></a>调度</h4><ul>\n<li>在后备队列上等待的每个作业，通常都要经过调度才能执行。在传统的操作系统中，包括<strong>作业调度</strong>和<strong>进程调度</strong>两步。</li>\n<li><strong>作业调度</strong>的基本任务，是从后备队列中按照一定的算法，选择出若干个作业，为它们分配其必需的资源(首先是分配内存)。 在将它们调入内存后，便分别为它们建立进程，使它们都成为可能获得处理机的就绪进程，并按照一定的算法将它们插入就绪队列。</li>\n<li>而<strong>进程调度</strong>的任务，则是从进程的就绪队列中选出一新进程，把处理机分配给它，并为它设置运行现场， 使进程投入执行。</li>\n<li>值得提出的是，在<strong>多线程OS</strong>中，通常是把<strong>线程</strong>作为独立运行和分配处理机的<strong>基本单位</strong>，为此，须把就绪线程排成一个队列，每次调度时，是从就绪线程队列中选出一个线程，把处理机分配给它。</li>\n</ul>\n<h3 id=\"存储器管理功能\"><a href=\"#存储器管理功能\" class=\"headerlink\" title=\"存储器管理功能\"></a>存储器管理功能</h3><h4 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h4><ul>\n<li>分配方式：<ol>\n<li>静态分配</li>\n<li>动态分配</li>\n</ol>\n</li>\n<li>为了实现内存分配，在内存分配的机制中应具有这样的结构和功能：<ol>\n<li>内存分配数据结构，该结构用于记录内存空间的使用情况，作为内存分配的依据；</li>\n<li>内存分配功能，系统按照一定的内存分配算法，为用户程序分配内存空间；</li>\n<li>内存回收功能，系统对于用户不再需要的内存，通过用户的释放请求，去完成系统的回收功能。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"内存保护\"><a href=\"#内存保护\" class=\"headerlink\" title=\"内存保护\"></a>内存保护</h4><ul>\n<li><strong>主要任务</strong>是确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰。</li>\n<li>一种比较简单的<strong>内存保护机制</strong>，是设置<strong>两个界限寄存器</strong>，分别用于存放正在执行程序的上界和下界。</li>\n<li>系统须对每条指令所要访问的地址进行检查，如果发生越界，便发出越界中断请求，以停止该程序的执行。</li>\n<li>如果这种检查完全用软件实现，则每执行一条指令，便须增加若干条指令去进行越界检查，这将显著降低程序的运行速度。<strong>因此，越界检查都由硬件实现。</strong>当然，对发生越界后的处理，<strong>还须与软件配合来完成。</strong></li>\n</ul>\n<h4 id=\"地址映射\"><a href=\"#地址映射\" class=\"headerlink\" title=\"地址映射\"></a>地址映射</h4><ul>\n<li>地址映射是逻辑地址到物理地址的映射。</li>\n<li>为使程序能正确运行，存储器管理必须提供地址映射功能，以将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。该功能应在硬件的支持下完成。</li>\n</ul>\n<h4 id=\"内存扩充\"><a href=\"#内存扩充\" class=\"headerlink\" title=\"内存扩充\"></a>内存扩充</h4><ul>\n<li>借助<strong>虚拟存储技术</strong>，<strong>从逻辑上</strong>去扩充内存容量，使用户所感觉到的内存容量比实际内存容量大得多；或者是让更多的用户程序能并发运行。</li>\n<li>用于实现下述各功能：<br>(1) 请求调入功能。<br>(2) 置换功能。</li>\n</ul>\n<p><strong>1. 请求调入功能</strong></p>\n<ul>\n<li><strong>概念：</strong><ul>\n<li>当程序运行时，并非所有代码和数据都需要立即加载到物理内存中。</li>\n<li>请求调入功能允许操作系统只将当前需要的程序部分（例如，代码页或数据页）加载到内存中。</li>\n<li>当程序尝试访问不在内存中的部分时，会产生一个“缺页中断”，操作系统会响应这个中断，并将所需的部分从磁盘（或其他存储介质）加载到内存中。</li>\n</ul>\n</li>\n<li><strong>作用：</strong><ul>\n<li>提高内存利用率：只加载必要的部分，减少了内存的浪费。</li>\n<li>支持更大的程序：允许程序使用比物理内存更大的地址空间。</li>\n</ul>\n</li>\n</ul>\n<p><strong>2. 置换功能</strong></p>\n<ul>\n<li><strong>概念：</strong><ul>\n<li>当物理内存已满，而程序又需要加载新的部分时，操作系统必须腾出一些空间。</li>\n<li>置换功能负责选择哪些内存中的部分应该被移出到磁盘（或其他存储介质），以便为新的部分腾出空间。</li>\n<li><strong>置换算法（例如，LRU、FIFO）</strong>用于决定哪些部分应该被置换。</li>\n</ul>\n</li>\n<li><strong>作用：</strong><ul>\n<li>管理有限的物理内存：确保在内存不足时，系统能够继续运行。</li>\n<li>优化内存使用：通过合理的置换算法，尽量减少频繁的磁盘I&#x2F;O操作。</li>\n</ul>\n</li>\n</ul>\n<p><strong>总结</strong></p>\n<ul>\n<li>请求调入和置换是虚拟内存技术的关键组成部分。</li>\n<li>它们共同工作，使得程序可以使用比实际物理内存更大的地址空间，并提高了内存的利用率。</li>\n<li>虚拟内存是现代操作系统中至关重要的技术。</li>\n</ul>\n<h3 id=\"设备管理功能\"><a href=\"#设备管理功能\" class=\"headerlink\" title=\"设备管理功能\"></a>设备管理功能</h3><h4 id=\"缓冲管理\"><a href=\"#缓冲管理\" class=\"headerlink\" title=\"缓冲管理\"></a>缓冲管理</h4><ul>\n<li>如果在I&#x2F;O设备和CPU之间引入缓冲，则<strong>可有效地缓和CPU（高速）和I&#x2F;O设备速度（低速）不匹配的矛盾</strong>，提高CPU的利用率，进而提高系统吞吐量。 </li>\n<li>因此，<strong>在现代计算机系统中，</strong>都毫无例外地在内存中设置了缓冲区，而且还可通过增加缓冲区容量的方法，来改善系统的性能。</li>\n<li>最常见的缓冲区机制有单缓冲机制、能实现双向同时传送数据的双缓冲机制，以及能供多个设备同时使用的公用缓冲池机制。</li>\n</ul>\n<h4 id=\"设备分配\"><a href=\"#设备分配\" class=\"headerlink\" title=\"设备分配\"></a>设备分配</h4><ul>\n<li>根据用户进程的I&#x2F;O请求、系统的现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。</li>\n<li>如果在I&#x2F;O设备和CPU之间，还存在着设备控制器和I&#x2F;O通道时，还须为分配出去的设备分配相应的控制器和通道。</li>\n<li>系统中应设置设备控制表、控制器控制表等数据结构，用于记录设备及控制器的标识符和状态。据这些表格可以了解指定设备当前是否可用，是否忙碌，以供进行设备分配时参考。</li>\n<li>在进行设备分配时，应针对不同的设备类型而采用不同的设备分配方式。对于独占设备(临界资源)的分配，还应考虑到该设备被分配出去后，系统是否安全。设备使用完后，还应立即由系统回收。</li>\n</ul>\n<h4 id=\"设备处理\"><a href=\"#设备处理\" class=\"headerlink\" title=\"设备处理\"></a>设备处理</h4><ul>\n<li><strong>设备处理程序</strong>又称为<strong>设备驱动程序</strong>。</li>\n<li>其<strong>基本任务</strong>是用于实现CPU和设备控制器之间的通信，即由CPU向设备控制器发出I&#x2F;O命令，要求它完成指定的I&#x2F;O操作；反之由CPU接收从控制器发来的中断请求，并给予迅速的响应和相应的处理。</li>\n<li>处理过程是：<ol>\n<li>设备处理程序首先检查I&#x2F;O请求的合法性，了解设备状态是否是空闲的，了解有关的传递参数及设置设备的工作方式。</li>\n<li>然后，便向设备控制器发出I&#x2F;O命令，启动I&#x2F;O设备去完成指定的I&#x2F;O操作。</li>\n</ol>\n</li>\n<li>设备驱动程序还应能及时响应由控制器发来的中断请求，并根据该中断请求的类型，调用相应的中断处理程序进行处理。对于设置了通道的计算机系统， 设备处理程序还应能根据用户的I&#x2F;O请求，自动地构成通道程序。</li>\n</ul>\n<h4 id=\"虚拟设备\"><a href=\"#虚拟设备\" class=\"headerlink\" title=\"虚拟设备\"></a>虚拟设备</h4><blockquote>\n<p>（没介绍）</p>\n</blockquote>\n<h3 id=\"文件管理功能\"><a href=\"#文件管理功能\" class=\"headerlink\" title=\"文件管理功能\"></a>文件管理功能</h3><h4 id=\"文件存储空间的管理\"><a href=\"#文件存储空间的管理\" class=\"headerlink\" title=\"文件存储空间的管理\"></a>文件存储空间的管理</h4><ul>\n<li>为每个文件分配必要的外存空间，提高外存的利用率，并能有助于提高文件系统的运行速度。</li>\n<li>为此，系统<ol>\n<li>应设置相应的数据结构，用于记录文件存储空间的使用情况，以供分配存储空间时参考；</li>\n<li>还应具有对存储空间进行分配和回收的功能。</li>\n</ol>\n</li>\n<li>为了提高存储空间的利用率，对存储空间的分配，通常是采用离散分配方式，以减少外存零头，并以盘块为基本分配单位。盘块的大小通常为512 B~8 KB。</li>\n</ul>\n<h4 id=\"目录管理\"><a href=\"#目录管理\" class=\"headerlink\" title=\"目录管理\"></a>目录管理</h4><ul>\n<li>为了使用户能方便地在外存上找到自己所需的文件，通常由系统为每个文件建立一个目录项。</li>\n<li>目录项包括文件名、文件属性、文件在磁盘上的物理位置等。由若干个目录项又可构成一个目录文件。</li>\n<li>目录管理的<strong>主要任务</strong>， 是为每个文件建立其目录项，并对众多的目录项加以有效的组织，以实现方便的按名存取。即用户只须提供文件名，即可对该文件进行存取。其次，目录管理还应能实现文件共享，这样，只须在外存上保留一份该共享文件的副本。此外，还应能提供快速的目录查询手段，以提高对文件的检索速度。</li>\n</ul>\n<h4 id=\"文件的读-写管理和保护\"><a href=\"#文件的读-写管理和保护\" class=\"headerlink\" title=\"文件的读&#x2F;写管理和保护\"></a>文件的读&#x2F;写管理和保护</h4><ol>\n<li><strong>文件的读&#x2F;写管理。</strong>该功能是根据用户的请求，从外存中读取数据；或将数据写入外存。在进行文件读(写)时，系统先根据用户给出的文件名，去检索文件目录，从中获得文件在外存中的位置。然后，利用文件读(写)指针，对文件进行读(写)。一旦读(写)完成，便修改读(写)指针，为下一次读(写)做好准备。由于读和写操作不会同时进行，故可合用一个读&#x2F;写指针。</li>\n<li><strong>文件保护。</strong>① 防止未经核准的用户存取文件； ② 防止冒名顶替存取文件； ③ 防止以不正确的方式使用文件。</li>\n</ol>\n<h4 id=\"用户接口\"><a href=\"#用户接口\" class=\"headerlink\" title=\"用户接口\"></a>用户接口</h4><ol>\n<li>命令接口<br>  (1) 联机用户接口（终端或控制台）<br>  (2) 脱机用户接口（也称批处理用户接口）</li>\n<li>程序接口</li>\n</ol>\n<ul>\n<li>由一组系统调用组成，每一个系统调用都是一个能完成特定功能的子程序，每当应用程序要求OS提供某种服务(功能)时，便调用具有相应功能的系统调用。</li>\n</ul>\n<ol start=\"3\">\n<li>图形接口</li>\n</ol>\n<ul>\n<li>用户虽然可以通过联机用户接口来取得OS的服务，但这时要求用户能熟记各种命令的名字和格式，并严格按照规定的格式输入命令，这既不方便又花时间，于是，图形用户接口便应运而生。</li>\n<li>图形用户接口采用了图形化的操作界面， 用非常容易识别的各种图标(icon)来将系统的各项功能、各种应用程序和文件，直观、逼真地表示出来。用户可用鼠标或通过菜单和对话框，来完成对应用程序和文件的操作。</li>\n<li>此时用户已完全不必像使用命令接口那样去记住命令名及格式，从而把用户从繁琐且单调的操作中解脱出来。</li>\n</ul>\n<h2 id=\"操作系统的结构设计\"><a href=\"#操作系统的结构设计\" class=\"headerlink\" title=\"操作系统的结构设计\"></a>操作系统的结构设计</h2><h3 id=\"软件工程的基本概念\"><a href=\"#软件工程的基本概念\" class=\"headerlink\" title=\"软件工程的基本概念\"></a>软件工程的基本概念</h3><h4 id=\"软件的含义\"><a href=\"#软件的含义\" class=\"headerlink\" title=\"软件的含义\"></a>软件的含义</h4><ul>\n<li>所谓软件，是指<strong>当计算机运行时，能提供所要求的【功能和性能】的【指令和程序】的集合，该程序能够正确地处理信息的数据结构</strong>；作为规范软件，还应具有描述程序功能需求以及程序如何操作使用的文档。</li>\n<li>如果说，硬件是物理部件，那么，软件则是一种逻辑部件，它具有与硬件完全不同的特点。</li>\n</ul>\n<h4 id=\"软件工程的含义\"><a href=\"#软件工程的含义\" class=\"headerlink\" title=\"软件工程的含义\"></a>软件工程的含义</h4><ul>\n<li>软件工程是指运用【系统的、规范的和可定量】的方法，来【开发、运行和维护软件】；或者说，是采用工程的概念、原理、技术和方法，来开发与维护软件，其目的是为了解决在软件开发中所出现的编程随意、软件质量不可保证以及维护困难等问题。</li>\n</ul>\n<h3 id=\"传统的操作系统结构\"><a href=\"#传统的操作系统结构\" class=\"headerlink\" title=\"传统的操作系统结构\"></a>传统的操作系统结构</h3><ul>\n<li>操作系统是一个十分复杂的大型软件。为了控制该软件的复杂性，在开发OS时，先后引入了分解、模块化、 抽象和隐蔽等方法。开发方法的不断发展，促进了OS结构的更新换代。这里，我们把第一代至第三代的OS结构， 称为传统的OS结构，而把微内核的OS结构称为现代OS结构。</li>\n</ul>\n<h4 id=\"无结构操作系统\"><a href=\"#无结构操作系统\" class=\"headerlink\" title=\"无结构操作系统\"></a>无结构操作系统</h4><h4 id=\"模块化OS结构\"><a href=\"#模块化OS结构\" class=\"headerlink\" title=\"模块化OS结构\"></a>模块化OS结构</h4><ul>\n<li><p>每个模块具有某方面的管理功能，如进程管理模块、存储器管理模块、I&#x2F;O设备管理模块和文件管理模块等，并规定好各模块间的接口， 使各模块之间能通过该接口实现交互，然后再进一步将各模块细分为若干个具有一定管理功能的子模块，如把进程管理模块又分为进程控制、 进程同步、 进程通信和进程调度等子模块， 同样也要规定各子模块之间的接口。若子模块较大时，再进一步将它细分。</p>\n<img src=\"/articles/c94444f9/模块化OS结构.png\" width=70% height=70% />\n</li>\n<li><p>优点：</p>\n<ol>\n<li>提高了OS设计的正确性、可理解性和可维护性。 </li>\n<li>增强了OS的可适应性。 </li>\n<li>加速了OS的开发过程。</li>\n</ol>\n</li>\n<li><p>缺点：</p>\n<ol>\n<li>在开始设计OS时，对模块的划分及对接口的规定并不精确，而且还可能存在错误，因而很难保证按此规定所设计出的模块会完全正确，这将使在把这些模块装配成OS时发生困难；</li>\n<li>其次，从功能观点来划分模块时，未能将共享资源和独占资源加以区别；</li>\n<li>由于管理上的差异，又会使模块间存在着复杂的依赖关系使OS结构变得不清晰。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"分层式OS结构\"><a href=\"#分层式OS结构\" class=\"headerlink\" title=\"分层式OS结构\"></a>分层式OS结构</h4><ul>\n<li>分层式结构设计的基本原则是：每一层都仅使用其底层所提供的功能和服务，这样可使系统的调试和验证都变得容易。</li>\n<li>层次的设置：<ol>\n<li><p><strong>程序嵌套。</strong>通常OS的每个功能的实现，并非是只用一个程序便能完成的，而是要经由若干个软件层才有可能完成。因此在划分OS层次时，首先要考虑在实现OS 的每个功能时所形成的程序嵌套。例如，作业调度模块须调用进程控制模块；在为某作业创建一进程时，进程控制模块又须调用内存管理模块为新进程分配内存空间，可见，进程控制模块应在内存管理模块之上； 而作业调度模块又应在更高层。</p>\n</li>\n<li><p><strong>运行频率。</strong>在分层结构中，各层次软件的运行速度是不同的，因为A1层软件能直接在物理机器上运行，故它有最高的运行速度。随着层次的增高，其相应软件的运行速度就随之下降，因而An层软件的运行速度最低。为了提高OS的运行效率，应该将那些经常活跃的模块放在最接近硬件的A1层，如时钟管理、进程调度，通常都放在A1层。</p>\n</li>\n<li><p>公用模块。应把供多种资源管理程序调用的公用模块，设置在最低层，不然，会使比它低的层次模块由于无法调用它而须另外配置相应功能的模块。例如，用于对<strong>信号量</strong>进行操作<strong>的</strong>原语Signal和Wait。</p>\n<blockquote>\n<p>这里提到<strong>信号量（Semaphore）</strong>是因为它是操作系统中用于进程同步与互斥的重要机制。信号量操作（如 Signal 和 Wait）通常是多个资源管理模块都会用到的基本功能，因此应放置在系统的底层，作为公用模块提供服务。这样可以避免不同模块重复实现相同的功能，提高系统的结构合理性和资源利用效率。</p>\n</blockquote>\n</li>\n<li><p>用户接口。为方便用户(程序)，OS向用户提供了“用户与OS的接口”，如命令接口、程序接口以及图形用户接口。这些接口应设置在OS的最高层，直接提供给用户使用。</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"微内核OS结构\"><a href=\"#微内核OS结构\" class=\"headerlink\" title=\"微内核OS结构\"></a>微内核OS结构</h3><h4 id=\"客户-服务器模式-Client-Server-Model\"><a href=\"#客户-服务器模式-Client-Server-Model\" class=\"headerlink\" title=\"客户&#x2F;服务器模式(Client-Server Model)\"></a>客户&#x2F;服务器模式(Client-Server Model)</h4><ul>\n<li>为了提高OS的灵活性和可扩充性而将OS划分为两部分，一部分是<strong>用于提供各种服务的一组服务器(进程)<strong>，如用于提供进程管理的进程服务器、提供存储器管理的存储器服务器和提供文件管理的文件服务器等，所有这些服务器(进程)都运行在用户态。当有一</strong>用户进程(现在称为客户进程)<strong>要求读文件的一个盘块时，该进程便向文件服务器(进程)发出一个请求；当服务器完成了该客户的请求后，便给该客户回送一个响应。操作系统的另一部分是</strong>内核</strong>，<strong>用来处理客户和服务器之间的通信</strong>， 即由内核来接收客户的请求，再将该请求送至相应的服务器；同时它也接收服务器的应答，并将此应答回送给请求客户。此外，在内核中还应具有其它一些机构，用于实现与硬件紧密相关的和一些较基本的功能。<blockquote>\n<p>平时我们提到 <strong>“服务器”</strong> 往往指的是云端或远程计算机提供的服务。但<strong>在操作系统（OS）内部，“服务器”指的是运行在用户态的系统进程，专门提供某些操作系统功能的服务。</strong></p>\n</blockquote>\n</li>\n</ul>\n<img src=\"/articles/c94444f9/C-S模式.png\" width=\"70%\" height=\"70%\" />\n<p style=\"text-align: center;\">单机环境下的客户/服务器模式</p>\n\n<ul>\n<li>优点：<ol>\n<li>提高了系统的灵活性和可扩充性。 </li>\n<li>提高了OS的可靠性。 </li>\n<li>可运行于分布式系统中。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"面向对象的程序设计技术-Object-Orientated-Programming\"><a href=\"#面向对象的程序设计技术-Object-Orientated-Programming\" class=\"headerlink\" title=\"面向对象的程序设计技术(Object-Orientated Programming)\"></a>面向对象的程序设计技术(Object-Orientated Programming)</h4><ul>\n<li><strong>面向对象技术的基本概念</strong><br>面向对象技术是20世纪80年代初提出并很快流行起来的。该技术是基于“抽象”和“隐蔽”原则来控制大型软件的复杂度的。所谓对象，是指在现实世界中具有相同属性、服从相同规则的一系列事物的抽象，而把其中的具体事物称为对象的实例。OS中的各类实体如进程、线程、消息、存储器等，都使用了对象这一概念，相应地，便有进程对象线程对象、 存储器对象等。 </li>\n<li><strong>优点</strong><ol>\n<li><strong>可修改性和可扩充性。</strong>由于隐蔽了表示实体的数据和操作，因而可以改变对象的表示而不会影响其它部分， 从而可以方便地改变老的对象和增加新的对象。</li>\n<li><strong>继承性。</strong>继承性是面向对象技术所具有的重要特性。继承性是指子对象可以继承父对象的属性，这样，在创建一个新的对象时， 便可减少大量的时空开销。</li>\n<li><strong>正确性和可靠性。</strong>由于对象是构成操作系统的基本单元，可以独立地对它进行测试，这样，比较易于保证其正确性和可靠性，从而比较容易保证整个系统的正确性和可靠性。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"微内核技术\"><a href=\"#微内核技术\" class=\"headerlink\" title=\"微内核技术\"></a>微内核技术</h4><ul>\n<li>所谓微内核技术，是指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS(程序)不同， 它更小更精炼，它不仅运行在核心态，而且开机后常驻内存， 它不会因内存紧张而被换出内存。微内核并非是一个完整的OS， 而只是为构建通用OS提供一个重要基础。由于在微内核OS结构中，通常都采用了客户&#x2F;服务器模式，因此OS的大部分功能和服务，都是由若干服务器来提供的， 如文件服务器、作业服务器和网络服务器等。</li>\n<li>微内核所提供的功能，通常都是一些最基本的功能，如进程管理、存储器管理、进程间通信、低级I&#x2F;O功能。</li>\n</ul>\n<h1 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h1><h2 id=\"进程的基本概念\"><a href=\"#进程的基本概念\" class=\"headerlink\" title=\"进程的基本概念\"></a>进程的基本概念</h2><h3 id=\"程序顺序执行时的特征\"><a href=\"#程序顺序执行时的特征\" class=\"headerlink\" title=\"程序顺序执行时的特征\"></a>程序顺序执行时的特征</h3><ol>\n<li>顺序性</li>\n<li>封闭性</li>\n<li>可再现性</li>\n</ol>\n<h3 id=\"前趋图\"><a href=\"#前趋图\" class=\"headerlink\" title=\"前趋图\"></a>前趋图</h3><ul>\n<li>前趋图(Precedence Graph)是一个<strong>有向无循环图</strong>，记为<strong>DAG</strong>(Directed Acyclic Graph)，用于描述进程之间执行的前后关系。</li>\n<li>在前趋图中，把<strong>没有前趋</strong>的结点称为<strong>初始结点</strong>(Initial Node)，把<strong>没有后继</strong>的结点称为<strong>终止结点</strong>(Final Node)。<img src=\"/articles/c94444f9/并发执行的前趋图.png\" width=70% height=70% /></li>\n</ul>\n<h3 id=\"程序并发执行时的特征\"><a href=\"#程序并发执行时的特征\" class=\"headerlink\" title=\"程序并发执行时的特征\"></a>程序并发执行时的特征</h3><ol>\n<li>间断性</li>\n<li>失去封闭性 </li>\n<li>不可再现性</li>\n</ol>\n<h3 id=\"进程的特征与状态\"><a href=\"#进程的特征与状态\" class=\"headerlink\" title=\"进程的特征与状态\"></a>进程的特征与状态</h3><h4 id=\"进程的特征\"><a href=\"#进程的特征\" class=\"headerlink\" title=\"进程的特征\"></a>进程的特征</h4><ol>\n<li>结构特征</li>\n<li>动态性</li>\n<li>并发性</li>\n<li>独立性</li>\n<li>异步性</li>\n</ol>\n<h4 id=\"较典型的进程的定义有：\"><a href=\"#较典型的进程的定义有：\" class=\"headerlink\" title=\"较典型的进程的定义有：\"></a>较典型的进程的定义有：</h4><ol>\n<li>进程是程序的一次执行。</li>\n<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li>\n<li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li>\n<li>在引入了进程实体的概念后，我们可以把传统OS中的进程定义为：<strong>“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位”</strong>。</li>\n</ol>\n<h4 id=\"进程的三种基本状态\"><a href=\"#进程的三种基本状态\" class=\"headerlink\" title=\"进程的三种基本状态\"></a>进程的三种<strong>基本</strong>状态</h4><ol>\n<li>就绪(Ready)状态 </li>\n<li>执行状态</li>\n<li>阻塞状态</li>\n</ol>\n<img src=\"/articles/c94444f9/进程的三种基本状态及其转换.png\" width=40% height=70% />\n\n<h4 id=\"挂起状态\"><a href=\"#挂起状态\" class=\"headerlink\" title=\"挂起状态\"></a>挂起状态</h4><ul>\n<li>引入挂起状态的原因 <ol>\n<li>终端用户的请求。 </li>\n<li>父进程请求。 </li>\n<li>负荷调节的需要。 </li>\n<li>操作系统的需要。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"进程状态的转换\"><a href=\"#进程状态的转换\" class=\"headerlink\" title=\"进程状态的转换\"></a><strong>进程状态的转换</strong></h4><p>在操作系统中，进程可能会经历多个状态，包括：</p>\n<ul>\n<li><strong>运行（Running）</strong>：进程正在 CPU 上执行。</li>\n<li><strong>就绪（Ready）</strong>：进程已获得所有必要资源，等待 CPU 调度执行。<ul>\n<li><strong>活动就绪（Active Ready）</strong>：进程保留在内存中，随时可以被 CPU 调度。</li>\n<li><strong>静止就绪（Suspended Ready）</strong>：进程被挂起，暂时存放在外存中，需调回内存后才能被调度执行。</li>\n</ul>\n</li>\n<li><strong>阻塞（Blocked）</strong>：进程正在等待某个事件（如 I&#x2F;O 结束）。<ul>\n<li><strong>活动阻塞（Active Blocked）</strong>：进程在内存中等待事件。</li>\n<li><strong>静止阻塞（Suspended Blocked）</strong>：进程被挂起，存放在外存，且仍在等待事件发生。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"进程状态的转换-1\"><a href=\"#进程状态的转换-1\" class=\"headerlink\" title=\"进程状态的转换\"></a>进程状态的转换</h4><ol>\n<li>活动就绪→静止就绪。<blockquote>\n<p>由于系统资源管理（如内存不足），某个就绪进程可能会被挂起并移至外存。</p>\n</blockquote>\n</li>\n<li>活动阻塞→静止阻塞。 <blockquote>\n<p>系统需要腾出内存，某个正在等待 I&#x2F;O 或其他事件的阻塞进程被挂起并移至外存。</p>\n</blockquote>\n</li>\n<li>静止就绪→活动就绪。<blockquote>\n<p>当系统资源充足（如内存可用）时，进程从外存调入内存，回到“活动就绪”状态，等待 CPU 调度。 </p>\n</blockquote>\n</li>\n<li>静止阻塞→活动阻塞。 <blockquote>\n<p>进程从外存恢复到内存，但仍然在等待事件完成。</p>\n</blockquote>\n</li>\n</ol>\n<img src=\"/articles/c94444f9/具有挂起状态的进程状态图.png\" width=40% height=70% />\n\n<h4 id=\"进程控制块（PCB，Process-Control-Block）\"><a href=\"#进程控制块（PCB，Process-Control-Block）\" class=\"headerlink\" title=\"进程控制块（PCB，Process Control Block）\"></a>进程控制块（PCB，Process Control Block）</h4><ul>\n<li><p>进程控制块的<strong>作用</strong>：</p>\n<ul>\n<li>是使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。</li>\n</ul>\n</li>\n<li><p>进程控制块中的<strong>信息</strong>：</p>\n<ol>\n<li>进程标识符（两种）</li>\n</ol>\n<ol>\n<li><p>内部标识符。</p>\n<blockquote>\n<p>在所有的操作系统中，都为每一个进程赋予一个惟一的数字标识符，<strong>它通常是一个进程的序号</strong>。<br><strong>设置内部标识符主要是为了方便系统使用。</strong></p>\n</blockquote>\n</li>\n<li><p>外部标识符。</p>\n<blockquote>\n<p>它由创建者提供，通常是由字母、数字组成，往往是由用户(进程)<strong>在访问该进程时</strong>使用。<br>为了描述进程的家族关系，还应设置父进程标识及子进程标识。<br>此外，还可设置用户标识，以指示拥有该进程的用户。</p>\n</blockquote>\n</li>\n</ol>\n<ol start=\"2\">\n<li>处理机状态<blockquote>\n<p>处理机状态信息主要是由处理机的<strong>各种寄存器</strong>中的内容组成的。</p>\n</blockquote>\n</li>\n</ol>\n<ol>\n<li>通用寄存器，又称为用户可视寄存器，它们是用户程序可以访问的，用于暂存信息，在大多数处理机中，有 8~32 个通用寄存器，在RISC结构的计算机中可超过 100 个；</li>\n<li>指令计数器，其中存放了要访问的下一条指令的地址；</li>\n<li>程序状态字PSW，其中含有状态信息，如条件码、执行方式、中断屏蔽标志等；</li>\n<li>用户栈指针，指每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶。</li>\n</ol>\n<ol start=\"3\">\n<li>进程调度信息<blockquote>\n<p>在PCB中还存放一些与进程调度和进程对换有关的信息，包括：</p>\n</blockquote>\n</li>\n</ol>\n<ol>\n<li>进程状态，指明进程的当前状态，作为进程调度和对换时的依据；</li>\n<li>进程优先级，用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机；</li>\n<li>进程调度所需的其它信息，它们与所采用的进程调度算法有关，比如，进程已等待CPU的时间总和、进程已执行的时间总和等；</li>\n<li>事件，是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。</li>\n</ol>\n<ol start=\"4\">\n<li>进程控制信息<blockquote>\n<p>进程控制信息包括：</p>\n</blockquote>\n</li>\n</ol>\n<ol>\n<li>程序和数据的地址，是指进程的程序和数据所在的内存或外存地(首)址，以便再调度到该进程执行时，能从PCB中找到其程序和数据；</li>\n<li>进程同步和通信机制，指实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等，它们可能全部或部分地放在PCB中；</li>\n<li>资源清单，是一张列出了除CPU以外的、进程所需的全部资源及已经分配到该进程的资源的清单；</li>\n<li>链接指针，它给出了本进程(PCB)所在队列中的下一个进程的PCB的首地址。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"进程控制-1\"><a href=\"#进程控制-1\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h2><h2 id=\"进程同步-1\"><a href=\"#进程同步-1\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h2><h2 id=\"经典进程的同步问题\"><a href=\"#经典进程的同步问题\" class=\"headerlink\" title=\"经典进程的同步问题\"></a>经典进程的同步问题</h2><h2 id=\"管程机制\"><a href=\"#管程机制\" class=\"headerlink\" title=\"管程机制\"></a>管程机制</h2><h2 id=\"进程通信-1\"><a href=\"#进程通信-1\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h2><h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2>","categories":[],"tags":[]}