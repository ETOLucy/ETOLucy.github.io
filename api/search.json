[{"title":"Android Studio - 安卓开发音乐app （use Spotify Android SDK and figma）","slug":"Android-Studio-安卓开发音乐app-（use-Spotify-Android-SDK-and-figma）","url":"/articles/24dd98ba.html","content":"\n# 前言\n\n这是“移动应用开发”这门课的大作业。用了Spotify Android SDK（后端，调取音乐数据）和figma（设计前端）。\n\n***\n**2023.12.22**\n说实话写得很累，写前端卡前端，写后端卡后端。所用的工具软件、看的文档又是全英文的，在一个期末八门大作业（其中三门开发岗项目、一门python大作业，两份课设、两篇论文）要在短短几周内（甚至到现在只剩几天了）写完的情况下，对于小白来说，不仅考验耐心，更考验效率。出现bug的时候更加不容易像平常那样不急不躁地debug，翻遍全网博客每次都是会看到不少同样的或类似的问题，但鲜少能很快地找到解决方案。\n\n在写这次大作业的时候才发现，之前一直心心念念的论坛，原来一般在开发者平台都能找到（他们若是有把部分项目或文档放到git仓库，可能git仓库底下也有不少能借鉴的Issues），为方便程序员开发，会给程序员建个专属论坛。以往我搜着搜着基本只能搜到stackflow，但大多情况搜到的都是尚未解决的问题，每次见到类似的报错都会很激动，点进去发现一个回答都没有，心又瞬间沉入谷底。\n\n光是调用Spotify Android SDK做到能打开app点击按钮播放一首设定好的歌曲我就挣扎了两个晚上，第一个晚上我搜了国内的那些音乐app大厂，只有网易云有开发者平台，我喜出望外地填写认证信息，填到最后我傻眼了，因为我那时才发现原来那个开发者平台是给网易云音乐内部的程序员用的。其他的大厂，包括抖音也有个音乐开放平台，但进去都是音乐人合作，或者企业合作。\n\n之后又搜罗资源，终于找到了spotify，但就那么一点点的入门文档，我就研究了两个晚上，现在才大致明白逻辑，并成功实现了后台播放。我觉得主要问题是版本吧，Android Studio真得改版太多了，其他的平台和它关联起来也需要不断地维护文档，但凡有一处没更新，对于我这样的小白来讲就真得很难处理问题。今天才懂如何去翻各种官方文档（原来不仅敲代码需要熟练度，看文档也需要熟练度啊）。\n\n目前spotify建了框架，尝试了playlist、track、album，都成功了。我想，开发简易的music player的话，光是这三种也差不多够用了，若是想开发复杂的，估计得看后期的时间是否充裕。\n\n再讲前端，将figma的文件包导入到Android Studio里，目前尝试过的插件（plugin）有俩，一个是Relay，一个是Dhiwise，但都失败了，接下来会重新再尝试，或者在线生成xml，最不济就只能导出图片然后加透明控件了。\n\n比较并总结一下Dhiwise和在线生成xml的优缺点（虽然目前Dhiwise没试成功）：\n\n- Dhiwise可以生成一整个packages，也就是项目包，里边会有图片、字体等各种丰富地资源，基本是能够完美还原源项目了。但是正是因为有这么多丰富的资源，包括有不同的dpi文件夹（这就意味着能适应各种dpi的手机），因此包很大，引入的依赖也很多，导入的时候很麻烦。且引入的是一整个新的前端包，之前写的后端内容，要重新手动cccv进去（我是小白，我只会手动，或许有什么其他的方法吧）。不过Dhiwise好像除了xml还有一个选项，不知道那个是什么用处，原谅一下我这位小白的无知。\n\n- 在线生成xml的方法，只能是每一个小模块生成一个xml，并且对应的drawable下的xml也需要自己手动创建、复制粘贴，一个稍微好看点的前端界面就有特别特别多的模块，而且稍微复杂点它们的位置就很难调节了，相当得麻烦。\n\n之后的日子再试试看吧，看看能否调出bug或者最终妥协，用“瞎猫”去“捉老鼠”。\n\n真是一个痛苦、难忘，但又充满着很多新鲜感和激情的期末啊！\n\n***\n\n\n\n\n# git仓库\n目前还没release，还在创建状态，网址为[https://github.com/ETOLucy/Music_app_spotify](https://github.com/ETOLucy/Music_app_spotify)。\n\n# 前端开发\n\n> 从数媒的高中同学那得知有figma这个东西，在国内的镜像版本叫做即使设计。于是就用起了figma。\n\n#TODO\n\n# 后端开发\n## Spotify文档讲解\n### 网址\n> 安卓开发网址：[https://developer.spotify.com/documentation/android](https://developer.spotify.com/documentation/android)\n论坛网址：[https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer](https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer)\n\n### 创建应用（以实现集成该SDK）\n- 先解释下，web端叫做“调取api”，对应的，Android叫做“集成SDK”。\n\n1. 进入Dashboard，创建应用。参考文档[创建应用](https://developer.spotify.com/documentation/web-api/concepts/apps)，这里要解释一下，新手可能会很好奇，明明我用的是SDK为什么跳转到web端去了，这个可以自己在Android的开发文档里仔细找，发现它就是有外链的，它给的外链就是我给的这个网址，我放这是为让读者切过去更方便些。\n这里的client id是它自动生成，重定向URI按照文档说的设置好（这里我也不是太懂我设置的uri是否在工作），安卓开发要填Android Package，ios开发填Bundle ID。安卓开发的Android Package可以从任意一个activity的java代码第一行里找，比如`package com.example.music_app_spotify;`则Android Package为`com.example.music_app_spotify`。\n> 对了，这里要说明一下，添加这些参数的时候，在输入框的下方会看到很明显的紫色“add”按钮，上面会有很不明显的“remove”按钮，记得一定要**点击“add”按钮**后再点击“save”按钮！！！\n指纹的话，按照文档来操作吧。\n2. 现在Android Studio是2023版了（现在都快2024年了），所以就连将库作为模块导入到项目都变了样。\n- 首先文档中导入方式的截图就和我们现在的Android Studio是不适配的，文档中的截图是new一个module，就可以选择“导入 .JAR/AAR 包”选项，但我们的方式，一种是点击左上角File，然后找到“Prject Structuer”，在左边的菜单栏选择“Dependencies”，在这里添加；另一种是在build.gradle.kts里（一般在文件最下边）dependencies{}里边添加`implementation(files(\"D:\\\\Android\\\\AndroidStudioProjects\\\\Music_app_spotify\\\\app\\\\libs\\\\spotify-app-remote-release-0.8.0.aar\"))`（路径依据你自己的来，记住别放在你定期清理的位置，放这个项目的libs下最好）。\n3. 在文档教程底下的授权那一篇里，文档提供的代码是：\n```groovy\nrepositories {\n    mavenCentral()\n}\ndependencies {\n    implementation 'com.spotify.android:auth:1.2.5' // Maven dependency\n\n    // All other dependencies for your app should also be here:\n    implementation 'androidx.browser:browser:1.0.0'\n    implementation \"androidx.appcompat:appcompat:$appCompatVersion\"\n}\n\n```\n而我的代码是（包含一些这份文档其他地方的要求的一些依赖）：\n```groovy\n    implementation(\"com.spotify.android:auth:1.2.6\")\n    implementation (\"androidx.browser:browser:1.6.0\")\n    implementation(\"androidx.appcompat:appcompat\")\n    implementation(\"com.google.android.material:material:1.8.0\")\n    implementation(files(\"D:\\\\Android\\\\AndroidStudioProjects\\\\Music_app_spotify\\\\app\\\\libs\\\\spotify-app-remote-release-0.8.0.aar\"))\n    implementation (\"com.google.code.gson:gson:2.10.1\")\n    implementation(\"com.google.android.gms:play-services-auth:20.7.0\")\n```\n文档这里的代码我几乎是加一行报错千万行，然后debug很长很长时间……\n- 首先是\n```groovy\nrepositories {\n    mavenCentral()\n}\n```\n当我把这个添加进去的时候，它显示和自带的maven库冲突，我就把它删掉了，也能跑maven。\n然后其他的一些，在[Maven Repository](https://mvnrepository.com/search?q=)里找到最新版引入的话，会显示Mainfest Merger报错，太老了也不对，就各种调吧，反正目前我这样的版本是可以使用的。\n\n## 授权登录之Activity的start与finish\n关于授权，在LoginActivity里和MainActivity里写这部分代码，问了gpt，但是它给的代码差一点（那一点很致命，我只好自己调出那一点）。\n看我在LoginActivity.java里的**成品**的部分代码：\n```java\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        super.onActivityResult(requestCode, resultCode, intent);\n\n        // Check if the result comes from the correct activity\n        if (requestCode == REQUEST_CODE) {\n            AuthorizationResponse response = AuthorizationClient.getResponse(resultCode, intent);\n\n            switch (((AuthorizationResponse) response).getType()) {\n                // Response was successful and contains auth token\n                case TOKEN:\n                    // Handle successful response, for example, navigate to MainActivity\n//                    Intent Main_intent = new Intent(this, MainActivity2.class);\n//                    String message = \"ok\";\n//                    Intent intent1 = intent.putExtra(\"if_login_in\", message);\n//                    startActivity(Main_intent);\n                    finish(); // finish the LoginActivity\n                    break;\n\n                // Auth flow returned an error\n                case ERROR:\n                    // Handle error response\n                    break;\n\n                // Most likely auth flow was cancelled\n                default:\n                    // Handle other cases\n            }\n        }\n    }\n```\n以及在MainActivity.java里的**成品**的部分代码：\n```java\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // Get the Intent that started this activity and extract the string\n//        Intent intent = getIntent();\n//        String message = intent.getStringExtra(\"if_login_in\");\n//        if(message.equals(\"ok\"))return;\n        // Check if the user is already logged in, based on your app's logic\n        if (userIsLoggedIn()) {\n            // User is logged in, proceed with your main app logic\n\n        } else {\n            // User is not logged in, navigate to LoginActivity\n            startActivity(new Intent(this, LoginActivity.class));\n//            finish(); // finish the MainActivity\n        }\n\n        // 找到播放按钮\n        Button playButton = findViewById(R.id.playButton);\n\n        // 设置按钮的点击事件\n        playButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // 在这里处理按钮点击事件，可以添加播放音乐的逻辑\n                playMusic();\n            }\n        });\n    }\n```\n可以观察一下我注释掉的部分。一开始运行的时候，是一直显示“正在加载...”，加载了之后又立刻弹出来又“正在加载...”，我以为是授权的地方哪里出错了，找了好久bug也没找到。\n后来发现MainActivity.java里if (userIsLoggedIn())底下没有任何实现，当时也没观察LoginActivity里是有start一个新的activity的（gpt给的代码是start MainActivity，我注释部分是我自己动过，也拿其他页面尝试过没成功），以为登陆进去啥操作也没有了，就开始在那加东西捣鼓，结果印象中是没啥反应（逻辑上应该也成立，因为Login那start一个新的Main页面后，main又授权登录，跳到login那，login再start一个新的main页面，因此死循环卡死了），于是又焦虑半天。\n再之后，发现login那有写start一个新的main页面，然后开始修改，发现运行结果有变化，这才意识到授权那边的代码没写错，理论上讲，登录应该成功了，出错应该是出在activity的实现上。\n我现在成品代码的逻辑是，授权成功后关闭login，这样就回到了main页面。\n\n## button之play music & stop music\n> 首先别忘记在xml页面创建按钮。\n\n先观察下我**成品**代码中的Onstart函数：\n```java\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n//        ConnectionParams connectionParams =\n//                new ConnectionParams.Builder(CLIENT_ID)\n//                        .setRedirectUri(REDIRECT_URI)\n//                        .showAuthView(true)\n//                        .build();\n//\n//        SpotifyAppRemote.connect(this, connectionParams,\n//                new Connector.ConnectionListener() {\n//\n//                    public void onConnected(SpotifyAppRemote spotifyAppRemote) {\n//                        mSpotifyAppRemote = spotifyAppRemote;\n//                        Log.d(\"MyActivity\", \"Connected! Yay!\");\n//\n//                        // Now you can start interacting with App Remote\n//                        connected();\n//\n//                    }\n//\n//                    public void onFailure(Throwable throwable) {\n//                        Log.e(\"MyActivity\", throwable.getMessage(), throwable);\n//\n//                        // Something went wrong when attempting to connect! Handle errors here\n//                    }\n//                });\n    }\n```\n观察一下我注释掉的代码里，有一句`connected();`，这里的connected函数相当于一个工具，就让它的那么摆着吧，丢到button的onClick里边反而不方便。至于其他部分，会发现它在进行连接，然后调取connected函数，执行`mSpotifyAppRemote.getPlayerApi().play(\"spotify:track:4lIsrJyQOdtBtRAyYiY2VD\");`这句话的时候，就是播放具体的歌曲了。\n所以把onStart()里除super.onStart();（这个是Onstart()函数存在它就必须得存在的东西，拿走不要命啦）全部拖到OnClick()下（我是在把它们封装在了playMusic函数里，再在OnClick里调用playMusic函数），如此便能实现运行app就后台播放音乐了。\n\n## 如何stop music？\n至于如何stop music，就再添加一个按钮，但是不能把onStop()下的`SpotifyAppRemote.disconnect(mSpotifyAppRemote);`放到按钮的OnClick下，这个是断开连接，而不是关闭，要这么写：\n```java\n        // 在这里处理按钮点击事件，停止音乐播放\n        if (mSpotifyAppRemote != null && mSpotifyAppRemote.isConnected()) {\n            // 如果 SpotifyAppRemote 已连接，则停止音乐播放\n            mSpotifyAppRemote.getPlayerApi().pause();\n        }\n```\n**记住！要加上这个if判断条件，不然的话点击停止按钮就会退出app！**\n\n## 关于 \"spotify:track:XXXXXX\" 怎么用\n这里其实很简单，我目前发现的有三种，一种是track，一种是album，一种是playlist。\n如果是album就\"spotify:album:XXXXXX\"，以此类推，替换两个冒号中间那个单词就行。\n至于每个歌曲的\"XXXXXXXXXXXXXXXXXX\"怎么知道是多少呢？这个其实跟，问到底是专辑（album）还是歌单（playList）还是具体去搜索某首歌（track）一样，去[spotify官网](https://open.spotify.com/)，比如我想找邓紫棋唱的面壁者，我搜到这首歌，它的网址是[https://open.spotify.com/track/1tCPlIIWX89HBVRhBzc9O1](https://open.spotify.com/track/1tCPlIIWX89HBVRhBzc9O1)，那么track就是两个冒号间要填的，`1tCPlIIWX89HBVRhBzc9O1`便是\"XXXXXXXXX\"。","tags":["安卓开发","Android Studio","AS","Spotify Android SDK","figma"],"categories":["Android Studio","Spotify","figma"]},{"title":"git系统学习笔记（基于acwing课）","slug":"git系统学习笔记（基于acwing课）","url":"/articles/cf02c727.html","content":"# 前言\n这是基于acwing中linux系统课下的git网课写的笔记。\n\n由于自己没系统学过就直接上手一边用一边现查然后发现玩不下去，所以转而系统学习，课前提要的时候y总也说他学习的时候也是这样的感受，所以让我们不要像学vim、tmux和ssh那样像学工具一样学习，一定要先系统地学完再使用git命令。\n\n由于git命令实在过于复杂（我认为倒也不是命令复杂，而是里边的逻辑概念很难形成一个清晰的认知，哪怕已经有点概念了，只要不是相当明确，就会出现同样的需求前一次感觉已经谈不上稀里糊涂有点概念地实现成功了，重新再实现一遍居然又遇上新的报错），我写了此篇笔记，用来之后翻看用。\n\n# acwing的讲义\n> acwing有提供过一套讲义，我先将它复制到此处。\n\n## git基本概念\n- 工作区：仓库的目录。工作区是独立于各个分支的。\n- 暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。\n- 版本库：存放所有已经提交到本地仓库的代码版本\n- 版本结构：树结构，树中每个节点代表一个代码版本。\n## git常用命令\n- `git config --global user.name xxx`：设置全局用户名，信息记录在`~/.gitconfig`文件中\n- `git config --global user.email xxx@xxx.com`：设置全局邮箱地址，信息记录在`~/.gitconfig`文件中\n- `git init`：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中\n- `git add XX`：将XX文件添加到暂存区\n    - `git add .`：将所有待加入暂存区的文件加入暂存区\n- `git rm --cached XX`：将文件从仓库索引目录中删掉\n- `git commit -m` \"给自己看的备注信息\"：将暂存区的内容提交到当前分支\n- `git status`：查看仓库状态\n- `git diff XX`：查看XX文件相对于暂存区修改了哪些内容\n- `git log`：查看当前分支的所有版本\n- `git reflog`：查看HEAD指针的移动历史（包括被回滚的版本）\n- `git reset --hard HEAD^` 或 `git reset --hard HEAD~`：将代码库回滚到上一个版本\n    - `git reset --hard HEAD^^`：往上回滚两次，以此类推\n    - `git reset --hard HEAD~100`：往上回滚100个版本\n    - `git reset --hard 版本号`：回滚到某一特定版本\n- `git checkout — XX`或`git restore XX`：将XX文件尚未加入暂存区的修改全部撤销\n- `git remote add origin git@git.acwing.com:xxx/XXX.git`：将本地仓库关联到远程仓库\n- `git push -u` (第一次需要-u以后不需要)：将当前分支推送到远程仓库\n- `git push origin branch_name`：将本地的某个分支推送到远程仓库\n- `git clone git@git.acwing.com:xxx/XXX.git`：将远程仓库XXX下载到当前目录下\n- `git checkout -b branch_name`：创建并切换到`branch_name`这个分支\n- `git branch`：查看所有分支和当前所处分支\n- `git checkout branch_name`：切换到branch_name这个分支\n- `git merge branch_name`：将分支branch_name合并到当前分支上\n- `git branch -d branch_name`：删除本地仓库的branch_name分支\n- `git branch branch_name`：创建新分支\n- `git push --set-upstream origin branch_name`：设置本地的`branch_name`分支对应远程仓库的`branch_name`分支\n- `git push -d origin branch_name`：删除远程仓库的`branch_name`分支\n- `git pull`：将远程仓库的当前分支与本地仓库的当前分支合并\n    - `git pull origin branch_name`：将远程仓库的`branch_name`分支与本地仓库的当前分支合并\n- `git branch --set-upstream-to=origin/branch_name1 branch_name2`：将远程的`branch_name1`分支与本地的`branch_name2`分支对应\n- `git checkout -t origin/branch_name` 将远程的`branch_name`分支拉取到本地\n- `git stash`：将工作区和暂存区中尚未提交的修改存入栈中\n- `git stash apply`：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素\n- `git stash drop`：删除栈顶存储的修改\n- `git stash pop`：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素\n- `git stash list`：查看栈中所有元素\n\n## acwing开发的仿github平台\n> 网址：[git.acwing.com](git.acwing.com)\ny总说马云的gitee广告太多，不喜欢，所以自己开发了这个。\n这个平台可以国内网进且快一点，且目前基本只有acwing的同学知道，氛围会好一点。\ny总说了，是免费的，大家也可以拿这个替代github。\n我去看了下，前端界面开发得挺好看的。\n(但是好像终端得用AC terminal，而AC terminal只有买了课的同学才能用，且给每个人分的带宽不多，亲测是很卡的。)\n\n\n# 网课笔记\n## 树模型\n- git其实相当于树模型，HEAD其实类似于头指针。\n因为这是个树模型，所以HEAD也可以在不同分支间切换。\n- 仓库信息在.git文件夹内\n```bash\nzstueto@LAPTOP-QJGKA05C:/mnt/d/Internet$ ls -a\n.   .git     CONTERIBUTING.md  HelloWorld  db.sqlite3  statics    templatetags\n..  .vscode  CONTRIBUTING.md   TestModel   manage.py   templates\nzstueto@LAPTOP-QJGKA05C:/mnt/d/Internet$ cd .git\nzstueto@LAPTOP-QJGKA05C:/mnt/d/Internet/.git$ ls -a\n.   COMMIT_EDITMSG  HEAD       branches  description  index  logs     packed-refs\n..  FETCH_HEAD      ORIG_HEAD  config    hooks        info   objects  refs\nzstueto@LAPTOP-QJGKA05C:/mnt/d/Internet/.git$ cat HEAD\nref: refs/heads/Lucy1\n```\n\n## 版本\n- **`git status`可以用来查看当前是否有文件没加进来**，比如我给文件夹里添加一个`111.html`.\n可以对比一下`git add .`之前和之后的`git status`给的提示。\n```bash\nzstueto@LAPTOP-QJGKA05C:/mnt/d/Internet$ git status\nOn branch Lucy1\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        templates/111.html\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nzstueto@LAPTOP-QJGKA05C:/mnt/d/Internet$ git add .\nzstueto@LAPTOP-QJGKA05C:/mnt/d/Internet$ git status\nOn branch Lucy1\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n        new file:   templates/111.html\n\n```\n\n- **`git commit -m \"给自己或合作者看的备注信息\"`记得要加`-m`！！！**\n`git commit -m \"给自己或合作者看的备注信息\"`命令之后，将我们当前暂存区的版本存到了我们当前分支的下一个节点，并将HEAD指向这个点，并且这个节点的记录存下备注信息。\n\n- **注意可以使用`git diff XX`查看XX文件相对于暂存区修改了哪些内容**\n\n- 关于`git rm --cached XX`和`git restore --stage XX`：这俩都可以从暂存区里撤回点东西，区别是，rm是直接删，而restore是回滚。\n\n- `git log`是从最初的空节点沿着当前分支走到当前节点，只有这条路径的log。\n所展示的内容，放最上面的是最新修改，越往下越旧，直到走到空节点。\n    - 有个命令叫`git log --pretty=oneline`，这样每个节点只展示一行。\n    部分log展示如下（只包含最近的几条信息，先前的太多了就不展示了）：\n```bash\nzstueto@LAPTOP-QJGKA05C:/mnt/d/Internet/templates$ git log --pretty=one\nline\n79c2e08e07bf9f7916544c8641efee252b66b420 (HEAD -> Lucy1) add 111.html\n80bab04e71ae3ec61af0cf46ba58cdfee8cc6877 delete 111.html\n6024a913bf3557b9423a832f7a3d50a08d1e0320 add 111.html\n```\n\n- 往前回滚版本\n    - `git reset --hard HEAD^`一个`^`代表回滚一个版本，两个`^`代表回滚两个版本，依此类推。\n    连续执行两次`git reset --hard HEAD^`命令的效果等同于`git reset --hard HEAD^^`，而不等同于回滚回去再滚回来。\n        - 回滚完之后，HEAD指针会前移，而`git log`只能显示根节点到HEAD的路径。虽然这里的回滚，不会将之前的内容删掉，但是`git log`已经看不到回滚前的了，那么如何回退回来呢？\n        - 用`git reflog`命令展示HEAD的移动记录。\n    ```bash\n    zstueto@LAPTOP-QJGKA05C:/mnt/d/Internet$ git reflog\n    80bab04 (HEAD -> Lucy1) HEAD@{0}: reset: moving to HEAD^\n    79c2e08 HEAD@{1}: commit: add 111.html\n    80bab04 (HEAD -> Lucy1) HEAD@{2}: commit: delete 111.html\n    6024a91 HEAD@{3}: commit: add 111.html\n    ```\n        (部分reflog展示)\n        - 在reflog里可以看到每个版本的编号，这个编号是hash值的前7位，这里的版本号用来跳转到任意一个节点（因为所有创建过的目录，HEAD一定是走过的，所以一定会在reflog里出现过）。\n    ```bash\n    zstueto@LAPTOP-QJGKA05C:/mnt/d/Internet$ git reflog\n    79c2e08 (HEAD -> Lucy1) HEAD@{0}: reset: moving to 79c2e08\n    80bab04 HEAD@{1}: reset: moving to 80bab04\n    80bab04 HEAD@{2}: reset: moving to HEAD^\n    79c2e08 (HEAD -> Lucy1) HEAD@{3}: commit: add 111.html\n    80bab04 HEAD@{4}: commit: delete 111.html\n    6024a91 HEAD@{5}: commit: add 111.html\n    ```\n        （部分reflog展示）\n        这里可以关注到，回滚回某个版本的时候，版本号和回滚的版本号一致，比如这里出现了两个79c2e08和两个80bab04。\n        - 关于`git reset --hard HEAD^^`：\n    ```bash\n    zstueto@LAPTOP-QJGKA05C:/mnt/d/Internet$ git log\n    commit 79c2e08e07bf9f7916544c8641efee252b66b420 (HEAD -> Lucy1)\n    Author: zstu21 <3435657471@qq.com>\n    Date:   Wed Dec 13 23:46:55 2023 +0800\n\n        add 111.html\n\n    commit 80bab04e71ae3ec61af0cf46ba58cdfee8cc6877\n    Author: zstu21 <3435657471@qq.com>\n    Date:   Wed Dec 13 23:21:54 2023 +0800\n\n        delete 111.html\n\n    commit 6024a913bf3557b9423a832f7a3d50a08d1e0320\n    Author: zstu21 <3435657471@qq.com>\n    Date:   Wed Dec 13 23:18:21 2023 +0800\n\n        add 111.html\n    # （此处省略前边历史）\n    zstueto@LAPTOP-QJGKA05C:/mnt/d/Internet$ git reset --hard HEAD^^\n    HEAD is now at 6024a91 add 111.html\n    zstueto@LAPTOP-QJGKA05C:/mnt/d/Internet$ git reset --hard HEAD^^\n    HEAD is now at 6024a91 add 111.html\n    zstueto@LAPTOP-QJGKA05C:/mnt/d/Internet$ git reflog\n    6024a91 (HEAD -> Lucy1) HEAD@{0}: reset: moving to HEAD^^\n    79c2e08 HEAD@{1}: reset: moving to 79c2e08\n    80bab04 HEAD@{2}: reset: moving to 80bab04\n    80bab04 HEAD@{3}: reset: moving to HEAD^\n    79c2e08 HEAD@{4}: commit: add 111.html\n    80bab04 HEAD@{5}: commit: delete 111.html\n    6024a91 (HEAD -> Lucy1) HEAD@{6}: commit: add 111.html\n    # （此处省略前边历史）\n    ```\n        可以发现这里的HEAD^^不是回滚reflog的前两个版本，而是回滚git log的前两个版本（git log是沿着当前分支从根节点走到当前HEAD节点路径的节点）。\n    \n    - 返回到上次保存（返回目前暂存区的版本，不是返回暂存区上一次的版本，就比如我往`111.html`中添加了`111`这句话，没`git add .`，那我`git restore .`后就是把`111`这行话删除，回滚到`111.html`没有`111`这句话的状态）的版本:\n        - `git restore .`：全部文件返回上次保存的版本。\n        - `git restore XX`：XX文件返回上次保存的版本。\n    \n- `git add XX`也可以将删除XX文件的记录添加到暂存区内。\n```bash\nzstueto@LAPTOP-QJGKA05C:/mnt/d/Internet/templates$ rm 111.html # linux命令\nzstueto@LAPTOP-QJGKA05C:/mnt/d/Internet/templates$ git add 111.html\nzstueto@LAPTOP-QJGKA05C:/mnt/d/Internet/templates$ git status\nOn branch Lucy1\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n        deleted:    111.html\n\n```\n\n- `git add XX YY`这样并排地写两个文件，意为把XX和YY两个文件的信息都添加到暂存区。\n\n- 这里若是误删，可以用`git restore XX`恢复XX文件（相当于从回收站还原文件）。\n\n> 这里需要注意的是，`git log`和`git reflog`记录的版本都只有持久化后的版本的，只有`git commit -m \"XX\"`后才会生成一个新版本。\n暂存区无变化的情况下，用`git commit -m \"XX\"`命令多次的结果是，无论在`git log`还是`git reflog`中，都不会生成新的版本，只有第一次commit的记录。\n\n> 目前都是对本地的操作，跟云端没有关系。\n\n## github上查看历史版本\n> 现在开始讲云端\n\n> github上绿色的`<>code`按钮下边有个`n commits`的按钮，点击就可以查看每个分支的commits\n\n- 使用`git reset --hard [你的commit id]`可以恢复历史版本，然后再用git push命令推送到远程仓库。\n\n- 这里的`commit id`是版本号中提交到远程仓库的部分，比起`git reflog`命令显示的版本号，缺少回滚部分。\n\n- `git reflog`中（我目前所看到的只有三种，说明这三种最常见）：\n```bash\n6024a91 HEAD@{8}: checkout: moving from branch1 to branch2\n731779f HEAD@{16}: commit: delete 111.html\n6024a91 HEAD@{17}: reset: moving to HEAD^^\n```\n分别为checkout，commit和reset，其中github仓库commit id中，checkout部分也没有。因为github仓库的commits记录是按分支分类的，没必要把本地切换分支的记录也写上去，要写也不知道写哪去。\ngithub仓库的commit记录是push上去的记录，而且`git commit -m \"XX\"`只能使用两次，再使用一次会不成功并提示要`git push`一下：\n```bash\nzstueto@LAPTOP-QJGKA05C:/mnt/d/Internet$ git commit -m \"delete 111.cpp\"\nOn branch hzh11\nYour branch is ahead of 'origin/hzh11' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add/rm <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        deleted:    111.cpp\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n这里告诉你已经有两个commits了，不能再多了，要想再commit就要先push一下，下面部分就是你没commit成功所以有这些东西没有存。\n\n## branch\n- （在本地）创建新分支的命令是`git checkout -b branchname`。\n创建分支是从当前HEAD中继承出来的（内容继承自当前HEAD分支），但是只是有个趋势，不会创建一个新的节点，用`git log`命令可以发现什么都没发生，但是用`git reflog`命令，会出现一个新记录。\n\n- 创建新分支，会创完并跳转到这个分支：\n```bash\nzstueto@LAPTOP-QJGKA05C:/mnt/d/Internet$ git checkout -b branch1\nSwitched to a new branch 'branch1'\n```\n\n> 注意暂存区和分支没有关系，跟分支是独立的。不管哪个分支都共用了一个暂存区，commit的时候，会看你当前在哪个分支，就把暂存区内容加到哪个分支的后面。切换分支的时候，不会有多个暂存区，不管在哪个分支上都用了一个暂存区和工作目录。\n\n- git branch 命令：\n<table>\n  <tr>\n    <th>分支操作</th>\n    <th>命令</th>\n  </tr>\n  <tr>\n    <td>创建分支</td>\n    <td><code>git branch &lt;name&gt;</code>：创建叫name的分支，但仍然停留在当前分支。<br><code>git checkout -b &lt;name&gt;</code>：创建叫name的分支，并切换到name分支。</td>\n  </tr>\n  <tr>\n    <td>删除分支</td>\n    <td><code>git branch -d &lt;name&gt;</code>：参数为-D则为强制删除，这个命令是删除本地分支。<br><code>git push origin --delete &lt;name&gt;</code>：删除远程仓库的叫name的分支，同名的本地分支并不会被删除，所以还需要单独删除本地同名分支。<br><code>git branch -dr &lt;remote&gt;/&lt;branch-name&gt;</code>：没有删除远程分支，只是删除 <code>git branch -r</code> 列表中的追踪分支。一般只有 <code>git push</code> 命令可以修改远程仓库。</td>\n  </tr>\n  <tr>\n    <td>创建+切换分支</td>\n    <td><code>git switch &lt;name&gt;</code>：只能用来切换到已有的分支，不能用来创建新的分支。\n    <br><code>git checkout &lt;name&gt;</code>：只能用来切换到已有的分支，不能用来创建新的分支。\n    <br><code>git branch &lt;name&gt;</code>：只能用来创建新分支，不能用来切换分支。创建但不会切换到新分支。\n    <br><code>git switch -c &lt;name&gt;</code>：只能用来创建新分支，不能用来切换分支。创建但切换到新分支。</td>\n    \n  </tr>\n  <tr>\n    <td>查看分支</td>\n    <td><code>git branch</code>：查看本地分支，当前分支前面会标一个*号。<br><code>git branch -r</code>：查看远程分支和本地分支的关联。<br><code>git branch -a</code>：查看本地分支和本地分支与远程分支的关联，本地分支与远程分支的关联会用红色表示出来（如果你开了颜色支持的话）。<br><code>git branch -v</code>：查看每个分支的最新版本和版本号。<br><code>git branch -vv</code>：类似于 <code>git branch -v</code>，区别在于会有蓝色提示，类似于 <code>[origin/branch_name]</code>，表示最新commit的修改在这个分支。</td>\n  </tr>\n  <tr>\n    <td>重命名分支</td>\n    <td><code>git branch -m oldName newName</code></td>\n  </tr>\n  <tr>\n    <td>操作远程分支</td>\n    <td><code>git push --set-upstream origin branch_name</code>：设置本地的<code>branch_name</code>分支对应远程仓库的<code>branch_name</code>分支。\n    <br><code>git push -u origin/remote_branch_name</code>：将本地新建的分支与远程分支相关联，同上。\n    <br><code>git branch --unset-upstream</code>：撤销当前本地分支和其远程分支的关联。\n    <br><code>git push -d origin branch_name</code>：删除远程仓库的<code>branch_name</code>分支。<br><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库。</td>\n  </tr>\n</table>\n\n\n\n\n- `git merge branch_name`：将分支branch_name合并到当前分支上\n如果无冲突就是fast-forward合并了。\n如果有冲突，比如在同一个文件上，两个分支的内容不一样，就会提示**合并不成功（但是你当前所在的文件会出现一些“》》》》》》”类的东西）**，请手动合并后再持久化：\n```bash\nzstueto@LAPTOP-QJGKA05C:/mnt/d/Internet$ git merge test1\nCONFLICT (add/add): Merge conflict in 1.cpp\nAuto-merging 1.cpp\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n对于有冲突的文件，打开，用vsc的合并编辑器或者linux终端的vim或者纯手动修改后，commit一下就行。\n另外，若想禁用fast-forward模式，用--no-ff，这个有需求的时候自己可以临时查。\n\n- git用远程分支代码强制覆盖本地分支代码：\n```bash\ngit fetch --all\ngit reset --hard origin/master\ngit pull\n```\n\n- git用本地代码强制覆盖远程代码：\n```bash\ngit push origin branch_name -f\n```\n\n## 栈空间\n- `git stash`用来：\n有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支做一点别的事情。 问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。 针对这个问题的答案是 `git stash` 命令。\n- `git stash`：将工作区和暂存区中尚未提交的修改存入栈中\n- `git stash apply`：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素\n- `git stash drop`：删除栈顶存储的修改\n- `git stash pop`：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素\n- `git stash list`：查看栈中所有元素\n\n> 可以看这个教程 [Git 工具 - 贮藏与清理](https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E8%B4%AE%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86)\n\n","tags":["git多人协作开发","git系统学习笔记","acwing课"]},{"title":"搭建网站-介绍杭州历史文化","slug":"搭建网站-介绍杭州历史文化","url":"/articles/af1b0cc3.html","content":"# PoeticPastHangzhou\n## github多人协作开发\n### 常见的git bash命令和快捷键\n- 有些命令和linux命令差不多，也有vim，touch等\n- **复制** `ctrl`+`insert` （可能需要外加`Fn`）\n- **粘贴** `shift`+`insert` （可能需要外加`Fn`）\n- **初始化本地git仓库**\n```bash\ngit init\n```\n- **与github仓库远程关联**\n```bash\n# e.g.\ngit remote add origin https://github.com/zstu21/PoeticPastHangzhou.git\n```\n- **切换分支**\n```bash\ngit checkout -b <your branch>\n```\n- **将文件添加进本地仓库中（等待上传）**\n```bash\ngit add .  # 把该目录下全部文件放入\ngit add <your files>\ngit add *.txt  # 添加所有以 .txt 结尾的文件\ngit add src/*.js  # 添加 src 目录下所有的 .js 文件\ngit add docs/**/*.md  # 添加 docs 目录及其子目录下所有的 .md 文件\ngit add file1.txt file2.txt file3.txt  # 逐个添加文件\ngit add dir1/ file1.txt dir2/file2.txt  # 添加文件和目录\ngit add -u  # 添加所有已经跟踪的文件，包括修改过的和删除的文件，但不包括新添加的文件\ngit add -A  # 添加所有已经跟踪的文件以及新添加的文件，包括修改过的和删除的文件\n\n```\n- **查看git add里的东西**\n```bash\ngit status\n\n```\n- **撤销 git add：**\n```bash\ngit reset  # 将所有已暂存的更改移除\ngit reset <filename>  # 将特定文件从暂存区中移除：\n```\n- **永久保存**\n```bash\ngit commit -m \"Your commit message here\"  # 这里的\"\"里的描述不能为空\n```\n- **git push**\n```bash\n# 要是之前就已经选好分支，直接git push\n# 要是没有就：\ngit push origin <branch>\n# 这里的origin类似于仓库的意思\n```\n- **查看现在所在的分支**\n```bash\ngit branch\n# 会显示：\n$ git branch\n* draft\n```","tags":["PoeticPastHangzhou","github多人协作开发"],"categories":["搭建网站"]},{"title":"计算机网络笔记-谢希仁（计算机网络概述）","slug":"计算机网络笔记-谢希仁（计算机网络概述）","url":"/articles/ca08d5a5.html","content":"# 思维导图\n![计算机网络概述](https://github.com/zstu21/image/blob/main/img/JiWang/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B01.png?raw=true)\n# 计算机网络概述\n\n## 计算机网络的概念\n\n### 计算机网络的定义\n\n- 计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统\n\n### 计算机网络的组成\n\n- 终端系统\n\n  - 提供共享的软件资源和硬件资源\n\n- 通信子网\n\n  - 提供信息交换的网络结点和通信线路\n\n### 计算机网络的类型\n\n- 按照拓扑分类\n\n  - 星型结构\n\n  - 树形结构\n\n  - 总线型结构\n\n  - 环形结构\n\n  - 网状结构\n\n- 按照范围分类\n\n  - 局域网 LAN\n\n  - 城域网 MAN\n\n  - 广域网 WAN\n\n  - 补充\n\n    - 个人区域网 PAN\n\n    - 互联网 Internet\n\n- 按照传输方式分类\n\n  - 有线网络\n\n    - IEEE802.3\n\n  - 无线网络\n\n    - IEEE802.11\n\n    - WLAN 无线局域网（wireless）\n\n    - WPAN 无线个域网\n\n## 计算机网络体系结构\n\n### 传输方式\n\n- 按照传输方向分\n\n  - 单工\n\n    - 只能单方向传输的工作模式\n\n  - 双工\n\n    - 在同一时间，线路上只能允许一个方向的数据通过\n\n  - 全双工\n\n    - 双方可以同时进行数据通信\n\n- 按照传输对象分\n\n  - 单播\n\n    - 1对1\n\n  - 多播\n\n    - 1对多\n\n  - 广播\n\n    - 1对all\n\n### 数据交换\n\n- 电路交换\n\n  - 整个报文从源头到终点连续的传输\n\n- 报文交换\n\n  - 整个报文先传送到相邻结点，全部存储下来查找转发表，再转发到下一个结点。\n\n- 分组交换\n\n  - 将一个报文分成多个分组，传送到相邻结点，再查找转发表，再转发到下一个结点。\n\n### 通信协议和体系结构\n\n- 网络协议三要素\n\n  - 语法\n\n  - 语义\n\n  - 时序\n\n- OSI参考模型\n\n  - 物理层\n\n    - 单位 bit，利用传输介质为通信的网络结点之间的建立\n\n  - 数据链路层\n\n    - 单位 帧，在物理层的基础之上，提供结点到结点之间的服务，采取差错控制和流量控制的方法，实现网络互联\n\n  - 网络层\n\n    - 单位 分组，在数据链路层的基础之上，提供点到点之间的通信，提供路由功能，实现拥塞控制、网络互联等功能。\n\n  - 传输层\n\n    - 提供端到端之间的数据传输服务，实现对数据进行控制和操作的功能。\n\n  - 会话层\n\n    - 负责维护通信中两个节点之间的会话建立维护和断开，以及数据的交换。\n\n  - 表示层\n\n    - 表示层用于处理交互数据的表示方式，例如格式转换、数据的加密和解密、数据压缩和恢复等功能。\n\n  - 应用层\n\n    - 使用应用程序通过网络服务。\n\n- TCP/IP参考模型\n\n  - 网络接口层\n\n    - 物理层和数据链路层\n\n  - 网际层\n\n    - 网络层\n\n  - 传输层\n\n  - 应用层\n\n    - 会话层、表示层、应用层\n\n","tags":["笔记","谢希仁教材","思维导图","计算机网络概述"],"categories":["计算机网络"]},{"title":"计算机网络笔记-谢希仁（计算机网络概论和物理层总结补充）","slug":"计算机网络笔记-谢希仁（计算机网络概论和物理层总结补充）","url":"/articles/e871eaa7.html","content":"# 思维导图\n![计算机网络概论和物理层总结补充](https://cdn.jsdelivr.net/gh/zstu21/image@main/img/JiWang/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E5%92%8C%E7%89%A9%E7%90%86%E5%B1%82%E6%80%BB%E7%BB%93%E8%A1%A5%E5%85%85.png)\n# 计算机网络概论和物理层总结补充\n\n## 计算机概论\n\n### 计算机网络定义\n\n- 地理位置不同的独立主机，通信线路连接实现资源共享。\n\n### 计算机网络组成\n\n- 资源子网和通信子网\n\n### 计算机网络分类\n\n- 拓扑\n\n  - 星型、树形、总线型、环形、网状型\n\n- 范围\n\n  - 局域网LAN、城域网MAN、广域网WAN\n\n- 传输方式\n\n  - 有线和无线\n\n### 计算机网络的传输方式\n\n- 方向\n\n  - 单工、半双工、全双工\n\n- 传输对象数量\n\n  - 单播、多播、广播\n\n### 数据交换方式\n\n- 电路交换、报文交换、分组交换\n\n### 网络协议三要素\n\n- 语法语义时序\n\n### 常见体系结构\n\n- OSI开放互联参考模型\n\n  - 七层\n\n    - 物理层、数据链路层、网络层、传输层、表示层、会话层、应用层\n\n- TCP/IP参考模型\n\n  - 四层\n\n    - 网路接入层、网络层、传输层、应用层\n\n## 物理层\n\n### 四大特性\n\n- 机械特性、电气特性、功能特性、过程特性\n\n### 两种信号\n\n- 数字信号和模拟信号\n\n### 调制和编码\n\n- 调制\n\n  - 将任意信号调整成为模拟信号\n\n- 编码\n\n  - 将任意信号编码成为数字信号\n\n### 传输介质\n\n- 双绞线\n\n  - 传输距离100-500（集线器）速度按照类别区分\n\n- 光纤\n\n  - 多模光纤和单模光纤；多模几千米；单模几十上百千米。\n\n### 三个传输部分\n\n- 源系统、传输系统、目的系统\n\n### 四种复用技术\n\n- 频分、时分、码分、波分（光）\n\n### 传输方式\n\n- 同时间传输数量\n\n  - 并行传输和串行传输\n\n- 通信时双方反应\n\n  - 同步传输和异步传输\n\n- 通过传输的信号类型\n\n  - 基带传输和频带传输\n\n- 方向和对象\n\n  - 单工...；单播....\n\n## 第一二章难点补充\n\n### 理解OSI参考模型工作模式和特点\n\n### 广播域和冲突域\n\n","tags":["笔记","谢希仁教材","思维导图","计算机网络概论和物理层总结补充"],"categories":["计算机网络"]},{"title":"计算机网络笔记-谢希仁（传输层）","slug":"计算机网络笔记-谢希仁（传输层）","url":"/articles/ec75daa1.html","content":"# 思维导图\n![传输层](https://cdn.jsdelivr.net/gh/zstu21/image@main/img/JiWang/%E4%BC%A0%E8%BE%93%E5%B1%82.png)\n# 传输层\n\n## 传输层概论\n\n### 传输层\n\n- 传输层提供端到端服务\n\n- 从通信和信息处理的角度看，传输层向上层应用层提供通信服务。\n\n- 所谓的端口，就好像是门牌号一样，客户端可以通过ip地址找到对应的服务器端，但是服务器端是有很多端口的，每个应用程序对应一个端口号，通过类似门牌号的端口号，客户端才能真正的访问到该服务器。为了对端口进行区分，将每个端口进行了编号，这就是端口号\n\n### 端口号\n\n- FTP：21 （20）*\n\n  - FTP（文件传输协议）\n\n  - 21连接；20传输数据\n\n- TELNET：23*\n\n  - TELNET（远程登录）\n\n- SMTP：25*\n\n  - SMTP（电子邮件传输协议）\n\n  - POP3（邮局协议版本3） ：110\n\n- DNS：53*\n\n  - DNS（域名系统）\n\n- TFTP：69\n\n  - TFTP（简单文件传输协议）\n\n- HTTP：80*\n\n  - HTTP（超文本传输协议）\n\n- SNMP：161\n\n  - SNMP（简单网络管理协议）\n\n- HTTPS：443*\n\n  - HTTPS（超文本传输安全协议）\n\n## 传输层的两个重要协议\n\n### TCP\n\n- 传输控制协议 ：TCP\n\n- TCP是TCP/IP体系中较为复杂的协议，是传输层中最重要的协议。\n  TCP的主要特点是：\n  1.TCP是面向连接的传输层协议\n  2.TCP提供可靠的交付服务\n  3.TCP提供全双工通信\n  4.TCP是面向字节流\n\n- 窗口\n\n  - 固定窗口\n\n    - 如果窗口过小，当传输比较大的数据的时候需要不停的对数据进行确认，这个时候就会造成很大的延迟。\n\n  - 滑动窗口\n\n    - 滑动窗口通俗来讲就是一种流量控制技术。\n      它本质上是描述接收方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据，如果发送方收到接收方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接收方发送窗口大小不为0的数据报的到来\n\n  - 拥塞处理和流量控制\n\n- TCP的三次握手和四次挥手\n\n### UDP\n\n- 用户数据报协议 ：UDP\n\n- UDP是在IP数据报服务之上增加了一些功能，增加了复用和分用的功能以及差错检测的功能，UDP的主要特点是：\n  1.UDP是无连接的\n  2.UDP尽最大努力交付\n  3.UDP面向报文且没有拥塞控制\n  4.UDP开销较小传输效率较高\n\n- UDP首部的概念\n\n","tags":["笔记","谢希仁教材","传输层","思维导图"],"categories":["计算机网络"]},{"title":"计算机网络笔记-谢希仁（网络安全）","slug":"计算机网络笔记-谢希仁（网络安全）","url":"/articles/66609e71.html","content":"# 思维导图\n![网络安全](https://cdn.jsdelivr.net/gh/zstu21/image@main/img/JiWang/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.png)\n# 网络安全\n\n## 网络安全概论\n\n### 网络安全\n\n- 网络安全（Cyber Security）是指网络系统的硬件、软件及其系统中的数据受到保护，不因偶然的或者恶意的原因而遭受到破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断。\n\n### 计算机网络面临的威胁主要分为两大类\n\n- 主动攻击\n\n  - 主动的去做一些在网络基础上的恶意行为。\n    恶意篡改信息数据，发布恶意程序脚本等待\n\n  - 篡改\n\n  - 恶意程序\n\n  - 拒绝服务\n\n- 被动攻击\n\n  - 被动攻击主要是收集信息而不是进行访问。\n    不改变数据本身的结构，也不对软硬件数据造成影响。\n\n  - 截获\n\n  - 窃取\n\n  - 流量分析\n\n### 网络系统的特性\n\n- 保密性\n\n  - 信息不泄露给非授权用户、实体或过程，或供其利用的特性。\n\n- 完整性\n\n  - 数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。\n\n- 可用性\n\n  - 可被授权实体访问并按需求使用的特性。即当需要时能否存取所需的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击。\n\n- 可靠性\n\n  - 对信息的传播及内容具有控制能力。\n\n- 不可抵赖性\n\n  - 出现安全问题时提供依据与手段。\n\n## 加密和交互\n\n### 加密和解密\n\n- 加密\n\n  - 是以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容。 \n\n  - 加密手段\n\n    - MD5加密（信息-摘要算法）\n\n      - 128位\n\n    - AES加密（称密钥加密）\n\n      - 128、192、256位\n\n    - SHA1加密（安全哈希算法）\n\n      - 160位\n\n    - RSA加密\n\n      - 公钥加密，私钥解密\n\n        - 1024位\n\n- 解密\n\n  - 加密的逆过程就是解密\n\n### 公钥和私钥\n\n- 对称加密\n\n  - 采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。\n\n- 非对称加密\n\n  - 使用非堆成的加密方式时，会生成两把钥匙以。发送方利用自己的公钥加密，接收方利用自己的私钥解密。\n\n  - 数字签名的四大特点\n\n    - 防止重放攻击\n\n      - 攻击者利用网络监听或者其他方式盗取认证凭据，之后再把它重新发给认证服务器。在数字签名中，如果采用了对签名报文加盖时戳等或添加流水号等技术，就可以有效防止重放攻击。\n\n    - 防止数据伪造\n\n      - 其他人不能伪造对消息的签名，因为私有密钥只有签名者自己知道，所以其他人不可以构造出正确的签名结果数据。\n\n    - 防止数据被篡改\n\n      - 数字签名与原始文件或摘要一起发送给接收者，一旦信息被篡改，接收者可通过计算摘要和验证签名来判断该文件无效，从而保证了文件的完整性。\n\n    - 防止数据抵赖\n\n      - 数字签名即可以作为身份认证的依据，也可以作为签名者签名操作的证据。要防止接收者抵赖，可以在数字签名系统中要求接收者返回一个自己签名的表示收到的报文，给发送者或受信任第三方。如果接收者不返回任何消息，此次通信可终止或重新开始，签名方也没有任何损失，由此双方均不可抵赖。\n\n### 防火墙\n\n- 防火墙时一种访问控制技术，可以严格控制进出网络边界的分组，禁止任何不必要的通信，来减少潜在入侵的发生。\n\n- 防火墙的区域们\n\n  - Local 本地区域\n\n    - 顶级安全区域，安全优先级为100\n\n    - local就是防火墙本身的区域比如ping指令等网际控制协议的回复，需要local域的权限凡是由防火墙主动发出的报文均可认为是从Local区域中发出凡是需要防火墙响应并处理(而不是转发)的报文均可认为是由Local区域接收\n\n  - Trust 受信区\n\n    - 高级级安全区域，安全优先级为85\n\n    - 通常用来定义内部用户所在的网络，也可以理解为应该是防护最严密的地区。\n\n  - DMZ 非军事化区\n\n    - 中级安全区域，安全优先级为50\n\n    - 通常用来定义内部服务器所在网络\n\n    - 作用是把WEB,E-mail,等允许外部访问的服务器单独接在该区端口，使整个需要保护的内部网络接在信任区端口后，不允许任何访问，实现内外网分离，达到用户需求。DMZ可以理解为一个不同于外网或内网的特殊网络区域，DMZ内通常放置一些不含机密信 息的公用服务器，比如Web、Mail、 FTP等。 这样来自外网的访问者可以访问DMZ中的服务，但不可能接触到存放在内网中的公司机密或私人信息等,即使DMZ中服务器受到破坏，也不会对内网中的机密信启造成影响。\n\n  - Untrust 非受信区\n\n    - 低级安全区域，安全优先级为5\n\n    - 通常用来定义Internet等不安全的网络，用于网络入口线的接入。\n\n","tags":["笔记","谢希仁教材","思维导图","网络安全"],"categories":["计算机网络"]},{"title":"计算机网络笔记-谢希仁（应用层）","slug":"计算机网络笔记-谢希仁（应用层）","url":"/articles/8bea7e3c.html","content":"# 思维导图\n![应用层](https://cdn.jsdelivr.net/gh/zstu21/image@main/img/JiWang/%E5%BA%94%E7%94%A8%E5%B1%82.png)\n# 应用层\n\n## 应用层的作用\n\n### 通过位于不同主机中的多个应用进程之间的通信和协同工作来完成。应用层的内容就是具体定义通信规则。\n\n## 应用层中常见的协议\n\n### 域名系统DNS\n\n- 域名结构：\n  每一个域名用标号隔开。\n             mail.cctv.com\n  三级域名.二级域名.顶级域名\n\n- 域名服务器\n\n  - 迭代\n\n  - 递归\n\n### 文件传输协议FTP\n\n- 使用TCP连接，传输数据\n\n- 端口号是21 （20）\n  20发送数据\n\n### 远程终端协议TELNET\n\n- 使用TCP连接，远程登录到远地的另一台主机上\n\n- 端口号是23\n\n### 万维网和HTTP协议\n\n- 超文本传输协议，是一个简单的请求-响应协议\n\n- 端口号是80\n\n### 电子邮件协议\n\n- SMTP电子邮件传输协议\n\n  - 端口号25\n\n- POP3邮局协议版本3\n\n  - 端口号110\n\n### DHCP动态主机配置协议\n\n- 指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。\n\n- 端口号68\n\n","tags":["笔记","谢希仁教材","思维导图","应用层"],"categories":["计算机网络"]},{"title":"计算机网络笔记-谢希仁（物理层概述）","slug":"计算机网络笔记-谢希仁（物理层概述）","url":"/articles/5f67f3dd.html","content":"# 思维导图\n![物理层](https://cdn.jsdelivr.net/gh/zstu21/image@main/img/JiWang/%E7%89%A9%E7%90%86%E5%B1%82.png)\n# 一、物理层\n\n## 物理层的基本概念\n\n### 四大特性\n\n- 机械特性\n\n  - 接口是怎样的\n\n- 电气特性\n\n  - 用多少伏的电\n\n- 功能特性\n\n  - 线路上电平电压的特性\n\n- 过程特性\n\n  - 实现不同功能所发射信号的顺序\n\n### 两种信号\n\n- 模拟信号\n\n  - 特定频段的信号\n\n    - 有更加丰富的表现形式\n\n- 数字信号\n\n  - 不是1就是0\n\n### 调制和编码\n\n- 调制\n\n  - 模拟信号转换\n\n- 编码\n\n  - 数字信号转换\n\n  - 编码的步骤\n\n    - 采样\n\n    - 量化\n\n    - 编码\n\n- 区别\n\n  - 数据可以通过编码手段转成数字信号，也可以通过调制手段将数据转为模拟信号 。\n\n  - 数字数据可以通过数字发送器转化为数字信号 （编码），也可以通过调制器转化为模拟信号（调）。\n\n  - 模拟数据可以通过PCM编码器转化为数字信号（编码），也可以通过放大器调制器转化为模拟信号（调制）\n\n### 传输介质\n\n- 双绞线\n\n  - 屏蔽双绞线 STP\n\n    - 抗干扰强、贵一些\n\n  - 非屏蔽双绞线 UTP\n\n    - 便宜、抗干扰差\n\n  - 制作标准 \n\n    - 568B\n\n      - 橙白、橙、绿白、蓝、蓝白、绿、棕白、棕\n\n    - 568A\n\n      - 13、26调换\n\n- 光纤\n\n  - 单模光纤\n\n    - 多模光纤(Multi Mode Fiber) － 芯较粗(50或62.5μm)，可传多种模式的光。但其模间色散较大，这就限制了传输数字信号的频率，而且随距离的增加会更加严重。例如：600MB/KM的光纤在2KM时则只有300MB的带宽了。因此，多模光纤传输的距离就比较近，一般只有几公里。\n\n    - 距离：2KM\n\n  - 多模光纤\n\n    - 单模光纤(Single Mode Fiber)：中心纤芯很细(芯径一般为9或10μm)，只能传一种模式的光。因此，其模间色散很小，适用于远程通讯，但还存在着材料色散和波导色散，这样单模光纤对光源的谱宽和稳定性有较高的要求，即谱宽要窄，稳定性要好。\n\n    - 距离：100KM\n\n- 同轴电缆\n\n  - 淘汰了\n\n- 无线\n\n  - 无线信号频率802.11\n\n### 三大部分\n\n- 源系统\n\n  - 发送数据的一端\n\n- 传输系统\n\n  - 传输过程中的各种传输介质\n\n- 目的系统\n\n  - 接收数据的电脑\n\n## 物理层的基本通信技术\n\n### 四种信道复用技术\n\n- 复用技术\n\n  - 复用技术是指一种在传输路径上综合多路信道，然后恢复原机制或解除终端各信道复用技术的过程。\n\n    - 将多种不同的信号在 同一信道上进行传输，复用技术主要是用于解决不同信号传输时应该如何区分。\n\n- 频分复用 FDM\n\n  - 频分多路复用，是在适于某种传输媒质的传输频带内，若干个频谱互不重叠的信号一并传输的方式，简称FDM。在每路信号进入传输频带前，先要依次搬移频率（调制），而在接收端，再搬回到原来的频段，恢复每路的原信号，从而使传输频带得到多路信号的复用。\n\n    - 划分不同频率来并行传输信号\n\n- 时分复用 TDM\n\n  - 时分复用TDM是采用同一物理连接的不同时段来传输不同的信号，也能达到多路传输的目的。时分多路复用以时间作为信号分割的参量，故必须使各路信号在时间轴上互不重叠。时分复用（TDM，Time-division multiplexing）就是将提供给整个信道传输信息的时间划分成若干时间片(简称时隙)，并将这些时隙分配给每一个信号源使用。\n\n    - 划分不同时间段来传输信号\n\n- 波分复用 WDM\n\n  - 是将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器(亦称合波器，Multiplexer)汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术\n\n    - 根据光波的波长进行传输（合波器耦合）\n\n- 码分复用 CDM\n\n  - 码分复用(CDM，Code Division Multiplexing)是靠不同的编码来区分各路原始信号的一种复用方式，主要和各种多址技术结合产生了各种接入技术，包括无线和有线接入。\n\n    - 在同一时间同一频率根据传输的数据码进行区分\n\n### 数据的传输方式\n\n- 通过同时间传输数量分为\n\n  - 并行传输\n\n    - 并行传输指的是数据以成组的方式，在多条并行信道上同时进行传输，是在传输中有多个数据位同时在设备之间进行的传输。\n\n  - 串行传输\n\n    - 使用一条数据线，将数据一位一位地依次传输，每一位数据占据一个固定的时间长度。只需要少数几条线就可以在系统间交换信息，特别适用于计算机与计算机、外设之间的远距离通信。\n\n- 通过数据报文的双方的行为分为\n\n  - 同步传输\n\n    - 同步\n\n      - 在计算机网络中，定时的因素称为位同步。同步是要接收方按照发送方发送的每个位的起止时刻和速率来接收数据，否则会产生误差。\n\n    - 同步传输的比特分组要大得多。它不是独立地发送每个字符，每个字符都有自己的开始位和停止位，而是把它们组合起来一起发送。我们将这些组合称为数据帧，或简称为帧。\n\n  - 异步传输\n\n    - 异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，\n      而接收方从不知道它们会在什么时候到达。\n\n- 通过传输的信号分为\n\n  - 基带传输\n\n    - 传输数字信号叫做基带传输\n\n  - 频带传输\n\n    - 传输模拟信号叫做频带传输\n\n      - 300-3400HZ\n\n- 传输方向\n\n  - 单工、双工、全双工\n\n- 传输对象\n\n  - 单播、组播、广播\n\n","tags":["笔记","谢希仁教材","思维导图","物理层概述"],"categories":["计算机网络"]},{"title":"计算机网络笔记-谢希仁（数据链路层）","slug":"计算机网络笔记-谢希仁（数据链路层）","url":"/articles/aeeebdd8.html","content":"# 思维导图\n![数据链路层](https://raw.githubusercontent.com/zstu21/image/main/img/JiWang/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.png)\n# 三、数据链路层\n\n## 数据链路层基础概论\n\n### 数据链路层概念\n\n- 数据链路层是在物理层和网络层之间的协议，提供相邻结点的可靠数据传输。\n\n### 帧的概念\n\n- 数据链路层的协议数据单元\n\n- 组成\n\n  - 帧头\n\n    - 源MAC地址、目的MAC地址、类型\n\n  - 数据\n\n  - 帧尾\n\n    - 校验\n\n### 以太网数据帧中的MAC和LLC\n\n- MAC\n\n  - MAC介质访问控制\n\n  - 作用\n\n    - 数据帧的封装/卸装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等。MAC子层的存在屏蔽了不同物理链路种类的差异性。\n\n- LLC\n\n  - LLC逻辑控制访问\n\n  - 作用\n\n    - LLC子层的主要功能为传输可靠性保障和控制，数据包的分段与重组，数据包的顺序传输。\n\n- 注解\n\n  - 该协议位于OSI七层协议中数据链路层，数据链路层分为上层LLC（逻辑链路控制），和下层的MAC（媒体访问控制），MAC主要负责控制与连接物理层的物理介质。在发送数据的时候，MAC协议可以事先判断是否可以发送数据，如果可以发送将给数据加上一些控制信息，最终将数据以及控制信息以规定的格式发送到物理层；在接收数据的时候，MAC协议首先判断输入的信息并是否发生传输错误，如果没有错误，则去掉控制信息发送至LLC（逻辑链路控制）层。\n\n### 数据链路层的两种传输方式\n\n- 单播\n\n- 广播\n\n### 数据链路层的三个基本问题\n\n- 封装成帧\n\n  - 封装成帧就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧，接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。\n\n- 透明传输\n\n  - 透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。\n\n- 差错检测\n\n  - 收到正确的帧就要向发送端发送确认，发送端在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，直到收到对方的确认为止。\n\n### 以太网中的设备\n\n- 集线器\n\n  - 集线器的英文称为“Hub”。“Hub”是“中心”的意思，集线器的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。\n\n- 交换机\n\n  - 交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备。，它可以为接入交换机的任意两个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机。\n\n- 网桥\n\n  - 两个端口的交换机\n\n## 数据链路层的通信协议\n\n### 冲突域和广播域\n\n- 冲突域\n\n  - 交换机的每一个端口都是一个冲突域；冲突域只能发生在一个网段\n\n- 广播域\n\n  - 交换机的所有端口都在一个广播域；广播域在一个或多个网段内发生。\n\n- 区别\n\n  - 1、广播域可以跨网段\n    2、在冲突域中所有的数据传输都是以广播形式；在广播域中，只有广播帧才会被所有主机接收。\n    3、冲突域是基于第一层（物理层），而广播域是机于第二层（数据链路层） 。\n    4、HUB 所有端口都在同一个广播域，冲突域内。Swith所有端口都在同一个广播域内，而每一个端口就是一个冲突域。\n\n### 虚拟局域网（实验）\n\n- VLAN（Virtual Local Area Network）即虚拟局域网，是将一个物理的LAN在逻辑上划分成多个广播域的通信技术。VLAN内的主机间可以直接通信，而VLAN间不能直接通信，从而将广播报文限制在一个VLAN内。\n\n- 优点和目的\n\n  - 1.划分广播域\n\n  - 2.增强局域网的安全性\n\n  - 3.提高健壮性\n\n  - 4.灵活构建工作组\n\n- 划分VLAN的方式\n\n  - 基于端口\n\n    - 给交换机的每个接口配置不同的PVID，当一个数据帧进入交换机接口时，如果没有带VLAN标签，且该接口上配置了PVID，那么，该数据帧就会被打上接口的PVID。如果进入的帧已经带有VLAN标签，那么交换机不会再增加VLAN标签，即使接口已经配置了PVID。\n\n      - Access\n\n        - 只允许通过一个VLAN\n\n      - Trunk\n\n        - 允许通过多个VLAN\n\n      - hybird\n\n  - 基于子网\n\n    - 配置好子网与VLAN映射表，如果交换设备收到的是untagged（不带VLAN标签）帧，交换设备根据报文中的源IP地址信息，确定添加的VLAN ID。将指定网段或IP地址发出的报文在指定的VLAN中传输，减轻了网络管理者的任务量，且有利于管理。\n\n  - 基于MAC地址\n\n    - 先配置好MAC地址和VLAN ID映射关系表，当终端用户的物理位置发生改变，不需要重新配置VLAN。提高了终端用户的安全性和接入的灵活性。\n\n  - 基于协议\n\n    - 将网络中提供的服务类型与VLAN相绑定，方便管理和维护。需要对网络中所有的协议类型和VLAN ID的映射关系表进行初始配置。需要分析各种协议的地址格式并进行相应的转换，消耗交换机较多的资源，速度上稍具劣势。\n\n  - 基于匹配策略\n\n    - 先在交换机上配置好终端的MAC地址和IP地址，并与VLAN关联。只有符合条件的终端才能加入指定VLAN。符合策略的终端加入指定VLAN后，严禁修改IP地址或MAC地址，否则会导致终端从指定VLAN中退出。\n\n### CSMA/CD\n\n- CSMA/CD即载波侦听多路访问/冲突检测，是广播型信道中采用一种随机访问技术的竞争型访问方法，具有多目标地址的特点。总线型网络传输数据\n\n- 四大要点\n\n  - 1.先听再发\n\n  - 2.边听边发\n\n  - 3.冲突停止\n\n  - 4.延迟后发\n\n### PPP\n\n- 点对点通信是一对一信道，因此不会发生碰撞，因此比较简单，采用PPP协议；其中PPP协议就是用户计算机和ISP(互联网服务提供商)进行通信时使用的数据链路层的协议\n\n- PPP 最初设计是为两个对等节点之间的 IP 流量传输提供一种封装协议。\n\n### CRC\n\n- 循环冗余校验\n\n- 是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。\n\n","tags":["笔记","谢希仁教材","思维导图","数据链路层"],"categories":["计算机网络"]},{"title":"计算机网络笔记-谢希仁（网络层）","slug":"计算机网络笔记-谢希仁（第四章-网络层）","url":"/articles/cbfaa914.html","content":"# 思维导图\n![网络层](https://raw.githubusercontent.com/zstu21/image/main/img/JiWang/%E7%BD%91%E7%BB%9C%E5%B1%82.png)\n# 四、网络层\n\n## 网络层的作用\n\n### 网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。\n\n- 提供点到点服务\n\n## 网际层协议IP\n\n### ARP地址解析协议\n\n- 根据IP地址获取物理地址\n\n### ICMP网际控制报文协议\n\n- 通过ICMP传输控制消息，控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。\n\n### IGMP网际组管理协议\n\n- 是用于管理网路协议多播组成员的一种通信协议。IP主机和相邻的路由器利用IGMP来创建多播组的组成员。组播方式解决了单播情况下数据的重复拷贝及带宽的重复占用，也解决了广播方式下带宽资源的浪费。\n\n## IP地址\n\n### IP地址的概念\n\n- IP地址\n\n  - IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。\n\n- 组成\n\n  - 一个IP地址由4个字节，32位组成，一般用点分十进制的方式表现。\n\n- IP地址和MAC地址的区别\n\n  - 1.IP地址是一个逻辑地址，MAC地址是物理地址\n    2.MAC地址是唯一的但是IP地址不是唯一的\n    3.MAC地址主要是工作在第二层，IP地址在网络层\n    4.MAC地址是48位，IP地址一般是32位（v6是128位）\n    5.IP地址的分配取决于网络拓扑，MAC地址分配取决于制造商。\n\n### IP地址的组成\n\n- 主机地址/主机号\n\n  - 标识某一台设备的地址\n\n- 网络地址/网络号\n\n  - 标识某一个网段的地址\n\n- 子网掩码\n\n  - 它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。\n\n  - 网络掩码一般与IP地址结合使用，其中值为1的比特对应IP地址中的网络位；值为0的\n    比特对应IP地址中的主机位，以此来辅助我们识别一个IP地址中的网络位与主机位。\n    即网络掩码中1的个数就是IP地址的网络号的位数，0的个数就是IP地址的主机号的位\n    数。\n\n### IP地址的分类\n\n- A类\n\n  - 一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台。\n    A类IP地址 地址范围1.0.0.1到127.255.255.254。\n\n    - 第一个字节为网络号，第一个字节第一位是0\n\n- B类\n\n  - 一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台。\n    B类IP地址地址范围128.0.0.1-191.255.255.254。\n\n    - 前两个字节为网络号，第一个字节前两位是10\n\n- C类\n\n  - 一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数量较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。\n    C类IP地址范围192.0.0.1-223.255.255.254。\n\n    - 前三个字节为网络号，第一个字节前两位是110\n\n- D类\n\n  - D类IP地址在历史上被叫做多播地址，即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255。\n\n- E类\n\n  - 保留\n\n### IPv6\n\n- 因为IPv4地址满足不了需求，出现匮乏的情况，所以诞生了IPv6地址继续使用。v6地址由128位，16个字节组成，一般表现形式为十六进制。\n\n## 子网划分\n\n### 子网划分\n\n- 概念：因此可以利用子网划分来减少地址浪费，即VLSM (Variable Length Subnet Mask)，可变\n  长子网掩码。将-个大的有类网络，划分成若干个小的子网，使得IP地址的使用更为科学。\n\n\n- 通过修改子网掩码，起到更加精细划分网络号和主机号的作用。\n\n- 网络掩码一般与IP地址结合使用，其中值为1的比特对应IP地址中的网络位；值为0的比特对应IP地址中的主机位，以此来辅助我们识别一个IP地址中的网络位与主机位。即网络掩码中1的个数就是IP地址的网络号的位数，0的个数就是IP地址的主机号的位\n  数。\n\n### VLSM\n\n- VLSM(可变长子网掩码) 是为了有效的使用无类别域间路由（CIDR）和路由汇聚(route summary)来控制路由表的大小，它是网络管理员常用的IP寻址技术，VLSM就是其中的常用方式，可以对子网进行层次化编址，以便最有效的利用现有的地址空间。\n\n### 给你IP地址和子网掩码，求网段\n\n## 网络层的路由\n\n### 路由\n\n- 路由是什么？\n\n  - 路由（routing）是指分组从源到目的地时，决定端到端路径的网络范围的进程 。路由是指导报文转发的路径信息，通过路由可以确认转发IP报文的路径。\n\n    - 路由是网络层最主要的工作任务\n\n- 路由器\n\n  - 网络层的基本设备。\n\n  - 数据转发\n\n  - 一个端口代表一个网段，路由器中存放着通往各个网段的表格，叫做路由表。\n\n- 路由表（routing table）或称路由择域信息库（RIB, Routing Information Base），是一个存储在路由器或者联网计算机中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径\n\n- 网关\n\n  - 网关(Gateway)又称网间连接器、协议转换器。用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。\n\n- 路由获取方式\n\n  - 直连路由\n\n  - 静态路由\n\n  - 动态路由\n\n### 路由的配置方式\n\n- 静态路由\n\n  - 静态路由\n\n    - 由管理员手工配置、配置方便，对系统要求低，适用于拓扑结构简单稳定的小型网络。\n\n  - 缺省路由\n\n    - 是一种特殊的路由，当报文没有在路由表中找到匹配的具体表项时才能使用的路由。\n\n- 动态路由\n\n  - 动态路由\n\n    - 通过动态路由协议来实现不同网段的路由互通\n\n    - 动态路由协议由自己的路由算法，能够自动适应网络拓扑的变化，适用于具有一定数量的三层设备的网络。\n\n  - 动态路由协议\n\n    - RIP*\n\n      - RIP（路由信息协议）\n\n      - 基于矢量的动态路由协议\n\n      - 适用于中小规模的网络拓扑，最大跳数为15\n\n    - OSPF*\n\n      - OSPF（开放式最短路径优先）\n\n      - 基于链路状态的协议\n\n      - 使用SPF算法，计算最短路径。树形协议。\n\n    - BGP\n\n      - BGP是自治系统间的路由协议。自治系统之间的路由协议。\n\n        - 自治系统间的路由协议\n\n    - IS-IS\n\n      - IS-IS（Intermediate System-to-Intermediate System，中间系统到中间系统）与OSPF类似，通。IS-IS是基于路由路划分区域、OSPF利用接口划分。\n\n        - 内部网关协议\n\n    - RIP和OSPF的区别：\n\n      - 1.RIP是基于矢量的协议，OSPF是基于链路状态.\n        2.RIP适用于中小型网络拓扑，OSPF适用于较大规模的网络.\n        3.OSPF支持可变长度子网掩码（VLSM），RIP不支持.\n        4.OSPF的收敛速度比RIP的更加迅速.\n\n","tags":["笔记","谢希仁教材","思维导图","网络层"],"categories":["计算机网络"]},{"title":"AS从入门到精通-笔记（二）（关于按钮一直遵循主题色不能变换颜色）","slug":"AS从入门到精通-笔记（二）（关于按钮一直遵循主题色不能变换颜色）","url":"/articles/fac12f19.html","content":"{% timeline ## AS第二节实验课,blue %}\n<!-- timeline ### 如何解决按钮一直不变换颜色，保持主题紫色的问题（2023年版本的AS） -->\n昨晚搜了一整晚的博客，没找到适合我的AS体质的解决方案。有的说的是改主题，但怎么改都没用，最多是改变了下主题的默认颜色，但是按钮背景色还是遵循主题色；有的说改主题色，比如colorPrimary，colorSecondary之类的，但这还是不能让我自定义button颜色；还有的说用android:backgroundTint，但这个带Tint的好像是跟矢量资源相关的。\n今早在YouTube上搜，有不少视频资源的，居然很快找到了解决方案，这个video也是最近发布的。\n具体解决方案就是其他跟主题相关的都不用改，把`activity_main.xml`中的`Button`改成`androidx.appcompat.widget.AppCompatButton`就行。\n就像这样：\n```xml\n<androidx.appcompat.widget.AppCompatButton\n    android:id=\"@+id/bt_CE\"\n    android:layout_width=\"270px\"\n    android:layout_height=\"270px\"\n    android:text=\"CE\"\n    android:clickable=\"true\"\n    style=\"@style/CustomButtonStyle\"\n    android:textColor=\"@color/black\" />\n```\n{% note info modern %}💡注：按钮自定义样式`style=\"@style/CustomButtonStyle\"`的介绍在下面。{% endnote %}\n<!-- endtimeline -->\n<!-- timeline ### 按钮自定义样式笔记 -->\n然后就是关于按钮自定义样式了，打算记一下笔记。\n如上，这里`style=\"@style/CustomButtonStyle\"`的`CustomButtonStyle`需要定义一下。\n可以在`themes.xml`中添加自定义的样式，也可以自己在`values`文件夹下添加一个`styles.xml`，如图：\n![文件夹图示](https://raw.githubusercontent.com/zstu21/image/main/img/AS/文件夹图示.jpg)\n然后写上如下代码：\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <style name=\"CustomButtonStyle\" parent=\"android:Widget.Button\">\n        <item name=\"android:background\">@drawable/button_selector</item>\n    </style>\n</resources>\n```\n对应的，我们需要在`@drawable`文件夹下创一个`selector`标签的文件，取名为`button_selector`，代码：\n```xml\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item android:drawable=\"@drawable/light_gray_bg\" android:state_pressed=\"false\" />\n    <item android:drawable=\"@drawable/dark_gray_bg\" android:state_pressed=\"true\" />\n</selector>\n```\n意思是按钮按下前是`@drawable/light_gray_bg`样式，按下后是`@drawable/dark_gray_bg`样式，然后我们分别写`@drawable`文件夹下的`light_gray_bg`和`dark_gray_bg`文件。\n`light_gray_bg`文件代码：\n```xml\n<shape xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:shape=\"rectangle\">\n    <solid android:color=\"@color/light_gray\" /> <!-- 这里设置背景颜色 -->\n</shape>\n```\n`dark_gray_bg`文件代码：\n```xml\n<shape xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:shape=\"rectangle\">\n    <solid android:color=\"@color/dark_gray\" /> <!-- 这里设置背景颜色 -->\n</shape>\n```\n{% note info modern %}💡注：这里的`@color/*`的介绍在下面。{% endnote %}\n<!-- endtimeline -->\n\n<!--timeline ### @color/*-->\n在values文件夹下创建`colors.xml`，若以有请忽略（忘了新建项目时它是否自带了）。\n\n写上形如下的代码：\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <color name=\"black\">#FF000000</color>\n    <color name=\"white\">#FFFFFFFF</color>\n    <color name=\"light_gray\">#E6E6E6</color>\n    <color name=\"dark_gray\">#CFCFCF</color>\n</resources>\n```\n\n<!-- endtimeline -->\n\n<!-- timeline ### 插入图片 -->\n在`drawable`文件夹下放图片，然后引用的时候只写文件名，不要带扩展名。\n代码如下：\n```xml\n<ImageView\n        android:id=\"@+id/android\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"400sp\"\n        android:src=\"@drawable/android\"\n        tools:ignore=\"MissingConstraints\" />\n```\n\n{% tip warning faa-horizontal animated-hover %}\n这里有个关于文字可能被图片遮盖而无法显示的问题！\n{% endtip %}\n在 XML 布局文件中，各个组件的顺序会影响它们在界面中的显示顺序以及布局层叠的顺序。\n\n具体来说，后面声明的视图会叠放在前面声明的视图上方。这意味着如果两个视图有重叠部分，后面声明的视图会覆盖在前面声明的视图之上。\n\n比如以下代码：\n```xml\n    <ImageView\n        android:id=\"@+id/android\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"400sp\"\n        android:src=\"@drawable/android\"\n        tools:ignore=\"MissingConstraints\" />\n    <TextView\n        android:id=\"@+id/countdown_text\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"100sp\"\n        android:layout_marginTop=\"184dp\"\n        android:text=\"5\"\n        android:gravity=\"center\"\n        android:textSize=\"80sp\"\n        app:layout_constraintEnd_toEndOf=\"@id/android\"\n        app:layout_constraintHorizontal_bias=\"0.0\"\n        app:layout_constraintStart_toStartOf=\"@id/android\"\n        app:layout_constraintTop_toTopOf=\"@id/android\" />\n```\n\n后声明的TextView会叠放在ImageView上方，也就是说文字显示在图片上放，不会被图片遮盖。\n\n<!-- endtimeline -->\n\n<!-- timeline ### 帮室友debug之activity创建的问题 -->\n室友是直接创建两个文件，一个.xml，一个.java，但是这样是不会被识别成activity的，只会被识别成一个普通的.xml文件。\n\n然后new了一个activity，AS给自动生成.xml和.java文件后，把原先的代码粘贴进去，就可以完美运作了。\n\n因此创建activity还是需要用new。\n<!-- endtimeline -->\n\n<!-- timeline ### 名词理解&解释 -->\n#### module\n首先一个application可以new多个module（这个老师上课就一直在强调）。老师第一节实验课就说了，可以用new module的方法，这样我们之后需要多做几个app的时候就不需要疯狂地new projects了。\n\n#### activity\nactivity相当于是页面。官方点的解释是这样的：\n\nActivity 是 Android 应用程序中的一个核心组件，它代表了用户界面的一个单独屏幕或窗口。每个 Activity 都提供了一个用于与用户交互的界面，可以包括按钮、文本输入框、图像等。\n\n在 Android 应用程序中，通常会有多个 Activity，每个 Activity 负责处理不同的用户界面和交互逻辑。用户可以在这些 Activity 之间进行切换，从而让应用程序能够提供多个不同的功能。\n\n每个 Activity 都有一个生命周期（Lifecycle），包括以下主要阶段：\n1. 创建阶段（onCreate）： Activity 第一次被创建时调用，通常在这里进行初始化操作。\n2. 启动阶段（onStart）： Activity 可见但未获得用户焦点时调用。\n3. 恢复阶段（onResume）： Activity 获得用户焦点时调用。\n4. 暂停阶段（onPause）： Activity 失去用户焦点但仍然可见时调用，常用于释放资源。\n5. 停止阶段（onStop）： Activity 不可见时调用。\n6. 销毁阶段（onDestroy）： Activity 被销毁时调用，通常在这里进行资源释放。\n7. 重新创建阶段（onRestart）： Activity 从停止状态重新启动时调用。\n\nActivity 之间可以通过 Intent 进行通信和切换，可以传递数据和启动其他 Activity。\n\n{% note info modern %}💡注：在 AndroidManifest.xml 文件中，需要在其中注册所有的 Activity，以便系统知道如何管理它们。{% endnote %}\n\n#### Intent\nIntent（意图）是在 Android 中用于在不同组件（如 Activity、Service、BroadcastReceiver 等）之间进行通信的一种机制。它用于描述应用程序中的一个操作，比如启动一个新的 Activity、启动一个 Service、发送一个广播等。\n\n\"Intent\" 这个单词在英语中表示一种意图、目的或者打算。在 Android 开发中，\"Intent\" 被用作一种通信机制，它表示了执行一个特定动作或者实现一个特定目的的意图。\n\nIntent 可以用来：\n1. 启动组件： 通过 Intent 可以启动另一个 Activity、Service、BroadcastReceiver 或者 Content Provider。\n2. 传递数据： 通过 Intent 可以在不同组件之间传递数据，比如字符串、整数、对象等。\n3. 发起动作： 通过 Intent 可以发起某种动作，比如打开一个网页、拨打电话、发送邮件等。\n4. 接收系统广播： 通过注册 BroadcastReceiver 并使用 IntentFilter，你可以接收系统发出的广播消息，比如网络状态变化、电池状态变化等。\n\n总的来说，Intent 是 Android 中实现组件之间通信和协作的重要机制，它能够将不同组件连接起来，实现复杂的应用逻辑。\n\n例如，你可以使用 Intent 启动一个新的 Activity，传递一些数据给它，然后在新的 Activity 中处理这些数据。\n\n```java\nIntent intent = new Intent(MainActivity.this, SecondActivity.class);\nintent.putExtra(\"key\", \"value\"); // 传递数据\nstartActivity(intent); // 启动新的 Activity\n```\n\n{% note modern %}{% p blue, 💡注：这里的`\"key\"`是用于在 Intent 中标识传递数据的唯一字符串。它用于在发送和接收数据时对数据进行标识和匹配。\n当你使用 putExtra() 方法将数据放入 Intent 时，你需要提供一个字符串键（key）和对应的数值或者对象。这个键就是用来在接收端识别和获取对应数据的标识符。%}{% endnote %}\n\n在 SecondActivity 中可以通过获取 Intent 中的数据来处理：\n\n```java\nIntent intent = getIntent();\nString value = intent.getStringExtra(\"key\"); // 获取传递的数据\n```\n\n\n总的来说，Intent 在 Android 开发中是非常重要的一个概念，它是实现组件之间通信的桥梁。\n\n<!-- endtimeline -->\n\n{% endtimeline %}","tags":["笔记","安卓开发","Android Studio","bug & solution"],"categories":["移动应用开发"]},{"title":"ipy","slug":"ipy","url":"/articles/bea199d3.html","content":"\n<iframe src=\"D:/hexo/source/ipynb/s.html\" width=\"100%\" height=\"600\"></iframe>"},{"title":"AS从入门到精通-笔记（一）","slug":"AS从入门到精通-笔记（一）","url":"/articles/cd24574.html","content":"\n{% timeline AS第一节实验课,blue %}\n\n<!-- timeline -->\n\n今天是AS实验课第一节课，完成AS的安装和配置，然后做一个hello world app，算是简单了解一下AS的基本操作。\n\n<!-- endtimeline -->\n\n<!-- timeline 一、安装和配置 -->\n\n网上教程很多，此处不再赘述。\n\n<!-- endtimeline -->\n\n<!-- timeline 二、了解基础界面和操作 -->\n\n这是建好project的界面，其中：\n- `AndroidManifest.xml`:\nAndroid 应用程序的清单文件，包含了应用程序的基本信息、组件声明、权限请求等。\n- `java`：\n存放 Java 代码文件，这些代码是与 Android 应用程序的逻辑和功能相关的。通常包含了各种活动 (Activities)、服务 (Services)、广播接收器 (Broadcast Receivers) 等组件的代码。\n- `res`（资源）：\n  用途：存放 Android 应用程序的资源文件，包括图像、布局、字符串、样式等。\n  这里的资源是与用户界面和应用程序功能相关的静态文件。\n  - `drawable`：\n  用途：存放图像资源文件，如 PNG、JPEG 图片等。\n  这些图像可以在应用程序的界面中使用。\n  - `layout`：\n  用途：存放 XML 文件，用于定义 Android 应用程序的用户  界面布局结构。\n  通过 XML 文件描述界面的结构和元素。\n  - `mipmap`：\n  用途：存放应用程序的应用图标，包括各种不同分辨率的图  标。\n  Android 系统会根据设备的屏幕密度选择合适的图标。\n  - `values`：\n  用途：存放资源值，如字符串、颜色、尺寸等。\n  这使得在应用程序中使用这些值更加灵活。\n  - `xml`：\n  用途：存放一些 XML 文件，用于配置一些非布局、非字符串  等资源，如网络请求配置、权限配置等。\n\n![AS-helloworld界面](https://raw.githubusercontent.com/zstu21/image/main/img/AS/AS-helloworld程序-基础界面.png)\n\n1. 这里的`build.gradle.kts(Project:My_Application)`内容为\n  ```groovy\n  // Top-level build file where you can add   configuration options common to all sub-projects/  modules.\n  plugins {\n      id(\"com.android.application\") version \"8.1.1\" apply false\n  }\n  ```\n  具体解释如下：\n  - `plugins`：这是一个 Groovy 闭包（即代码块），用于配  置项目中的插件。\n  - `id(\"com.android.application\") version \"8.1.1\" apply false`：这行指示了应用了一个 Android 应用程序插件，它告诉 Gradle 构建系统这是一个 Android 应用项目。版本号为 \"8.1.1\" 表示使用的 Android Gradle 插件的版本。最后的 apply false 表示在此处  禁用了插件的自动应用，意味着该插件将不会在当前的 build.gradle 文件中被自动应用，可能会在后续的配置中手动应用。\n  \n2. 这里的`build.gradle.kts(Module :app)`内容为\n```gradle\n  plugins {\n      id(\"com.android.application\")\n  }\n  \n  android {\n      namespace = \"com.example.myapplication\"\n      compileSdk = 33\n  \n      defaultConfig {\n          applicationId = \"com.example.  myapplication\"\n          minSdk = 24\n          targetSdk = 33\n          versionCode = 1\n          versionName = \"1.0\"\n  \n          testInstrumentationRunner = \"androidx.  test.runner.AndroidJUnitRunner\"\n      }\n  \n      buildTypes {\n          release {\n              isMinifyEnabled = false\n              proguardFiles(getDefaultProguardFile  (\"proguard-android-optimize.txt\"),   \"proguard-rules.pro\")\n          }\n      }\n      compileOptions {\n          sourceCompatibility = JavaVersion.  VERSION_1_8\n          targetCompatibility = JavaVersion.  VERSION_1_8\n      }\n  }\n  \n  dependencies {\n  \n      implementation(\"androidx.  appcompat:appcompat:1.6.1\")\n      implementation(\"com.google.android.  material:material:1.8.0\")\n      implementation(\"androidx.  constraintlayout:constraintlayout:2.1.4\")\n      testImplementation(\"junit:junit:4.13.2\")\n      androidTestImplementation(\"androidx.test.  ext:junit:1.1.5\")\n      androidTestImplementation(\"androidx.test.  espresso:espresso-core:3.5.1\")\n  }\n  ```\n  这是一个 Android 项目的 build.gradle 文件内容，它用于配置 Android 项目的构建设置，包括依赖库、编译选项等。\n  - `plugins`:\n  ```gradle\n  plugins {\n      id(\"com.android.application\")\n  }\n  ```\n  这里声明了一个插件，com.android.application 表示这是一个 Android 应用项目，用于构建 Android 应用程序。\n\n  - `android`:\n  ```gradle\n  android {\n      namespace = \"com.example.myapplication\"\n      compileSdk = 33\n      ...\n  }\n  ```\n  `namespace`: 这是 Android 应用程序的命名空间，它指定了我的应用程序的基本包名。在这里，命名空间被设置为 com.example.myapplication。\n  `compileSdk`: 指定了我的项目所使用的编译版本（SDK 版本）。在这里，使用的是 SDK 版本 33。\n  - defaultConfig:\n  ```gradle\n  defaultConfig {\n      applicationId = \"com.example.myapplication\"\n      minSdk = 24\n      targetSdk = 33\n      versionCode = 1\n      versionName = \"1.0\"\n      testInstrumentationRunner = \"androidx.test.  runner.AndroidJUnitRunner\"\n  }\n  ```\n  `applicationId`: 这是我的 Android 应用程序的包名。在这里，它被设置为 com.example.myapplication。\n  `minSdk`: 指定了应用程序支持的最低 Android 版本。在这里，最低支持 Android 版本为 24。\n  `targetSdk`: 指定了应用程序的目标 Android 版本。在这里，目标 Android 版本为 33。\n  `versionCode`: 这是 Android 应用程序的版本代码，用于区分不同版本。\n  `versionName`: 这是 Android 应用程序的版本名，用于显示给用户。\n  `testInstrumentationRunner`: 指定了用于运行单元测试的测试运行器。\n  - buildTypes:\n  ```gradle\n  buildTypes {\n      release {\n          isMinifyEnabled = false\n          proguardFiles(getDefaultProguardFile  (\"proguard-android-optimize.txt\"),   \"proguard-rules.pro\")\n      }\n  }\n  ```\n  这里定义了一个构建类型 release，它用于生成发布版本的 APK 文件。在 release 构建类型中，设置了以下选项：\n  `isMinifyEnabled`: 表示是否启用代码混淆。在发布版本中，一般会开启代码混淆以保护代码。 \n  `proguardFiles(...)`: 指定了 ProGuard 配置文件的位置，用于配置代码混淆规则。\n  - compileOptions:\n  ```gradle\n  compileOptions {\n      sourceCompatibility = JavaVersion.VERSION_1_8\n      targetCompatibility = JavaVersion.VERSION_1_8\n  }\n  ```\n  这里指定了 Java 编译选项，将源代码和目标代码的兼容性设置为 Java 1.8。  \n  - dependencies:\n  ```gradle\n  dependencies {\n      implementation(\"androidx.  appcompat:appcompat:1.6.1\")\n      implementation(\"com.google.android.  material:material:1.8.0\")\n      implementation(\"androidx.  constraintlayout:constraintlayout:2.1.4\")\n      testImplementation(\"junit:junit:4.13.2\")\n      androidTestImplementation(\"androidx.test.  ext:junit:1.1.5\")\n      androidTestImplementation(\"androidx.test.  espresso:espresso-core:3.5.1\")\n  }\n  ```\n  这里列出了项目的依赖项：\n  `implementation`: 用于指定在应用程序运行时需要的库。\n  `testImplementation`: 用于指定在进行单元测试时需要的库。 \n  `androidTestImplementation`: 用于指定在进行 Android 测试时需要的库。\n  以上这些配置文件是一个 Android 项目的基本构建设置，它定义了项目的属性、依赖关系以及编译选项等信息。\n  \n以下是运行后的模拟器界面：\n![AS-helloworld-模拟器界面.png](https://raw.githubusercontent.com/zstu21/image/main/img/AS/AS-helloworld-模拟器界面.png)\n\n<!-- endtimeline -->\n\n<!-- timeline 三、设置Activity生命周期的Log日志 -->\n\n1. 修改代码为\n```java\npackage com.example.myapplication;\n\nimport androidx.appcompat.app.AppCompatActivity;\n\nimport android.os.Bundle;\n\nimport android.util.Log;\n\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Log.d(\"MainActivity\", \"onCreate\");\n    }\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n        Log.d(\"MainActivity\", \"onStart\");\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        Log.d(\"MainActivity\", \"onResume\");\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n        Log.d(\"MainActivity\", \"onPause\");\n    }\n\n    @Override\n    protected void onStop() {\n        super.onStop();\n        Log.d(\"MainActivity\", \"onStop\");\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        Log.d(\"MainActivity\", \"onDestroy\");\n    }\n\n    @Override\n    protected void onRestart() {\n        super.onRestart();\n        Log.d(\"MainActivity\", \"onRestart\");\n    }\n\n\n}\n```\n2. 运行程序如图：<br>\n![运行程序1](https://raw.githubusercontent.com/zstu21/image/main/img/AS/AS-helloworld-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F1.png)可知执行顺序确为onCreate()、onStart()、onResume()。\n3. back返回桌面并清理掉后台，如图：<br>\n![运行程序2](https://raw.githubusercontent.com/zstu21/image/main/img/AS/AS-helloworld-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F2.png)可知执行顺序确为onPause（）、onStop（）、onDestory（）。\n4. 再启动HelloWorld，在LogCat的输出日志中检查输出情况，如图：\n![运行程序3](https://raw.githubusercontent.com/zstu21/image/main/img/AS/AS-helloworld-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F3.png)可知执行顺序确为onRestart（）、onStart（）、onResume（）。\n\n<!-- endtimeline -->\n\n{% endtimeline %}\n\n\n\n","tags":["笔记","安卓开发","Android Studio"],"categories":["移动应用开发"]},{"title":"2023-9-21","slug":"2023-9-21","url":"/articles/e658b399.html","content":"又是一种矛盾的孤寂感。\n昨晚就有这般强烈的体会，周边没有一个真正的知音，自己一遍遍地忙着推开朋友，到真正落寞时又觉得寂寥，然而处在人群中却又不觉热闹。\n准确来说，这样的感觉一直都有，只是昨晚特别强烈，强烈到在思考要不要把全部都推开算了。面对处理不来的情感，我的第一反应便是回避，躲得越远，应该就无需处理了。最好是那人从我的朋友圈子里彻底消失，消失得无影无踪，不然ta一旦再出现，就是再杀我。\n最怕交流时陷入意见无法达成一致的尴尬境地，要么一方妥协同意和解，若是再交流下去只会伤了情面，挫了情谊。可若是总妥协，不免觉着有些累。长达数年的友谊了，到现在都还需磨合再磨合，妥协又妥协。从前觉着友谊是天下最好维系的感情，现在开始感到害怕了，我开始变得不想让任何情感牵制住我，于是逃避所有的情感，不愿维系，不敢面对，只想逃离。\n我不知道别人是什么样的，或许有和我一样只有生活上互帮互助的小伙伴，没有真正知音的人。当然世上也一定有人每每发生一件事都能找得到那么一个人去分享或者求安慰，而得到的回复也深入心坎，因为他们了解彼此，懂彼此。\n或许我这样是正常的，很多人都和我一样，遇着事了并不见得有人能说，说了也没人听，听了也没人懂。也习惯不了说给自己听，拿自己当树洞。\n我也不想去维系让我感到累的关系。合不来的，没必要强迫彼此将意见达成一致，哪怕只是表面上的一致。我是那种不喜欢争论的人，对方若是固执己见，我也懒得继续作争辩，求同存异即可。但“异”其实也不见得如此容易“存”，“小异”是互补，“大异”却是大忌。\n而友谊却又是最难说分别的关系。像恋人，不合适便可以说分手；而友谊不行，若不是吵得不可开交，决定绝交，就说不了分手。慢慢疏远？很难。因为爱情可以说没了喜欢的感觉，而友谊本应是随着时间的积累，情谊便愈加深厚。\n很奇妙，如今连友谊都会困扰我。人被赋予了情感这项技能，就注定了会备受折磨吧。","tags":["随想"],"categories":["个人随笔"]},{"title":"2023-8-20","slug":"2023-8-20","url":"/articles/29e3e46a.html","content":"\n小的时候问大人，对于平淡如死水，和大起大落的生活，选哪一种，大人们都想选平淡的，理由是他们一致认为能平淡地生活已经很不错了。\n\n现在慢慢开始理解这句话，我时常发现，每次就想安安静静地生活都成了一种奢求。我太讨厌噪声了，一个人待着的时候，能保证心如止境，但事实上时常会有外界来打搅这份安宁。无论是不合时宜地开怀大笑，还是莫名其妙的无理取闹，都十分耗费我的精力，所以我总是轻声言语，有时候分贝低到自己都听不清……\n\n很难投入十分的精气神去拥抱这个纷繁芜杂的世界，纵使来往越发熙熙攘攘，我也一直一直在追求一些宁静的死角。煮一盏清茗，焚一炉沉香，醉熏于如雾的氤氲中，或清雅，或浓郁，沉沦在如梦似幻的烟缕里，妄念离，平心静气。","tags":["随想"],"categories":["个人随笔"]},{"title":"2023/8/16","slug":"2023-8-16","url":"/articles/92e99592.html","content":"\n一种强烈的孤独感笼罩了我，它把我包裹得越来越紧，近乎窒息。\n\n好像总是会有这样的时候，挤在熙攘的人堆里，世界却好安静；明明与周围的人摩着肩接着踵，想要什么依靠时，却只能抓来一手虚空。\n\n是呵，人生，注定是一场孤独的旅行。这漫漫的一生，慢慢地教会我们接受孤独，习惯孤独，忍受或是享受孤独……然后在想明白这些之后，真正孤独地完成剩余的旅程，最后孤独地离世。\n\n一直在尝试磨练出一颗足够强大的内心，愿有朝一日能与自己和解，以自己为伴，做自己的慰藉。\n","tags":["随想"],"categories":["个人随笔"]},{"title":"搭建一个QQbot","slug":"搭建一个QQbot","url":"/articles/3aa92d64.html","content":"\n\n\n\n\n\n\n参考博客：\n\n1. [教你如何搭建自己的qq机器人，全是干货！](https://zhuanlan.zhihu.com/p/404342876)（然后在中途遇到了些问题，就又搜了第二篇博客）\n2. [【新版】使用 go-cqhttp 扫码登录，一键接入 ChatGPT 机器人到 QQ 群](https://www.cnblogs.com/tinygeeker/p/17211561.html)\n\n然后就用QQbot发出了第一条消息，很兴奋，纪念一下。\n\n![QQbot第一条消息](https://raw.githubusercontent.com/zstu21/image/main/img/QQbot第一条消息.png)\n\n","tags":["QQbot"],"categories":["QQbot"]},{"title":"科一笔记","slug":"科一笔记","url":"/articles/8b881bbe.html","content":"\n\n\n\n\n\n\n{% note no-icon %}\n\n我现在已经顺利通过科一啦，这是我在考前有一个晚上刷了点题整理的部分笔记（懒得继续完善和补充了）。\n\n内容比较少，但能保证精确（除了错别字）。这些都是做题时从题目解析里文字识别提取出来并做上一些标记而写成的。\n\n考试时间2023.7.4，地点浙江省，所以适用与否自行定夺吧。\n\n完整的一些速成资料在b站、知乎肯定能找得到，我的这篇博客主要是整理了一些针对我个人的易错题，可以做些参考。\n\n{% endnote %}\n\n# 考试内容\n\n{% note blue 'fas fa-bullhorn' flat %}[中华人民共和国道路交通安全法](https://www.66laws.com/fagui/5027.html){% endnote %}\n\n# 注意\n\n{% tip bell %}\n\n1. 注意字符：加速、只需、可以不、可以、直接、便可、即可、仍需\n2. {% span cyan,未达、以外%}\n3. {% span cyan,故障 %} or {% span cyan,不够，需补充 %}\n4. 可以打开远光灯（大概率错）\n5. 倒车（谁说能倒车了？？？）\n6. 注意 {% span cyan,高速路上车道数%}  {% span blue,（但有标志限速的按标志来！！！）%} \n7. 注意区分 机油 和 燃油（汽油）\n8. 保留（比如保留相应学习记录，保留已考科目成绩，不保留啊！！）\n9. 有情况的交通事故是必须得报警的\n10. {% span blue,危险距离！！！%} 比如高速公路上100km/h {% span blue,以上%} ，50米是危险距离！\n\n{% endtip %}\n\n### 扣分\n\n#### 1分：\n\n1. 驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路以外的道路上行驶超过规定时速百分之十以上未达到百分之二十的；\n\n2. 驾驶机动车不按规定会车，或者在高速公路、城市快速路以外的道路上不按规定倒车、掉头的；\n\n3. 驾驶机动车不按规定使用灯光的；\n\n4. 驾驶机动车违反禁令标志、禁止标线指示的；\n\n5. 驾驶机动车载货长度、宽度、高度超过规定的；\n\n6. 驾驶载货汽车载物超过最大允许总质量未达到百分之三十的；\n\n7. 驾驶未按规定定期进行安全技术检验的公路客运汽车、旅游客运汽车、危险物品运输车辆以外的机动车上道路行驶的；\n\n8. 驾驶擅自改变已登记的结构、构造或者特征的载货汽车上道路行驶的；\n\n9. 驾驶机动车在道路上行驶时，机动车驾驶人未按规定系安全带的；\n\n   \n\n   {% tip warning %}无论在什么道路上未按规定系安全带都只扣1分{% endtip %}\n\n10. 驾驶摩托车，不戴安全头盔的。\n\n#### 3分：\n\n1. 驾驶校车、公路客运汽车、旅游客运汽车、7座以上载客汽车以外的其他载客汽车载人超过核定人数百分之二十以上未达到百分之五十的；\n\n2. 驾驶校车、中型以上载客载货汽车、危险物品运输车辆以外的机动车在高速公路、城市快速路以外的道路上行驶超过规定时速百分之二十以上未达到百分之五十的；\n\n3. 驾驶机动车在高速公路或者城市快速路上不按规定车道行驶的；\n\n4. 驾驶机动车不按规定超车、让行，或者在高速公路、城市快速路以外的道路上逆行的；\n\n5. 驾驶机动车遇前方机动车停车排队或者缓慢行驶时，借道超车或者占用对面车道、穿插等候车辆的；\n\n6. 驾驶机动车有拨打、接听手持电话等妨碍安全驾驶的行为的；\n\n   \n\n   {% tip warning %}在哪种道路上打手持电话都扣3分{% endtip %}\n\n7. 驾驶机动车行经人行横道不按规定减速、停车、避让行人的；\n\n8. 驾驶机动车不按规定避让校车的；\n\n9. 驾驶载货汽车载物超过最大允许总质量百分之三十以上未达到百分之五十的，或者违反规定载客的；\n\n10. 驾驶不按规定安装机动车号牌的机动车上道路行驶的；\n\n11. 在道路上车辆发生故障、事故停车后，不按规定使用灯光或者设置警告标志的；\n\n12. 驾驶未按规定定期进行安全技术检验的公路客运汽车、旅游客运汽车、危险物品运输车辆上道路行驶的；\n\n13. 驾驶校车上道路行驶前，未对校车车况是否符合安全技术要求进行检查，或者驾驶存在安全隐患的校车上道路行驶的；\n\n14. 连续驾驶载货汽车超过4小时未停车休息或者停车休息时间少于20分钟的；\n\n15. 驾驶机动车在高速公路上行驶低于规定最低时速的。\n\n#### 6分：\n\n1. 驾驶校车、公路客运汽车、旅游客运汽车载人超过核定人数未达到百分之二十，或者驾驶7座以上载客汽车载人超过核定人数百分之二十以上未达到百分之五十，或者驾驶其他载客汽车载人超过核定人数百分之五十以上未达到百分之百的；\n2. 驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路上行驶超过规定时速未达到百分之二十，或者在高速公路、城市快速路以外的道路上行驶超过规定时速百分之二十以上未达到百分之五十的；\n3. 驾驶校车、中型以上载客载货汽车、危险物品运输车辆以外的机动车在高速公路、城市快速路上行驶超过规定时速百分之二十以上未达到百分之五十，或者在高速公路、城市快速路以外的道路上行驶超过规定时速百分之五十以上的；\n4. 驾驶载货汽车载物超过最大允许总质量百分之五十以上的；\n5. 驾驶机动车载运爆炸物品、易燃易爆化学物品以及剧毒、放射性等危险物品，未按指定的时间、路线、速度行驶或者未悬挂警示标志并采取必要的安全措施的；\n6. 驾驶机动车运载超限的不可解体的物品，未按指定的时间、路线、速度行驶或者未悬挂警示标志的；\n7. 驾驶机动车运输危险化学品，未经批准进入危险化学品运输车辆限制通行的区域的；\n8. 驾驶机动车不按交通信号灯指示通行的；\n9. 机动车驾驶证被暂扣或者扣留期间驾驶机动车的；\n10. 造成致人轻微伤或者财产损失的交通事故后逃逸，尚不构成犯罪的；\n11. 驾驶机动车在高速公路或者城市快速路上违法占用应急车道行驶的。\n\n#### 9分：\n\n1. 驾驶7座以上载客汽车载人超过核定人数百分之五十以上未达到百分之百的；\n2. 驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路 {% span red,以外%} 的道路上行驶超过规定时速百分之五十以上的；\n3. 驾驶机动车在高速公路或者城市快速路上违法停车的；\n4. 驾驶未悬挂机动车号牌或者故意遮挡、污损机动车号牌的机动车上道路行驶的；\n5. 驾驶与准驾车型不符的机动车的；\n6. 未取得 {% span red,校车%} 驾驶资格驾驶校车的；\n7. 连续驾驶中型以上载客汽车、危险物品运输车辆超过4小时未停车休息或者停车休息时间少于20分钟的。\n\n#### 12分：\n\n1. 饮酒后驾驶机动车的；\n2. 造成致人轻伤以上或者死亡的交通事故后逃逸，尚不构成犯罪的；\n3. 使用伪造、变造的机动车号牌、行驶证、驾驶证、校车标牌或者使用其他机动车号牌、行驶证的；\n4. 驾驶校车、公路客运汽车、旅游客运汽车载人超过核定人数百分之二十以上，或者驾驶其他载客汽车载人超过核定人数百分之百以上的；\n5. 驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路上行驶超过规定时速百分之二十以上，或者驾驶其他机动车在高速公路、城市快速路上行驶超过规定时速百分之五十以上的；\n6. 驾驶机动车在高速公路、城市快速路上倒车、逆行、穿越中央分隔带掉头的；\n7. 代替实际机动车驾驶人接受交通违法行为处罚和记分牟取经济利益的。\n\n### 罚款\n\n#### 20-200：\n\n《机动车驾驶证申领和使用规定》规定，申请人在道路上学习驾驶时，有下列情形之一的，由公安机关交通管理部门对 {% span red, 教练员或者随车指导人员%} 处20元以上200以下罚款：\n\n1. 未按照公安机关交通管理部门指定的路线、时间进行的；\n\n2. 未按照本规定第四十二条规定放置、粘贴学车专用标识的。\n\n\n\n《机动车登记规定》规定：已注册登记的机动车所有权发生转让的，现机动车所有人应当自机动车交付之日起 {% span red, 三十日内%} 向 {% span red, 登记地车辆管理所%} 申请转让登记。现机动车所有人未按规定的时限办理转让登记的，由公安机关交通管理部门处警告或者 {% span red, 200元以下%} 罚款。\n\n\n\n#### 特别的：\n\n{% tip bell %}\n\n《机动车驾驶证申领和使用规定》规定：申请人 {% span cyan,隐瞒%} 有关情况或者提供 {% span cyan,虚假%} 材料 {% span cyan,申请%}  {% span blue,校车%} 驾驶资格的，公安机关交通管理部门 {% span cyan,不予受理或者不予办理%} ，处 {% span cyan,500元以下%} 罚款；申请人在 {% span cyan,一年内%} 不得再次申请校车驾驶资格。申请人以 {% span cyan,欺骗、贿赂等%} 不正当手段 {% span cyan,取得校车驾驶资格%} 的，公安机关交通管理部门 {% span cyan,撤销%}  {% span blue,校车%} 驾驶资格，处 {% span cyan,2000元以下%} 罚款；申请人在 {% span cyan,三年内%} 不得再次申请校车驾驶资格。\n\n《机动车驾驶证申领和使用规定》规定:申申请人在考试过程中有 {% span cyan,贿赂、舞弊%} 行为的,取消考试资格, {% span cyan,已经通过过考试的其他科目成绩无效%} ,公安机关交通管理部门处ニ千元以下罚款;申请人在 {% span cyan,一年内%} 不得再次申领机动车驾驶证。\n\n{% endtip %}\n\n#### 200-2000：\n\n《道路交通安全法》第九十九条： {% span red,机动车%} 行驶超过规定时速 {% span red,50％%} 的，由公安交通管理部门处200元以上2000元以下罚款，可以并处吊销机动车驾驶证。\n\n《道路交通安全法》第一百条：驾驶 {% span red,拼装%} 的机动车或者 {% span red,已达到报废标准%} 的机动车上道路行驶的，公安机关交通管理部门应当予以收缴，强制报废。对驾驶前款所列机动车上道路行驶的驾驶人，处200元以上2000元以下罚款，并 {% span red,吊销机动车驾驶证%} 。\n\n\n\n《中华人民共和国道路交通安全法》第九十九条：有下列行为之一的，由公安机关交通管理部门处二百元以上二千元以下罚款：\n\n1. 未取得机动车驾驶证、机动车驾驶证被吊销或者机动车驾驶证被暂扣期间驾驶机动车的； {% span blue,（可以并处十五日以下拘留）%} \n2. 将机动车交由未取得机动车驾驶证或者机动车驾驶证被吊销、暂扣的人驾驶的； {% span blue,（可以并处吊销机动车驾驶证）%} \n3. 造成交通事故后逃逸，尚不构成犯罪的； {% span blue,（可以并处十五日以下拘留）%} \n4. 机动车行驶超过规定时速百分之五十的； {% span blue,（可以并处吊销机动车驾驶证）%} \n5. 强迫机动车驾驶人违反道路交通安全法律、法规和机动车安全驾驶要求驾驶机动车，造成交通事故，尚不构成犯罪的； {% span blue,（可以并处十五日以下拘留）%} \n6. 违反交通管制的规定强行通行，不听劝阻的； {% span blue,（可以并处十五日以下拘留）%} \n7. 故意损毁、移动、涂改交通设施，造成危害后果，尚不构成罪的； {% span blue,（可以并处十五日以下拘留）%} \n8. 非法拦截、扣留机动车辆，不听劝阻，造成交通严重阻塞或者较大财产损失的。 {% span blue,（可以并处十五日以下拘留）%} \n9. 行为人有前款第二项、第四项情形之一的，可以并处吊销机动车驾驶证；有第一项、第三项、第五项至第八项情形之一的，可以并处十五日以下拘留。\n\n\n\n#### 几倍几万\n\n1. 《机动车驾驶证申领和使用规定》规定：机动车驾驶人参加审验教育时在签注学习记录、学习过程中弄虚作假的，相应学习记录无效，重新参加审验学习，由公安机关交通管理部门处一千元以下罚款。代替实际机动车驾驶人参加审验教育的，由公安机关交通管理部门处二千元以下罚款。组织他人实施前两款行为之一，有违法所得的，由公安机关交通管理部门处违法所得三倍以下罚款，但最高不超过二万元；没有违法所得的，由公安机关交通管理部门处二万元以下罚款。\n2. 《道路交通安全法》第九十八条：机动车所有人、管理人未按照国家规定投保机动车第三者责任强制保险的，由公安机关交通管理部门扣留车辆至依照规定投保后，并处依照规定投保最低责任限额应缴纳的保险费的二倍罚款。\n\n### 几日\n\n#### 三日：\n\n1. 《道路交通事故处理程序规定》第十八条： {% span red,发生道路交通事故后当事人未报警%} ，在事故现场撤除后，当事人又报警请求公安机关交通管理部门处理的，公安机关交通管理部门应当按照本规定第十六条规定的记录内容予以记录，并在三日内作出是否接受案件的决定。\n\n#### 七日：\n\n1. 《道路交通安全违法行为记分管理办法》规定：机动车驾驶人在一个记分周期内累积记分满12分的，应当参加为期 {% span red,七天%} 的道路交通安全法律、法规和相关知识学习。其中，大型客车、重型牵引挂车、城市公交车、中型客车、大型货车驾驶人应当参加为期三十天的道路交通安全法律、法规和相关知识学习。\n\n#### 十五日：\n\n1. 《机动车登记规定》规定：机动车号牌灭失、丢失或者损毁的，机动车所有人应当向登记地车辆管理所申请补领、换领。申请时，机动车所有人应当确认申请信息并提交身份证明。车辆管理所应当审查提交的证明、凭证，收回未灭失、丢失或者损毁的号牌，自受理之日起十五日内补发、换发号牌，原机动车号牌号码不变。补发、换发号牌期间，申请人可以申领有效期不超过十五日的临时行驶车号牌。补领、换领机动车号牌的，原机动车号牌作废，不得继续使用。\n\n#### 三十日：\n\n1. 《道路交通安全违法行为记分管理办法》规定：机动车驾驶人在一个记分周期内累积记分满12分的，应当参加为期七天的道路交通安全法律、法规和相关知识学习。其中，大型客车、重型牵引挂车、城市公交车、中型客车、大型货车驾驶人应当参加为期 {% span red,三十天%} 的道路交通安全法律、法规和相关知识学习。\n\n### 年龄-申请准驾车型\n\n{% p red,年满20周岁初次可以申领大型货车，中型客车只能通过增驾取得，不得初次申领。%}\n\n《机动车驾驶证申领和使用规定》规定，\n\n1. 申请小型汽车、小型自动挡汽车、残疾人专用小型自动挡载客汽车、轻便摩托车准驾车型的，在18周岁以上；\n2. 申请低速载货汽车、三轮汽车、普通三轮摩托车、普通二轮摩托车或者轮式专用机械车准驾车型的，在18周岁以上，60周岁以下；\n3. 申请城市公交车、中型客车、大型货车、轻型牵引挂车、无轨电车或者有轨电车准驾车型的，在20周岁以上，60周岁以下；\n4. 申请大型客车、重型牵引挂车准驾车型的，在22周岁以上，60周岁以下；\n5. 初次申领机动车驾驶证的，可以申请准驾车型为城市公交车、大型货车、小型汽车、小型自动挡汽车、低速载货汽车、三轮汽车、残疾人专用小型自动挡载客汽车、普通三轮摩托车、普通二轮摩托车、轻便摩托车、轮式专用机械车、无轨电车、有轨电车的机动车驾驶证。\n\n{% p green,《机动车驾驶证申领和使用规定》规定：初次申领机动车驾驶证的，可以申请准驾车型为城市公交车、大型货车、小型汽车、小型自动挡汽车、低速载货汽车、三轮汽车、残疾人专用小型自动挡载客汽车、普通三轮摩托车、普通二轮摩托车、轻便摩托车、轮式专用机械车、无轨电车、有轨电车的机动车驾驶证。%}\n\n### 车辆管理所\n\n《机动车驾驶证申领和使用规定》规定，申领机动车驾驶证的人，按照下列规定向车辆管理所提出申请：\n\n1. 在户籍所在地居住的，应当在户籍所在地提出申请；\n2. 在户籍所在地以外居住的，可以在居住地提出申请；\n3. 现役军人（含武警），应当在部队驻地提出申请；\n4. 境外人员，应当在居留地或者居住地提出申请；\n5. 申请增加准驾车型的，应当在所持机动车驾驶证 {% span red,核发地%} 提出申请；\n6. 接受全日制驾驶职业教育，申请增加大型客车、重型牵引挂车准驾车型的，应当在接受教育地提出申请。\n\n### 急弯等如何行驶\n\n《中华人民共和国道路交通安全法》第五十九条机动车在 {% span red,夜间%} 通过 {% span red,急弯、坡路、拱桥、人行横道或者没有交通信号灯控制的路口%} 时，应当 {% span red,交替使用远近光灯%} 示意。\n机动车驶近 {% span red,急弯、坡道顶端等%} 影响安全视距的路段以及 {% span red,超车%} 或者 {% span red,遇有紧急情况%} 时，应当 {% span red,减速%} 慢行，并{% span red,鸣喇叭%} 示意。\n\n### 标志\n\n1. 只准直行-圆形 & 直行单行路-方形\n\n### 危险驾驶罪\n\n1. 追逐竞驶，情节恶劣的；\n1. 醉酒驾驶机动车的；\n1. 从事校车业务或者旅客运输，严重超过额定乘员载客，或者严重超过规定时速行驶的；\n1. 违反危险化学品安全管理规定运输危险化学品，危及公共安全的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["驾考"],"categories":["驾考"]},{"title":"Hello World","slug":"hello-world","url":"/articles/4a17b156.html","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]